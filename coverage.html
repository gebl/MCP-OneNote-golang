
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>onenote-mcp-server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/AuthTools.go (25.5%)</option>
				
				<option value="file1">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/NotebookResources.go (17.7%)</option>
				
				<option value="file2">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/NotebookTools.go (5.0%)</option>
				
				<option value="file3">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/PageResources.go (0.0%)</option>
				
				<option value="file4">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/PageTools.go (5.3%)</option>
				
				<option value="file5">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/SectionResources.go (0.0%)</option>
				
				<option value="file6">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/TestTools.go (13.3%)</option>
				
				<option value="file7">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/main.go (1.1%)</option>
				
				<option value="file8">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/resources.go (0.0%)</option>
				
				<option value="file9">github.com/gebl/onenote-mcp-server/cmd/onenote-mcp-server/tools.go (70.6%)</option>
				
				<option value="file10">github.com/gebl/onenote-mcp-server/internal/auth/auth.go (19.7%)</option>
				
				<option value="file11">github.com/gebl/onenote-mcp-server/internal/auth/manager.go (41.2%)</option>
				
				<option value="file12">github.com/gebl/onenote-mcp-server/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file13">github.com/gebl/onenote-mcp-server/internal/authorization/adapters.go (0.0%)</option>
				
				<option value="file14">github.com/gebl/onenote-mcp-server/internal/authorization/authorization.go (85.1%)</option>
				
				<option value="file15">github.com/gebl/onenote-mcp-server/internal/authorization/context.go (0.0%)</option>
				
				<option value="file16">github.com/gebl/onenote-mcp-server/internal/authorization/wrapper.go (0.0%)</option>
				
				<option value="file17">github.com/gebl/onenote-mcp-server/internal/config/config.go (77.2%)</option>
				
				<option value="file18">github.com/gebl/onenote-mcp-server/internal/graph/client.go (51.4%)</option>
				
				<option value="file19">github.com/gebl/onenote-mcp-server/internal/graph/http.go (91.4%)</option>
				
				<option value="file20">github.com/gebl/onenote-mcp-server/internal/graph/utils.go (83.3%)</option>
				
				<option value="file21">github.com/gebl/onenote-mcp-server/internal/http/helpers.go (93.4%)</option>
				
				<option value="file22">github.com/gebl/onenote-mcp-server/internal/logging/logger.go (86.6%)</option>
				
				<option value="file23">github.com/gebl/onenote-mcp-server/internal/notebooks/notebooks.go (1.0%)</option>
				
				<option value="file24">github.com/gebl/onenote-mcp-server/internal/pages/pages.go (6.7%)</option>
				
				<option value="file25">github.com/gebl/onenote-mcp-server/internal/resources/descriptions.go (100.0%)</option>
				
				<option value="file26">github.com/gebl/onenote-mcp-server/internal/sections/groups.go (0.0%)</option>
				
				<option value="file27">github.com/gebl/onenote-mcp-server/internal/sections/sections.go (0.3%)</option>
				
				<option value="file28">github.com/gebl/onenote-mcp-server/internal/utils/image.go (88.9%)</option>
				
				<option value="file29">github.com/gebl/onenote-mcp-server/internal/utils/progress.go (95.7%)</option>
				
				<option value="file30">github.com/gebl/onenote-mcp-server/internal/utils/tool_helpers.go (0.0%)</option>
				
				<option value="file31">github.com/gebl/onenote-mcp-server/internal/utils/validation.go (73.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package main

import (
        "context"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/auth"
        "github.com/gebl/onenote-mcp-server/internal/authorization"
        "github.com/gebl/onenote-mcp-server/internal/resources"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

// registerAuthTools registers authentication-related MCP tools
func registerAuthTools(s *server.MCPServer, authManager *auth.AuthManager, authConfig *authorization.AuthorizationConfig, cache authorization.NotebookCache, quickNoteConfig authorization.QuickNoteConfig) <span class="cov8" title="1">{
        // getAuthStatus: Get current authentication status
        getAuthStatusTool := mcp.NewTool(
                "getAuthStatus",
                mcp.WithDescription(resources.MustGetToolDescription("getAuthStatus")),
        )
        getAuthStatusHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                logger := utils.NewToolLogger("getAuthStatus")

                if authManager == nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError("Authentication manager not available"), nil
                }</span>

                <span class="cov0" title="0">status := authManager.GetAuthStatus()

                logger.LogSuccess("authenticated", status.Authenticated)
                return utils.ToolResults.NewJSONResult("getAuthStatus", status), nil</span>
        }
        // getAuthStatus doesn't require authorization since it's needed to check auth state
        <span class="cov8" title="1">s.AddTool(getAuthStatusTool, server.ToolHandlerFunc(getAuthStatusHandler))

        // refreshToken: Manually refresh authentication token
        refreshTokenTool := mcp.NewTool(
                "refreshToken",
                mcp.WithDescription(resources.MustGetToolDescription("refreshToken")),
        )
        refreshTokenHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                logger := utils.NewToolLogger("refreshToken")

                if authManager == nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError("Authentication manager not available"), nil
                }</span>

                <span class="cov0" title="0">status, err := authManager.RefreshToken()
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(err)
                        return utils.ToolResults.NewError("refresh token", err), nil
                }</span>

                <span class="cov0" title="0">logger.LogSuccess()
                return utils.ToolResults.NewJSONResult("refreshToken", status), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(refreshTokenTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("refreshToken", refreshTokenHandler, authConfig, cache, quickNoteConfig)))

        // initiateAuth: Start new authentication flow
        initiateAuthTool := mcp.NewTool(
                "initiateAuth",
                mcp.WithDescription(resources.MustGetToolDescription("initiateAuth")),
        )
        initiateAuthHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                logger := utils.NewToolLogger("initiateAuth")

                if authManager == nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError("Authentication manager not available"), nil
                }</span>

                <span class="cov0" title="0">session, err := authManager.InitiateAuth()
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(err)
                        return utils.ToolResults.NewError("initiate authentication", err), nil
                }</span>

                // Create response with user instructions
                <span class="cov0" title="0">response := map[string]interface{}{
                        "authUrl":         session.AuthURL,
                        "instructions":    "Visit this URL in your browser to authenticate with Microsoft. The authentication will complete automatically.",
                        "localServerPort": session.LocalServerPort,
                        "timeoutMinutes":  session.TimeoutMinutes,
                        "state":           session.State,
                }

                logger.LogSuccess("auth_url_generated", true)
                return utils.ToolResults.NewJSONResult("initiateAuth", response), nil</span>
        }
        // initiateAuth doesn't require authorization since it's needed to establish auth
        <span class="cov8" title="1">s.AddTool(initiateAuthTool, server.ToolHandlerFunc(initiateAuthHandler))

        // clearAuth: Clear stored authentication tokens
        clearAuthTool := mcp.NewTool(
                "clearAuth",
                mcp.WithDescription(resources.MustGetToolDescription("clearAuth")),
        )
        clearAuthHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                logger := utils.NewToolLogger("clearAuth")

                if authManager == nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError("Authentication manager not available"), nil
                }</span>

                <span class="cov0" title="0">err := authManager.ClearAuth()
                if err != nil </span><span class="cov0" title="0">{
                        logger.LogError(err)
                        return utils.ToolResults.NewError("clear authentication", err), nil
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "success": true,
                        "message": "Authentication tokens cleared successfully. Use initiateAuth to re-authenticate.",
                }

                logger.LogSuccess()
                return utils.ToolResults.NewJSONResult("clearAuth", response), nil</span>
        }
        // clearAuth doesn't require authorization since it clears auth state
        <span class="cov8" title="1">s.AddTool(clearAuthTool, server.ToolHandlerFunc(clearAuthHandler))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// OneNote MCP Server Notebook Resources
//
// This file implements MCP (Model Context Protocol) notebook-related resources for accessing
// Microsoft OneNote data through a hierarchical REST-like URI structure. The resources provide
// AI models with structured access to OneNote notebooks.
//
// ## Notebook Resource URIs
//
// ### Available Notebook Resource URIs
//
// #### 1. List All Notebooks
// **URI:** `onenote://notebooks`
// **Purpose:** Get a complete list of all accessible OneNote notebooks
// **Returns:** JSON array of notebook objects with metadata (IDs, names, creation dates, etc.)
//
// #### 2. Get Specific Notebook Details
// **URI:** `onenote://notebooks/{NotebookDisplayName}`
// **Purpose:** Get detailed information about a specific notebook by its display name
// **Parameters:**
//   - `{NotebookDisplayName}`: URL-encoded display name of the notebook (spaces become %20)
// **Returns:** JSON object with comprehensive notebook metadata
//
// Note: Section-related resources have been moved to SectionResources.go for better organization.

package main

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "strings"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/notebooks"
)

// registerNotebookResources registers all notebook-related MCP resources
func registerNotebookResources(s *server.MCPServer, graphClient *graph.Client, cfg *config.Config) <span class="cov0" title="0">{
        logging.MainLogger.Debug("Starting notebook resource registration process")

        // Register notebooks resource - list all notebooks with full metadata
        logging.MainLogger.Debug("Creating notebooks resource",
                "resource_uri", "onenote://notebooks",
                "resource_type", "static_resource")
        notebooksResource := mcp.NewResource(
                "onenote://notebooks",
                "OneNote Notebooks",
                mcp.WithResourceDescription("List of all OneNote notebooks accessible to the authenticated user with comprehensive metadata including timestamps, ownership, links, and properties"),
                mcp.WithMIMEType("application/json"),
        )

        s.AddResource(notebooksResource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Resource handler invoked",
                        "resource_uri", "onenote://notebooks",
                        "request_uri", request.Params.URI,
                        "handler_type", "notebooks_list")

                // Create specialized client for notebooks
                notebookClient := notebooks.NewNotebookClient(graphClient)
                logging.MainLogger.Debug("Created notebook client for resource request")

                // Get notebooks with detailed information
                logging.MainLogger.Debug("Calling ListNotebooksDetailed from resource handler")
                notebooks, err := notebookClient.ListNotebooksDetailed()
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to list detailed notebooks for resource",
                                "error", err,
                                "resource_uri", "onenote://notebooks")
                        return nil, fmt.Errorf("failed to list detailed notebooks: %v", err)
                }</span>

                <span class="cov0" title="0">logging.MainLogger.Debug("Retrieved detailed notebooks for resource",
                        "count", len(notebooks),
                        "resource_uri", "onenote://notebooks")

                // Convert to JSON
                logging.MainLogger.Debug("Marshaling notebooks data to JSON")
                jsonData, err := json.Marshal(notebooks)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to marshal detailed notebooks to JSON",
                                "error", err,
                                "notebooks_count", len(notebooks))
                        return nil, fmt.Errorf("failed to marshal detailed notebooks: %v", err)
                }</span>

                <span class="cov0" title="0">responseSize := len(jsonData)
                logging.MainLogger.Debug("Successfully prepared resource response",
                        "resource_uri", "onenote://notebooks",
                        "response_size_bytes", responseSize,
                        "notebooks_count", len(notebooks))

                return []mcp.ResourceContents{
                        mcp.TextResourceContents{
                                URI:      "onenote://notebooks",
                                MIMEType: "application/json",
                                Text:     string(jsonData),
                        },
                }, nil</span>
        })
        <span class="cov0" title="0">logging.MainLogger.Debug("Registered notebooks resource successfully",
                "resource_uri", "onenote://notebooks")

        // Register notebook by name resource template
        logging.MainLogger.Debug("Creating notebook by name resource template",
                "template_pattern", "onenote://notebooks/{name}",
                "resource_type", "template_resource")
        notebookByNameTemplate := mcp.NewResourceTemplate(
                "onenote://notebooks/{name}",
                "OneNote Notebook by Name",
                mcp.WithTemplateDescription("Get a specific OneNote notebook by its display name with comprehensive metadata including timestamps, ownership, links, and properties"),
                mcp.WithTemplateMIMEType("application/json"),
        )

        s.AddResourceTemplate(notebookByNameTemplate, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Resource template handler invoked",
                        "template_pattern", "onenote://notebooks/{name}",
                        "request_uri", request.Params.URI,
                        "handler_type", "notebook_by_name")

                // Extract notebook name from URI
                notebookName := extractNotebookNameFromURI(request.Params.URI)
                if notebookName == "" </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Invalid notebook name in URI",
                                "request_uri", request.Params.URI,
                                "extracted_name", notebookName)
                        return nil, fmt.Errorf("invalid notebook name in URI: %s", request.Params.URI)
                }</span>

                <span class="cov0" title="0">logging.MainLogger.Debug("Extracted notebook name from URI",
                        "notebook_name", notebookName,
                        "request_uri", request.Params.URI)

                // Create specialized client for notebooks
                notebookClient := notebooks.NewNotebookClient(graphClient)
                logging.MainLogger.Debug("Created notebook client for notebook by name resource request")

                // Get detailed notebook information by name using the existing function
                logging.MainLogger.Debug("Calling GetDetailedNotebookByName from resource handler",
                        "notebook_name", notebookName)
                detailedNotebook, err := notebookClient.GetDetailedNotebookByName(notebookName)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to get detailed notebook for resource",
                                "notebook_name", notebookName,
                                "error", err,
                                "request_uri", request.Params.URI)
                        return nil, fmt.Errorf("failed to get detailed notebook '%s': %v", notebookName, err)
                }</span>

                <span class="cov0" title="0">logging.MainLogger.Debug("Retrieved detailed notebook by name",
                        "notebook_name", notebookName,
                        "attributes_count", len(detailedNotebook),
                        "request_uri", request.Params.URI)

                logging.MainLogger.Debug("Marshaling detailed notebook data to JSON",
                        "notebook_name", notebookName)
                jsonData, err := json.Marshal(detailedNotebook)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to marshal detailed notebook to JSON",
                                "error", err,
                                "notebook_name", notebookName,
                                "attributes_count", len(detailedNotebook))
                        return nil, fmt.Errorf("failed to marshal detailed notebook: %v", err)
                }</span>

                <span class="cov0" title="0">responseSize := len(jsonData)
                logging.MainLogger.Debug("Successfully prepared notebook by name resource response",
                        "notebook_name", notebookName,
                        "request_uri", request.Params.URI,
                        "response_size_bytes", responseSize,
                        "attributes_count", len(detailedNotebook))

                return []mcp.ResourceContents{
                        mcp.TextResourceContents{
                                URI:      request.Params.URI,
                                MIMEType: "application/json",
                                Text:     string(jsonData),
                        },
                }, nil</span>
        })
        <span class="cov0" title="0">logging.MainLogger.Debug("Registered notebook by name resource template successfully",
                "template_pattern", "onenote://notebooks/{name}")

        logging.MainLogger.Debug("Notebook resource registration completed successfully",
                "resources_registered", 2,
                "static_resources", 1,
                "template_resources", 1)</span>
}

// Notebook-specific URI extraction functions

// extractNotebookIDFromURI extracts the notebook ID from a URI like "onenote://notebooks/{id}"
func extractNotebookIDFromURI(uri string) string <span class="cov8" title="1">{
        // URI format: onenote://notebooks/{id}
        parts := strings.Split(uri, "/")
        if len(parts) &gt;= 3 &amp;&amp; parts[0] == "onenote:" &amp;&amp; parts[2] == "notebooks" &amp;&amp; len(parts) &gt;= 4 </span><span class="cov8" title="1">{
                return parts[3]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// extractNotebookNameFromURI extracts the notebook name from a URI like "onenote://notebooks/{name}"
func extractNotebookNameFromURI(uri string) string <span class="cov8" title="1">{
        // URI format: onenote://notebooks/{name}
        parts := strings.Split(uri, "/")
        if len(parts) &gt;= 4 &amp;&amp; parts[0] == "onenote:" &amp;&amp; parts[2] == "notebooks" </span><span class="cov8" title="1">{
                // URL decode the notebook name since it's part of a URI
                decodedName, err := url.QueryUnescape(parts[3])
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Warn("Failed to URL decode notebook name, using raw value",
                                "raw_name", parts[3],
                                "error", err)
                        return parts[3] // fallback to raw value
                }</span>
                <span class="cov8" title="1">logging.MainLogger.Debug("URL decoded notebook name",
                        "raw_name", parts[3],
                        "decoded_name", decodedName)
                return decodedName</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package main

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/authorization"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/notebooks"
        "github.com/gebl/onenote-mcp-server/internal/resources"
        "github.com/gebl/onenote-mcp-server/internal/sections"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

// Context keys are now imported from utils to avoid duplication
const (
        mcpServerKey     = utils.MCPServerKey
        progressTokenKey = utils.ProgressTokenKey
)

// SectionItem represents a section or section group in the hierarchical tree
type SectionItem struct {
        Type     string        `json:"type"`     // "section" or "sectionGroup"
        ID       string        `json:"id"`       // Unique identifier
        Name     string        `json:"name"`     // Display name
        Children []SectionItem `json:"children"` // Child items (nil for sections, populated for section groups)
}

// registerNotebookTools registers notebook and section-related MCP tools
func registerNotebookTools(s *server.MCPServer, graphClient *graph.Client, notebookCache *NotebookCache, authConfig *authorization.AuthorizationConfig, cache authorization.NotebookCache, quickNoteConfig authorization.QuickNoteConfig) <span class="cov8" title="1">{
        // Create specialized clients for notebook and section operations
        notebookClient := notebooks.NewNotebookClient(graphClient)
        sectionClient := sections.NewSectionClient(graphClient)

        // listNotebooks: List all OneNote notebooks for the user
        listNotebooksTool := mcp.NewTool(
                "listNotebooks",
                mcp.WithDescription(resources.MustGetToolDescription("listNotebooks")),
        )
        listNotebooksHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Debug("listNotebooks called with no parameters")

                notebooks, err := notebookClient.ListNotebooksDetailed()
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("listNotebooks failed", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to list notebooks: %v", err)), nil
                }</span>

                // Apply authorization filtering
                <span class="cov0" title="0">originalCount := len(notebooks)
                if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                        notebooks = authConfig.FilterNotebooks(notebooks)
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("listNotebooks completed", 
                        "duration", elapsed, 
                        "original_count", originalCount,
                        "filtered_count", len(notebooks))

                // Handle empty results gracefully
                if len(notebooks) == 0 </span><span class="cov0" title="0">{
                        return mcp.NewToolResultText("[]"), nil
                }</span>

                // Create a JSON array with id, name, default status flags, and permission info for each notebook
                <span class="cov0" title="0">type NotebookInfo struct {
                        ID                    string `json:"id"`
                        Name                  string `json:"name"`
                        IsAPIDefault          bool   `json:"isAPIDefault"`          // True if this is the default notebook according to Microsoft Graph API
                        IsConfigDefault       bool   `json:"isConfigDefault"`       // True if this matches the configured default notebook name
                        Permission            string `json:"permission"`            // Permission level for this notebook (none, read, write)
                        PermissionSource      string `json:"permissionSource"`      // Source of permission (exact, pattern, default)
                        CanSelect             bool   `json:"canSelect"`             // True if user can select this notebook
                }

                var notebookList []NotebookInfo
                for _, notebook := range notebooks </span><span class="cov0" title="0">{
                        id, _ := notebook["notebookId"].(string)
                        displayName, _ := notebook["displayName"].(string)
                        
                        // Check if this is the API default notebook
                        isAPIDefault := false
                        if apiDefaultValue, exists := notebook["isDefault"].(bool); exists </span><span class="cov0" title="0">{
                                isAPIDefault = apiDefaultValue
                        }</span>
                        
                        // Check if this matches the configured default notebook name
                        <span class="cov0" title="0">isConfigDefault := false
                        if graphClient.Config != nil &amp;&amp; graphClient.Config.NotebookName != "" </span><span class="cov0" title="0">{
                                isConfigDefault = displayName == graphClient.Config.NotebookName
                        }</span>

                        // Get permission information
                        <span class="cov0" title="0">var permission string = "read"      // Default fallback
                        var permissionSource string = "default"
                        var canSelect bool = true
                        
                        if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                                actualPermission, _, source := authConfig.GetNotebookPermissionWithSource(displayName)
                                permission = string(actualPermission)
                                permissionSource = source
                                canSelect = actualPermission != authorization.PermissionNone &amp;&amp; actualPermission != ""
                        }</span>

                        <span class="cov0" title="0">notebookList = append(notebookList, NotebookInfo{
                                ID:                    id,
                                Name:                  displayName,
                                IsAPIDefault:          isAPIDefault,
                                IsConfigDefault:       isConfigDefault,
                                Permission:            permission,
                                PermissionSource:      permissionSource,
                                CanSelect:             canSelect,
                        })</span>
                }

                // Marshal to JSON
                <span class="cov0" title="0">jsonBytes, err := json.Marshal(notebookList)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("Failed to marshal notebooks to JSON", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to format notebooks: %v", err)), nil
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(listNotebooksTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                return authorization.AuthorizedToolHandler("listNotebooks", listNotebooksHandler, authConfig, cache, quickNoteConfig)(ctx, req)
        }</span>)

        // createSection: Create a new section in a notebook or section group
        <span class="cov8" title="1">createSectionTool := mcp.NewTool(
                "createSection",
                mcp.WithDescription(resources.MustGetToolDescription("createSection")),
                mcp.WithString("containerID", mcp.Description("Notebook ID or Section Group ID to create the section in. Optional - if left blank, automatically uses the server's configured default notebook.")),
                mcp.WithString("displayName", mcp.Required(), mcp.Description("Display name for the new section (cannot contain: ?*\\/:&lt;&gt;|&amp;#''%%~)")),
        )
        createSectionHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("MCP Tool: createSection", "operation", "createSection", "type", "tool_invocation")

                containerID := req.GetString("containerID", "")
                if containerID == "" </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("createSection no containerID provided, using default notebook")
                        var err error
                        containerID, err = notebooks.GetDefaultNotebookID(graphClient, graphClient.Config)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("createSection failed to get default notebook", "error", err)
                                return mcp.NewToolResultError(fmt.Sprintf("No containerID provided and failed to get default notebook: %v", err)), nil
                        }</span>
                }

                <span class="cov0" title="0">displayName, err := req.RequireString("displayName")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSection missing displayName", "error", err)
                        return mcp.NewToolResultError("displayName is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("createSection parameters", "containerID", containerID, "displayName", displayName)

                // Validate display name for illegal characters
                illegalChars := []string{"?", "*", "\\", "/", ":", "&lt;", "&gt;", "|", "&amp;", "#", "'", "'", "%", "~"}
                for _, char := range illegalChars </span><span class="cov0" title="0">{
                        if strings.Contains(displayName, char) </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("createSection displayName contains illegal character", "character", char, "display_name", displayName)
                                suggestedName := utils.SuggestValidName(displayName, char)
                                return mcp.NewToolResultError(fmt.Sprintf("displayName contains illegal character '%s'. Illegal characters are: ?*\\/:&lt;&gt;|&amp;#''%%%%~\n\nSuggestion: Try using '%s' instead of '%s'.\n\nSuggested valid name: '%s'", char, utils.GetReplacementChar(char), char, suggestedName)), nil
                        }</span>
                }
                <span class="cov0" title="0">logging.ToolsLogger.Debug("createSection displayName validation passed")

                result, err := sectionClient.CreateSection(containerID, displayName)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSection operation failed", "container_id", containerID, "error", err, "operation", "createSection")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to create section: %v", err)), nil
                }</span>

                // Extract only the essential information: success status and section ID
                <span class="cov0" title="0">sectionID, exists := result["id"].(string)
                if !exists </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSection result missing ID field", "result", result)
                        return mcp.NewToolResultError("Section creation succeeded but no ID was returned"), nil
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "success":   true,
                        "sectionID": sectionID,
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSection failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("createSection operation completed", "duration", elapsed, "section_id", sectionID)
                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(createSectionTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                return authorization.AuthorizedToolHandler("createSection", createSectionHandler, authConfig, cache, quickNoteConfig)(ctx, req)
        }</span>)

        // createSectionGroup: Create a new section group in a notebook or another section group
        <span class="cov8" title="1">createSectionGroupTool := mcp.NewTool(
                "createSectionGroup",
                mcp.WithDescription(resources.MustGetToolDescription("createSectionGroup")),
                mcp.WithString("containerID", mcp.Description("Notebook ID or Section Group ID to create the section group in. Optional - if left blank, automatically uses the server's configured default notebook.")),
                mcp.WithString("displayName", mcp.Required(), mcp.Description("Display name for the new section group (cannot contain: ?*\\/:&lt;&gt;|&amp;#''%%~)")),
        )
        createSectionGroupHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("MCP Tool: createSectionGroup", "operation", "createSectionGroup", "type", "tool_invocation")

                containerID := req.GetString("containerID", "")
                if containerID == "" </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("createSectionGroup no containerID provided, using default notebook")
                        var err error
                        containerID, err = notebooks.GetDefaultNotebookID(graphClient, graphClient.Config)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("createSectionGroup failed to get default notebook", "error", err)
                                return mcp.NewToolResultError(fmt.Sprintf("No containerID provided and failed to get default notebook: %v", err)), nil
                        }</span>
                }

                <span class="cov0" title="0">displayName, err := req.RequireString("displayName")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSectionGroup missing displayName", "error", err)
                        return mcp.NewToolResultError("displayName is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("createSectionGroup parameters", "containerID", containerID, "displayName", displayName)

                // Validate display name for illegal characters
                illegalChars := []string{"?", "*", "\\", "/", ":", "&lt;", "&gt;", "|", "&amp;", "#", "'", "'", "%", "~"}
                for _, char := range illegalChars </span><span class="cov0" title="0">{
                        if strings.Contains(displayName, char) </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("createSectionGroup displayName contains illegal character", "character", char, "display_name", displayName)
                                suggestedName := utils.SuggestValidName(displayName, char)
                                return mcp.NewToolResultError(fmt.Sprintf("displayName contains illegal character '%s'. Illegal characters are: ?*\\/:&lt;&gt;|&amp;#''%%%%~\n\nSuggestion: Try using '%s' instead of '%s'.\n\nSuggested valid name: '%s'", char, utils.GetReplacementChar(char), char, suggestedName)), nil
                        }</span>
                }
                <span class="cov0" title="0">logging.ToolsLogger.Debug("createSectionGroup displayName validation passed")

                result, err := sectionClient.CreateSectionGroup(containerID, displayName)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSectionGroup operation failed", "container_id", containerID, "error", err, "operation", "createSectionGroup")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to create section group: %v", err)), nil
                }</span>

                // Extract only the essential information: success status and section group ID
                <span class="cov0" title="0">sectionGroupID, exists := result["id"].(string)
                if !exists </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSectionGroup result missing ID field", "result", result)
                        return mcp.NewToolResultError("Section group creation succeeded but no ID was returned"), nil
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "success":        true,
                        "sectionGroupID": sectionGroupID,
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createSectionGroup failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("createSectionGroup operation completed", "duration", elapsed, "section_group_id", sectionGroupID)
                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(createSectionGroupTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                return authorization.AuthorizedToolHandler("createSectionGroup", createSectionGroupHandler, authConfig, cache, quickNoteConfig)(ctx, req)
        }</span>)

        // getSelectedNotebook: Get currently selected notebook metadata from cache
        <span class="cov8" title="1">getSelectedNotebookTool := mcp.NewTool(
                "getSelectedNotebook",
                mcp.WithDescription(resources.MustGetToolDescription("getSelectedNotebook")),
        )
        getSelectedNotebookHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Debug("getSelectedNotebook called")

                notebook, isSet := notebookCache.GetNotebook()
                if !isSet </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("No notebook currently selected")
                        return mcp.NewToolResultError("No notebook is currently selected. Use the 'selectNotebook' tool to select a notebook first."), nil
                }</span>

                <span class="cov0" title="0">jsonBytes, err := json.Marshal(notebook)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getSelectedNotebook failed to marshal notebook", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal selected notebook: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                if displayName, ok := notebookCache.GetDisplayName(); ok </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("getSelectedNotebook completed successfully",
                                "duration", elapsed,
                                "notebook_name", displayName)
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(getSelectedNotebookTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                return authorization.AuthorizedToolHandler("getSelectedNotebook", getSelectedNotebookHandler, authConfig, cache, quickNoteConfig)(ctx, req)
        }</span>)

        // selectNotebook: Select a notebook by name or ID to use as the active notebook
        <span class="cov8" title="1">selectNotebookTool := mcp.NewTool(
                "selectNotebook",
                mcp.WithDescription(resources.MustGetToolDescription("selectNotebook")),
                mcp.WithString("identifier", mcp.Description("Notebook name or ID to select as active")),
        )
        selectNotebookHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                args := req.GetArguments()

                identifier, ok := args["identifier"].(string)
                if !ok || identifier == "" </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("selectNotebook missing identifier parameter")
                        return mcp.NewToolResultError("Missing required parameter: identifier (notebook name or ID)"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("selectNotebook called", "identifier", identifier)

                // Try to get notebook by name first, then by ID
                var notebook map[string]interface{}
                var err error

                // First try as name
                notebook, err = notebookClient.GetDetailedNotebookByName(identifier)
                if err != nil </span><span class="cov0" title="0">{
                        // Try as ID - get all detailed notebooks and find matching ID
                        logging.ToolsLogger.Debug("Failed to find notebook by name, trying as ID",
                                "identifier", identifier, "name_error", err)

                        detailedNotebooks, errList := notebookClient.ListNotebooksDetailed()
                        if errList != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("selectNotebook failed to list detailed notebooks",
                                        "identifier", identifier, "error", errList)
                                return mcp.NewToolResultError(fmt.Sprintf("Failed to search for notebook '%s': %v", identifier, errList)), nil
                        }</span>

                        // Find notebook by ID
                        <span class="cov0" title="0">found := false
                        for _, nb := range detailedNotebooks </span><span class="cov0" title="0">{
                                if nbID, ok := nb["id"].(string); ok &amp;&amp; nbID == identifier </span><span class="cov0" title="0">{
                                        notebook = nb
                                        found = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("selectNotebook failed to find notebook by name or ID",
                                        "identifier", identifier)
                                return mcp.NewToolResultError(fmt.Sprintf("Failed to find notebook '%s' by name or ID", identifier)), nil
                        }</span>
                }

                // Validate authorization for this notebook selection
                <span class="cov0" title="0">notebookDisplayName, _ := notebook["displayName"].(string)
                if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                        if err := authConfig.SetCurrentNotebook(notebookDisplayName); err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("selectNotebook authorization denied",
                                        "notebook_name", notebookDisplayName,
                                        "error", err)
                                return mcp.NewToolResultError(fmt.Sprintf("Authorization denied: %v", err)), nil
                        }</span>
                        <span class="cov0" title="0">logging.ToolsLogger.Debug("selectNotebook authorization granted",
                                "notebook_name", notebookDisplayName)</span>
                }

                // Set the notebook in cache after authorization check
                <span class="cov0" title="0">notebookCache.SetNotebook(notebook)

                // Prepare response
                response := map[string]interface{}{
                        "success":  true,
                        "message":  fmt.Sprintf("Successfully selected notebook: %s", identifier),
                        "notebook": notebook,
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("selectNotebook failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal select response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                if displayName, ok := notebook["displayName"].(string); ok </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("selectNotebook completed successfully",
                                "duration", elapsed,
                                "notebook_name", displayName,
                                "notebook_id", notebook["id"])
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(selectNotebookTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                return authorization.AuthorizedToolHandler("selectNotebook", selectNotebookHandler, authConfig, cache, quickNoteConfig)(ctx, req)
        }</span>)

        // getNotebookSections: Get sections and section groups from selected notebook with caching
        <span class="cov8" title="1">getNotebookSectionsTool := mcp.NewTool(
                "getNotebookSections",
                mcp.WithDescription(resources.MustGetToolDescription("getNotebookSections")),
        )
        getNotebookSectionsHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Debug("getNotebookSections called")

                // Check if notebook is selected
                notebookID, isSet := notebookCache.GetNotebookID()
                if !isSet </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("No notebook currently selected for getNotebookSections")
                        return mcp.NewToolResultError("No notebook is currently selected. Use the 'selectNotebook' tool to select a notebook first."), nil
                }</span>

                // Send initial progress notification
                // First check the _meta field for progressToken
                <span class="cov0" title="0">var progressToken string

                // Debug the entire request structure
                if reqBytes, err := json.Marshal(req); err == nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("Full request structure", "request_json", string(reqBytes))
                }</span>

                // Debug just the Meta field
                <span class="cov0" title="0">if req.Params.Meta != nil </span><span class="cov0" title="0">{
                        if metaBytes, err := json.Marshal(req.Params.Meta); err == nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Debug("Meta field structure", "meta_json", string(metaBytes))
                        }</span>
                }

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Starting progress token extraction",
                        "has_meta", req.Params.Meta != nil,
                        "has_progress_token_field", req.Params.Meta != nil &amp;&amp; req.Params.Meta.ProgressToken != nil)

                if req.Params.Meta != nil &amp;&amp; req.Params.Meta.ProgressToken != nil </span><span class="cov0" title="0">{
                        rawToken := req.Params.Meta.ProgressToken
                        logging.ToolsLogger.Debug("Raw progress token found",
                                "token_type", fmt.Sprintf("%T", rawToken),
                                "token_value", rawToken)

                        // Handle both string and numeric progress tokens
                        switch token := rawToken.(type) </span>{
                        case string:<span class="cov0" title="0">
                                progressToken = token
                                logging.ToolsLogger.Debug("Progress token extracted as string", "progress_token", progressToken)</span>
                        case int:<span class="cov0" title="0">
                                progressToken = fmt.Sprintf("%d", token)
                                logging.ToolsLogger.Debug("Progress token extracted as int", "progress_token", progressToken, "original_value", token)</span>
                        case int64:<span class="cov0" title="0">
                                progressToken = fmt.Sprintf("%d", token)
                                logging.ToolsLogger.Debug("Progress token extracted as int64", "progress_token", progressToken, "original_value", token)</span>
                        case float64:<span class="cov0" title="0">
                                // Check if it's a whole number and convert appropriately
                                if token == float64(int64(token)) </span><span class="cov0" title="0">{
                                        progressToken = fmt.Sprintf("%.0f", token)
                                }</span> else<span class="cov0" title="0"> {
                                        progressToken = fmt.Sprintf("%g", token)
                                }</span>
                                <span class="cov0" title="0">logging.ToolsLogger.Debug("Progress token extracted as float64",
                                        "progress_token", progressToken,
                                        "original_value", token,
                                        "is_whole_number", token == float64(int64(token)))</span>
                        default:<span class="cov0" title="0">
                                progressToken = fmt.Sprintf("%v", token)
                                logging.ToolsLogger.Debug("Progress token extracted with default conversion",
                                        "token_type", fmt.Sprintf("%T", token),
                                        "token_value", token,
                                        "progress_token", progressToken)</span>
                        }
                } else<span class="cov0" title="0"> {
                        logging.ToolsLogger.Debug("No progress token in _meta field")
                }</span>

                // Fallback to checking arguments for backwards compatibility
                <span class="cov0" title="0">if progressToken == "" </span><span class="cov0" title="0">{
                        progressToken = req.GetString("_progressToken", "")
                        if progressToken != "" </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Debug("Progress token found in arguments fallback", "progress_token", progressToken)
                        }</span>
                }

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Final progress token extraction result",
                        "progress_token", progressToken,
                        "token_empty", progressToken == "")

                sendProgressNotification(s, ctx, progressToken, 0, 100, "Starting to fetch notebook sections...")

                // Check cache first
                if notebookCache.IsSectionsCached() </span><span class="cov0" title="0">{
                        // Send progress notification for cache check
                        sendProgressNotification(s, ctx, progressToken, 10, 100, "Checking cache for notebook sections...")

                        cachedStructure, cached := notebookCache.GetSectionsTree()
                        if cached </span><span class="cov0" title="0">{
                                // Send progress notification for cache hit
                                sendProgressNotification(s, ctx, progressToken, 80, 100, "Found cached notebook sections, preparing response...")
                                // Extract the array from the cached wrapper - handle both old and new format
                                var cachedArray []SectionItem
                                if sectionsInterface, hasSections := cachedStructure["sections"]; hasSections </span><span class="cov0" title="0">{
                                        // Try to convert to []SectionItem (new format)
                                        if sections, ok := sectionsInterface.([]SectionItem); ok </span><span class="cov0" title="0">{
                                                cachedArray = sections
                                        }</span> else<span class="cov0" title="0"> if oldSections, ok := sectionsInterface.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                // Handle legacy format - convert to SectionItem
                                                for _, oldSection := range oldSections </span><span class="cov0" title="0">{
                                                        sectionItem := convertMapToSectionItem(oldSection)
                                                        cachedArray = append(cachedArray, sectionItem)
                                                }</span>
                                        }
                                }

                                // Apply authorization filtering to cached sections
                                <span class="cov0" title="0">originalCachedCount := len(cachedArray)
                                if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                                        // Get notebook display name for filtering context
                                        notebookDisplayName, _ := notebookCache.GetDisplayName()
                                        if notebookDisplayName == "" </span><span class="cov0" title="0">{
                                                notebookDisplayName = "Unknown Notebook"
                                        }</span>
                                        
                                        // Convert SectionItem slice to []map[string]interface{} for filtering
                                        <span class="cov0" title="0">var sectionsForFiltering []map[string]interface{}
                                        for _, item := range cachedArray </span><span class="cov0" title="0">{
                                                sectionMap := map[string]interface{}{
                                                        "displayName": item.Name,
                                                        "id":          item.ID,
                                                        "type":        item.Type,
                                                }
                                                sectionsForFiltering = append(sectionsForFiltering, sectionMap)
                                        }</span>
                                        
                                        // Apply filtering
                                        // Note: Section filtering removed - all sections within selected notebook are now accessible
                                        <span class="cov0" title="0">filteredSections := sectionsForFiltering
                                        
                                        // Convert back to SectionItem slice
                                        var filteredCachedArray []SectionItem
                                        for _, filteredSection := range filteredSections </span><span class="cov0" title="0">{
                                                for _, originalItem := range cachedArray </span><span class="cov0" title="0">{
                                                        if originalItem.ID == filteredSection["id"].(string) </span><span class="cov0" title="0">{
                                                                filteredCachedArray = append(filteredCachedArray, originalItem)
                                                                break</span>
                                                        }
                                                }
                                        }
                                        
                                        <span class="cov0" title="0">cachedArray = filteredCachedArray
                                        logging.ToolsLogger.Debug("Applied authorization filtering to cached sections",
                                                "notebook", notebookDisplayName,
                                                "original_count", originalCachedCount,
                                                "filtered_count", len(cachedArray))</span>
                                }

                                <span class="cov0" title="0">elapsed := time.Since(startTime)
                                logging.ToolsLogger.Debug("getNotebookSections completed from cache",
                                        "duration", elapsed,
                                        "notebook_id", notebookID,
                                        "original_cached_count", originalCachedCount,
                                        "filtered_cached_count", len(cachedArray),
                                        "cache_hit", true)

                                // Get notebook display name (already retrieved above for filtering)
                                notebookDisplayName, _ := notebookCache.GetDisplayName()
                                if notebookDisplayName == "" </span><span class="cov0" title="0">{
                                        notebookDisplayName = "Unknown Notebook"
                                }</span>

                                // Create notebook root structure with sections as children
                                <span class="cov0" title="0">notebookRoot := map[string]interface{}{
                                        "type":        "notebook",
                                        "id":          notebookID,
                                        "displayName": notebookDisplayName,
                                        "children":    cachedArray,
                                }

                                // Create response with cache status
                                cacheResponse := map[string]interface{}{
                                        "notebook":       notebookRoot,
                                        "cached":         true,
                                        "cache_hit":      true,
                                        "sections_count": len(cachedArray),
                                        "duration":       elapsed.String(),
                                }

                                jsonBytes, err := json.Marshal(cacheResponse)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.ToolsLogger.Error("getNotebookSections failed to marshal cached sections", "error", err)
                                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal cached sections: %v", err)), nil
                                }</span>

                                // Send final 100% progress notification before returning result (MCP spec requirement)
                                <span class="cov0" title="0">sendProgressNotification(s, ctx, progressToken, 100, 100, "Completed - returning cached notebook sections")

                                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
                        }
                }

                // Cache miss - need to fetch from API
                <span class="cov0" title="0">logging.ToolsLogger.Debug("Cache miss, fetching sections from Graph API", "notebook_id", notebookID)

                // Send progress notification for cache miss (continuing from cache check at 10%)
                sendProgressNotification(s, ctx, progressToken, 20, 100, "Cache miss, fetching sections from Microsoft Graph API...")

                // Fetch all sections and section groups recursively
                logging.ToolsLogger.Debug("Fetching all sections and section groups recursively", "notebook_id", notebookID)

                // Create a progress context to pass the server and progress token
                progressCtx := context.WithValue(ctx, mcpServerKey, s)
                progressCtx = context.WithValue(progressCtx, progressTokenKey, progressToken)

                sectionItems, err := fetchAllNotebookContentWithProgress(sectionClient, notebookID, progressCtx)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getNotebookSections failed to fetch all content", "notebook_id", notebookID, "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to fetch sections: %v", err)), nil
                }</span>

                // Apply authorization filtering to sections
                <span class="cov0" title="0">originalSectionCount := len(sectionItems)
                if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                        // Get notebook display name for filtering context
                        notebookDisplayName, _ := notebookCache.GetDisplayName()
                        if notebookDisplayName == "" </span><span class="cov0" title="0">{
                                notebookDisplayName = "Unknown Notebook"
                        }</span>
                        
                        // Convert SectionItem slice to []map[string]interface{} for filtering
                        <span class="cov0" title="0">var sectionsForFiltering []map[string]interface{}
                        for _, item := range sectionItems </span><span class="cov0" title="0">{
                                sectionMap := map[string]interface{}{
                                        "displayName": item.Name,
                                        "id":          item.ID,
                                        "type":        item.Type,
                                }
                                sectionsForFiltering = append(sectionsForFiltering, sectionMap)
                        }</span>
                        
                        // Apply filtering
                        // Note: Section filtering removed - all sections within selected notebook are now accessible
                        <span class="cov0" title="0">filteredSections := sectionsForFiltering
                        
                        // Convert back to SectionItem slice
                        var filteredSectionItems []SectionItem
                        for _, filteredSection := range filteredSections </span><span class="cov0" title="0">{
                                for _, originalItem := range sectionItems </span><span class="cov0" title="0">{
                                        if originalItem.ID == filteredSection["id"].(string) </span><span class="cov0" title="0">{
                                                filteredSectionItems = append(filteredSectionItems, originalItem)
                                                break</span>
                                        }
                                }
                        }
                        
                        <span class="cov0" title="0">sectionItems = filteredSectionItems
                        logging.ToolsLogger.Debug("Applied authorization filtering to sections",
                                "notebook", notebookDisplayName,
                                "original_count", originalSectionCount,
                                "filtered_count", len(sectionItems))</span>
                }

                // Cache the complete structure
                <span class="cov0" title="0">cacheStructure := map[string]interface{}{
                        "sections": sectionItems,
                }
                notebookCache.SetSectionsTree(cacheStructure)

                elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("getNotebookSections completed from API",
                        "duration", elapsed,
                        "notebook_id", notebookID,
                        "sections_count", len(sectionItems),
                        "cache_hit", false)

                // Get notebook display name
                notebookDisplayName, _ := notebookCache.GetDisplayName()
                if notebookDisplayName == "" </span><span class="cov0" title="0">{
                        notebookDisplayName = "Unknown Notebook"
                }</span>

                // Create notebook root structure with sections as children
                <span class="cov0" title="0">notebookRoot := map[string]interface{}{
                        "type":        "notebook",
                        "id":          notebookID,
                        "displayName": notebookDisplayName,
                        "children":    sectionItems,
                }

                // Create response with cache status
                apiResponse := map[string]interface{}{
                        "notebook":       notebookRoot,
                        "cached":         false,
                        "cache_hit":      false,
                        "sections_count": len(sectionItems),
                        "duration":       elapsed.String(),
                }

                jsonBytes, err := json.Marshal(apiResponse)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getNotebookSections failed to marshal sections", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal sections: %v", err)), nil
                }</span>

                // Send final progress notification
                <span class="cov0" title="0">sendProgressNotification(s, ctx, progressToken, 100, 100, "Completed fetching all sections and section groups")

                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(getNotebookSectionsTool, func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                return authorization.AuthorizedToolHandler("getNotebookSections", getNotebookSectionsHandler, authConfig, cache, quickNoteConfig)(ctx, req)
        }</span>)

        // clearCache: Clear all cached data (notebook sections and pages)
        <span class="cov8" title="1">clearCacheTool := mcp.NewTool(
                "clearCache",
                mcp.WithDescription(resources.MustGetToolDescription("clearCache")),
        )
        clearCacheHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("MCP Tool: clearCache", "operation", "clearCache", "type", "tool_invocation")

                // Clear all cache data
                notebookCache.ClearAllCache()

                elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("clearCache operation completed", "duration", elapsed)

                response := map[string]interface{}{
                        "success": true,
                        "message": "All cache data cleared successfully. Next requests will fetch fresh data from the API.",
                        "cleared": []string{
                                "notebook sections cache",
                                "pages cache for all sections",
                        },
                        "duration": elapsed.String(),
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("clearCache failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        // clearCache doesn't require authorization since it's a system maintenance operation
        <span class="cov8" title="1">s.AddTool(clearCacheTool, server.ToolHandlerFunc(clearCacheHandler))

        logging.ToolsLogger.Debug("Notebook and section tools registered successfully")</span>
}

// sendProgressNotification sends a progress notification using the centralized utility
func sendProgressNotification(s *server.MCPServer, ctx context.Context, progressToken string, progress int, total int, message string) <span class="cov0" title="0">{
        utils.SendProgressNotification(s, ctx, progressToken, progress, total, message)
}</span>

// Helper functions for notebook and section operations

// fetchAllNotebookContentWithProgress fetches all sections and section groups with progress notifications
func fetchAllNotebookContentWithProgress(sectionClient *sections.SectionClient, notebookID string, ctx context.Context) ([]SectionItem, error) <span class="cov0" title="0">{
        logging.ToolsLogger.Debug("Starting fetchAllNotebookContentWithProgress", "notebook_id", notebookID)

        // Extract progress info from context
        var mcpServer *server.MCPServer
        var progressToken string
        if serverVal := ctx.Value(mcpServerKey); serverVal != nil </span><span class="cov0" title="0">{
                mcpServer, _ = serverVal.(*server.MCPServer)
        }</span>
        <span class="cov0" title="0">if tokenVal := ctx.Value(progressTokenKey); tokenVal != nil </span><span class="cov0" title="0">{
                progressToken, _ = tokenVal.(string)
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("Progress context extracted",
                "notebook_id", notebookID,
                "has_mcp_server", mcpServer != nil,
                "has_progress_token", progressToken != "",
                "progress_token", progressToken)

        // Send progress notification - fetching top-level items (continuing from main function at 20%)
        if mcpServer != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Sending progress notification for API fetch",
                        "notebook_id", notebookID,
                        "progress_token", progressToken,
                        "progress", 30,
                        "message", "Fetching top-level sections and section groups...")
                sendProgressNotification(mcpServer, ctx, progressToken, 30, 100, "Fetching top-level sections and section groups...")
        }</span> else<span class="cov0" title="0"> {
                logging.ToolsLogger.Debug("No MCP server available for progress notifications", "notebook_id", notebookID)
        }</span>

        // Send progress notification before the critical API call
        <span class="cov0" title="0">if mcpServer != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Sending progress notification for main API call",
                        "notebook_id", notebookID,
                        "progress_token", progressToken,
                        "progress", 32,
                        "message", "Making main API call to get sections and section groups...")
                sendProgressNotification(mcpServer, ctx, progressToken, 32, 100, "Making main API call to get sections and section groups...")
        }</span>

        // Get immediate sections and section groups from the notebook using ListSections
        <span class="cov0" title="0">items, err := sectionClient.ListSectionsWithContext(ctx, notebookID)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("Failed to get sections and section groups from notebook", "notebook_id", notebookID, "error", err)
                return nil, fmt.Errorf("failed to get sections and section groups from notebook: %v", err)
        }</span>

        // Send progress notification after API call completes
        <span class="cov0" title="0">if mcpServer != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Sending progress notification after API fetch",
                        "notebook_id", notebookID,
                        "progress_token", progressToken,
                        "progress", 35,
                        "total_items", len(items),
                        "message", fmt.Sprintf("Retrieved %d items, starting to process...", len(items)))
                sendProgressNotification(mcpServer, ctx, progressToken, 35, 100, fmt.Sprintf("Retrieved %d items, starting to process...", len(items)))
        }</span>

        <span class="cov0" title="0">var sectionItems []SectionItem
        totalItems := len(items)
        processedItems := 0

        logging.ToolsLogger.Debug("Starting item processing loop",
                "notebook_id", notebookID,
                "total_items", totalItems)

        // Process each item returned by ListSections
        for i, item := range items </span><span class="cov0" title="0">{
                itemID := getStringValue(item, "id")
                itemName := getStringValue(item, "displayName")
                if itemName == "" </span><span class="cov0" title="0">{
                        itemName = itemID
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Processing individual item",
                        "notebook_id", notebookID,
                        "item_index", i+1,
                        "total_items", totalItems,
                        "item_id", itemID,
                        "item_name", itemName)

                // Send progress for each item being processed - more frequent updates to prevent timeouts
                if mcpServer != nil </span><span class="cov0" title="0">{
                        progress := 35 + int(float64(i)/float64(totalItems)*45) // Progress from 35 to 80 (leave room for completion)
                        logging.ToolsLogger.Debug("Sending item progress notification",
                                "notebook_id", notebookID,
                                "item_index", i+1,
                                "item_name", itemName,
                                "progress", progress,
                                "message", fmt.Sprintf("Processing item %d/%d: %s", i+1, totalItems, itemName))
                        sendProgressNotification(mcpServer, ctx, progressToken, progress, 100, fmt.Sprintf("Processing item %d/%d: %s", i+1, totalItems, itemName))
                }</span>

                // Build the section item - this may involve recursive API calls for section groups
                <span class="cov0" title="0">sectionItem, err := buildSectionItemWithProgress(item, sectionClient, ctx, i, totalItems)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Warn("Failed to build section item, skipping",
                                "notebook_id", notebookID,
                                "item_id", itemID,
                                "item_name", itemName,
                                "error", err)
                        continue</span> // Skip this item but continue with others
                }

                // Send progress after each item is completed
                <span class="cov0" title="0">if mcpServer != nil </span><span class="cov0" title="0">{
                        progressAfterCompletion := 35 + int(float64(i+1)/float64(totalItems)*45) // Updated progress after completion
                        logging.ToolsLogger.Debug("Sending item completion progress notification",
                                "notebook_id", notebookID,
                                "item_index", i+1,
                                "item_name", itemName,
                                "progress", progressAfterCompletion,
                                "message", fmt.Sprintf("Completed item %d/%d: %s", i+1, totalItems, itemName))
                        sendProgressNotification(mcpServer, ctx, progressToken, progressAfterCompletion, 100, fmt.Sprintf("Completed item %d/%d: %s", i+1, totalItems, itemName))
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Successfully built section item",
                        "notebook_id", notebookID,
                        "item_id", itemID,
                        "item_name", itemName,
                        "item_type", sectionItem.Type)

                sectionItems = append(sectionItems, sectionItem)
                processedItems++</span>
        }

        // Send completion progress
        <span class="cov0" title="0">if mcpServer != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Sending completion progress notification",
                        "notebook_id", notebookID,
                        "processed_items", processedItems,
                        "total_items", totalItems,
                        "progress", 85)
                sendProgressNotification(mcpServer, ctx, progressToken, 85, 100, fmt.Sprintf("Completed processing all %d items", processedItems))
        }</span> else<span class="cov0" title="0"> {
                logging.ToolsLogger.Debug("No MCP server for completion notification",
                        "notebook_id", notebookID,
                        "processed_items", processedItems)
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("fetchAllNotebookContentWithProgress completed",
                "notebook_id", notebookID,
                "result_items", len(sectionItems))

        return sectionItems, nil</span>
}

// getStringField safely extracts a string field from a map
func getStringField(item map[string]interface{}, field string) string <span class="cov0" title="0">{
        if value, ok := item[field].(string); ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getStringValue safely extracts a string value from a map (alias for getStringField)
func getStringValue(item map[string]interface{}, field string) string <span class="cov0" title="0">{
        return getStringField(item, field)
}</span>

// buildSectionItemWithProgress builds a SectionItem with progress notifications
func buildSectionItemWithProgress(item map[string]interface{}, sectionClient *sections.SectionClient, ctx context.Context, itemIndex, totalItems int) (SectionItem, error) <span class="cov0" title="0">{
        id := getStringValue(item, "id")
        name := getStringValue(item, "displayName")

        logging.ToolsLogger.Debug("Starting buildSectionItemWithProgress",
                "item_id", id,
                "item_name", name,
                "item_index", itemIndex,
                "total_items", totalItems)

        // Extract progress info from context
        var mcpServer *server.MCPServer
        var progressToken string
        if serverVal := ctx.Value(mcpServerKey); serverVal != nil </span><span class="cov0" title="0">{
                mcpServer, _ = serverVal.(*server.MCPServer)
        }</span>
        <span class="cov0" title="0">if tokenVal := ctx.Value(progressTokenKey); tokenVal != nil </span><span class="cov0" title="0">{
                progressToken, _ = tokenVal.(string)
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("Progress context in buildSectionItemWithProgress",
                "item_id", id,
                "has_mcp_server", mcpServer != nil,
                "has_progress_token", progressToken != "",
                "progress_token", progressToken)

        // Determine if this is a section or section group by checking for specific fields
        itemType := determineSectionItemType(item)

        logging.ToolsLogger.Debug("Determined item type",
                "item_id", id,
                "item_name", name,
                "item_type", itemType)

        sectionItem := SectionItem{
                Type: itemType,
                ID:   id,
                Name: name,
        }

        // If this is a section group, populate its children by calling ListSections recursively
        if itemType == "sectionGroup" </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Processing section group - building children",
                        "section_group_id", id,
                        "section_group_name", name,
                        "item_index", itemIndex,
                        "total_items", totalItems)

                // Send progress notification for section group - early notification to prevent gaps
                if mcpServer != nil </span><span class="cov0" title="0">{
                        progress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 2
                        logging.ToolsLogger.Debug("Sending section group progress notification",
                                "section_group_id", id,
                                "section_group_name", name,
                                "progress", progress,
                                "message", fmt.Sprintf("Starting to fetch children for section group: %s", name))
                        sendProgressNotification(mcpServer, ctx, progressToken, progress, 100, fmt.Sprintf("Starting to fetch children for section group: %s", name))
                }</span> else<span class="cov0" title="0"> {
                        logging.ToolsLogger.Debug("No MCP server for section group progress notification",
                                "section_group_id", id)
                }</span>

                // Send progress notification before the actual API call that was causing long delays
                <span class="cov0" title="0">if mcpServer != nil </span><span class="cov0" title="0">{
                        progress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 3
                        logging.ToolsLogger.Debug("Sending API call progress notification",
                                "section_group_id", id,
                                "section_group_name", name,
                                "progress", progress,
                                "message", fmt.Sprintf("Making API call to get children for: %s", name))
                        sendProgressNotification(mcpServer, ctx, progressToken, progress, 100, fmt.Sprintf("Making API call to get children for: %s", name))
                }</span>

                <span class="cov0" title="0">childItems, err := sectionClient.ListSectionsWithContext(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Warn("Failed to get children for section group, returning empty children",
                                "section_group_id", id,
                                "section_group_name", name,
                                "error", err)
                        // Return the section group without children rather than failing completely
                        sectionItem.Children = []SectionItem{}
                        return sectionItem, nil
                }</span>

                // Send progress notification after API call completes
                <span class="cov0" title="0">if mcpServer != nil </span><span class="cov0" title="0">{
                        progress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 4 // Add small increment after API call
                        logging.ToolsLogger.Debug("Sending section group API completion progress notification",
                                "section_group_id", id,
                                "section_group_name", name,
                                "progress", progress,
                                "child_count", len(childItems),
                                "message", fmt.Sprintf("Retrieved %d children for section group: %s", len(childItems), name))
                        sendProgressNotification(mcpServer, ctx, progressToken, progress, 100, fmt.Sprintf("Retrieved %d children for section group: %s", len(childItems), name))
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Retrieved child items for section group",
                        "section_group_id", id,
                        "section_group_name", name,
                        "child_count", len(childItems))

                var children []SectionItem
                for childIndex, childItem := range childItems </span><span class="cov0" title="0">{
                        childID := getStringValue(childItem, "id")
                        childName := getStringValue(childItem, "displayName")
                        if childName == "" </span><span class="cov0" title="0">{
                                childName = childID
                        }</span>

                        <span class="cov0" title="0">logging.ToolsLogger.Debug("Processing child item in section group",
                                "parent_section_group_id", id,
                                "parent_section_group_name", name,
                                "child_id", childID,
                                "child_name", childName,
                                "child_index", childIndex+1,
                                "total_children", len(childItems))

                        // Send progress for each child - frequent progress tracking to prevent timeouts
                        if mcpServer != nil &amp;&amp; len(childItems) &gt; 0 </span><span class="cov0" title="0">{
                                // Calculate progress within the section group processing - smaller increments for frequent updates
                                baseProgress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 4
                                childProgress := baseProgress + int(float64(childIndex)/float64(len(childItems))*5) // Add up to 5% progress within section group
                                progressMessage := fmt.Sprintf("Processing child %d/%d in %s: %s", childIndex+1, len(childItems), name, childName)
                                logging.ToolsLogger.Debug("Sending child progress notification",
                                        "parent_section_group_id", id,
                                        "child_id", childID,
                                        "child_name", childName,
                                        "progress", childProgress,
                                        "message", progressMessage)
                                sendProgressNotification(mcpServer, ctx, progressToken, childProgress, 100, progressMessage)
                        }</span>

                        // Recursively build child items with progress
                        // Create a progress context for child items to pass the MCP server and progress token
                        <span class="cov0" title="0">childProgressCtx := context.WithValue(ctx, mcpServerKey, mcpServer)
                        childProgressCtx = context.WithValue(childProgressCtx, progressTokenKey, progressToken)
                        childSectionItem, err := buildSectionItemWithProgress(childItem, sectionClient, childProgressCtx, childIndex, len(childItems))
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Warn("Failed to build child section item, skipping",
                                        "parent_section_group_id", id,
                                        "child_id", childID,
                                        "child_name", childName,
                                        "error", err)
                                continue</span> // Skip this child but continue with others
                        }

                        // Send progress after each child is completed - quick update to show completion
                        <span class="cov0" title="0">if mcpServer != nil &amp;&amp; len(childItems) &gt; 0 </span><span class="cov0" title="0">{
                                baseProgress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 4
                                childCompletionProgress := baseProgress + int(float64(childIndex+1)/float64(len(childItems))*5)
                                progressMessage := fmt.Sprintf("Completed child %d/%d in %s: %s", childIndex+1, len(childItems), name, childName)
                                logging.ToolsLogger.Debug("Sending child completion progress notification",
                                        "parent_section_group_id", id,
                                        "child_id", childID,
                                        "child_name", childName,
                                        "progress", childCompletionProgress,
                                        "message", progressMessage)
                                sendProgressNotification(mcpServer, ctx, progressToken, childCompletionProgress, 100, progressMessage)
                        }</span>

                        <span class="cov0" title="0">logging.ToolsLogger.Debug("Successfully built child section item",
                                "parent_section_group_id", id,
                                "child_id", childID,
                                "child_name", childName,
                                "child_type", childSectionItem.Type)

                        children = append(children, childSectionItem)</span>
                }

                <span class="cov0" title="0">sectionItem.Children = children

                // Send progress after completing all children in section group
                if mcpServer != nil </span><span class="cov0" title="0">{
                        finalProgress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 10 // Complete the section group processing
                        progressMessage := fmt.Sprintf("Completed section group %s with %d children", name, len(children))
                        logging.ToolsLogger.Debug("Sending section group completion progress notification",
                                "section_group_id", id,
                                "section_group_name", name,
                                "progress", finalProgress,
                                "children_count", len(children),
                                "message", progressMessage)
                        sendProgressNotification(mcpServer, ctx, progressToken, finalProgress, 100, progressMessage)
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Completed building section group with all children",
                        "section_group_id", id,
                        "section_group_name", name,
                        "children_count", len(children),
                        "successful_children", len(children))</span>
        } else<span class="cov0" title="0"> {
                // Sections don't have children
                logging.ToolsLogger.Debug("Item is a section, no children to process",
                        "section_id", id,
                        "section_name", name)
                sectionItem.Children = nil

                // Send progress for simple section
                if mcpServer != nil </span><span class="cov0" title="0">{
                        progress := 35 + int(float64(itemIndex)/float64(totalItems)*45) + 8 // Quick progress for simple section
                        progressMessage := fmt.Sprintf("Processed section: %s", name)
                        logging.ToolsLogger.Debug("Sending section progress notification",
                                "section_id", id,
                                "section_name", name,
                                "progress", progress,
                                "message", progressMessage)
                        sendProgressNotification(mcpServer, ctx, progressToken, progress, 100, progressMessage)
                }</span>
        }

        <span class="cov0" title="0">return sectionItem, nil</span>
}

// determineSectionItemType determines if an item is a section or section group
func determineSectionItemType(item map[string]interface{}) string <span class="cov0" title="0">{
        // Check if this item has the structure of a section group
        // Section groups typically have different metadata structure than sections

        // One way to distinguish: check if the item has specific fields that are unique to sections vs section groups
        // Looking at the Microsoft Graph API documentation:
        // - Sections have pagesUrl field
        // - Section groups have sectionsUrl and sectionGroupsUrl fields

        if _, hasPagesURL := item["pagesUrl"]; hasPagesURL </span><span class="cov0" title="0">{
                return "section"
        }</span>

        <span class="cov0" title="0">if _, hasSectionsURL := item["sectionsUrl"]; hasSectionsURL </span><span class="cov0" title="0">{
                return "sectionGroup"
        }</span>

        <span class="cov0" title="0">if _, hasSectionGroupsURL := item["sectionGroupsUrl"]; hasSectionGroupsURL </span><span class="cov0" title="0">{
                return "sectionGroup"
        }</span>

        // Fallback: if we can't determine, assume it's a section
        // This is safer since sections are leaf nodes and won't cause infinite recursion
        <span class="cov0" title="0">logging.ToolsLogger.Debug("Could not determine item type, defaulting to section", "item_id", getStringValue(item, "id"))
        return "section"</span>
}

// convertMapToSectionItem converts a legacy map format to SectionItem (for cache compatibility)
func convertMapToSectionItem(item map[string]interface{}) SectionItem <span class="cov0" title="0">{
        sectionItem := SectionItem{
                Type: getStringValue(item, "type"),
                ID:   getStringValue(item, "id"),
                Name: getStringValue(item, "name"),
        }

        // Handle children if they exist
        if childrenInterface, hasChildren := item["children"]; hasChildren </span><span class="cov0" title="0">{
                if childrenArray, ok := childrenInterface.([]interface{}); ok </span><span class="cov0" title="0">{
                        var children []SectionItem
                        for _, childInterface := range childrenArray </span><span class="cov0" title="0">{
                                if childMap, ok := childInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        child := convertMapToSectionItem(childMap)
                                        children = append(children, child)
                                }</span>
                        }
                        <span class="cov0" title="0">sectionItem.Children = children</span>
                }
        }

        <span class="cov0" title="0">return sectionItem</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// OneNote MCP Server Page Resources
//
// This file implements MCP (Model Context Protocol) page-related resources for accessing
// Microsoft OneNote pages through a hierarchical REST-like URI structure.
//
// ## Page Resource URIs
//
// ### Available Page Resource URIs
//
// #### 1. List Pages in a Section by ID or Name
// **URI:** `onenote://pages/{sectionIdOrName}`
// **Purpose:** Get all pages within a specific section, identified by either section ID or display name
// **Parameters:**
//   - `{sectionIdOrName}`: URL-encoded section ID or display name
// **API Equivalent:** `https://graph.microsoft.com/v1.0/me/onenote/sections/{sectionId}/pages`
// **Returns:** JSON object with pages containing title and pageId fields
//
// #### 2. Get Page Content for Update
// **URI:** `onenote://page/{pageId}`
// **Purpose:** Get HTML content for a specific page with data-id attributes included for update operations
// **Parameters:**
//   - `{pageId}`: URL-encoded page ID
// **API Equivalent:** `https://graph.microsoft.com/v1.0/me/onenote/pages/{pageId}/content?includeIDs=true`
// **Returns:** HTML content with data-id attributes for targeted updates
//

package main

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "strings"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/pages"
        "github.com/gebl/onenote-mcp-server/internal/sections"
)

// registerPageResources registers all page-related MCP resources
func registerPageResources(s *server.MCPServer, graphClient *graph.Client, cfg *config.Config) <span class="cov0" title="0">{
        logging.MainLogger.Debug("Starting page resource registration process")

        // Register pages by section ID or name resource template
        logging.MainLogger.Debug("Creating pages by section resource template",
                "template_pattern", "onenote://pages/{sectionIdOrName}",
                "resource_type", "template_resource")
        pagesTemplate := mcp.NewResourceTemplate(
                "onenote://pages/{sectionIdOrName}",
                "OneNote Pages for Section",
                mcp.WithTemplateDescription("List all pages in a specific section by either section ID or display name, returning page titles and IDs"),
                mcp.WithTemplateMIMEType("application/json"),
        )

        s.AddResourceTemplate(pagesTemplate, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Page resource template handler invoked",
                        "template_pattern", "onenote://pages/{sectionIdOrName}",
                        "request_uri", request.Params.URI,
                        "handler_type", "section_pages")

                // Extract section ID or name from URI
                sectionIdOrName := extractSectionIdOrNameFromPagesURI(request.Params.URI)
                if sectionIdOrName == "" </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Invalid section ID or name in pages URI",
                                "request_uri", request.Params.URI,
                                "extracted_value", sectionIdOrName)
                        return nil, fmt.Errorf("invalid section ID or name in URI: %s", request.Params.URI)
                }</span>

                <span class="cov0" title="0">logging.MainLogger.Debug("Extracted section ID or name from pages URI",
                        "section_id_or_name", sectionIdOrName,
                        "request_uri", request.Params.URI)

                // Call the pages resource handler with progress support
                jsonData, err := getPagesForSectionResource(ctx, s, graphClient, sectionIdOrName)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to get pages for section resource",
                                "section_id_or_name", sectionIdOrName,
                                "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">responseSize := len(jsonData)
                logging.MainLogger.Debug("Successfully prepared pages resource response",
                        "section_id_or_name", sectionIdOrName,
                        "request_uri", request.Params.URI,
                        "response_size_bytes", responseSize)

                return []mcp.ResourceContents{
                        mcp.TextResourceContents{
                                URI:      request.Params.URI,
                                MIMEType: "application/json",
                                Text:     string(jsonData),
                        },
                }, nil</span>
        })
        <span class="cov0" title="0">logging.MainLogger.Debug("Registered pages by section resource template successfully",
                "template_pattern", "onenote://pages/{sectionIdOrName}")

        // Register page content by page ID resource template
        logging.MainLogger.Debug("Creating page content by page ID resource template",
                "template_pattern", "onenote://page/{pageId}",
                "resource_type", "template_resource")
        pageContentTemplate := mcp.NewResourceTemplate(
                "onenote://page/{pageId}",
                "OneNote Page Content for Update",
                mcp.WithTemplateDescription("Get HTML content for a specific page with data-id attributes included for update operations"),
                mcp.WithTemplateMIMEType("text/html"),
        )

        s.AddResourceTemplate(pageContentTemplate, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Page content resource template handler invoked",
                        "template_pattern", "onenote://page/{pageId}",
                        "request_uri", request.Params.URI,
                        "handler_type", "page_content")

                // Extract page ID from URI
                pageID := extractPageIdFromPageURI(request.Params.URI)
                if pageID == "" </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Invalid page ID in page content URI",
                                "request_uri", request.Params.URI,
                                "extracted_value", pageID)
                        return nil, fmt.Errorf("invalid page ID in URI: %s", request.Params.URI)
                }</span>

                <span class="cov0" title="0">logging.MainLogger.Debug("Extracted page ID from page content URI",
                        "page_id", pageID,
                        "request_uri", request.Params.URI)

                // Call the page content resource handler with progress support
                htmlContent, err := getPageContentForResource(ctx, s, graphClient, pageID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to get page content for resource",
                                "page_id", pageID,
                                "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">responseSize := len(htmlContent)
                logging.MainLogger.Debug("Successfully prepared page content resource response",
                        "page_id", pageID,
                        "request_uri", request.Params.URI,
                        "response_size_bytes", responseSize)

                return []mcp.ResourceContents{
                        mcp.TextResourceContents{
                                URI:      request.Params.URI,
                                MIMEType: "text/html",
                                Text:     htmlContent,
                        },
                }, nil</span>
        })
        <span class="cov0" title="0">logging.MainLogger.Debug("Registered page content by page ID resource template successfully",
                "template_pattern", "onenote://page/{pageId}")

        logging.MainLogger.Debug("Page resource registration completed successfully",
                "total_resources", 2,
                "template_resources", 2,
                "static_resources", 0)</span>
}

// Page-specific URI extraction functions

// extractSectionIdOrNameFromPagesURI extracts the section ID or name from a URI like "onenote://pages/{sectionIdOrName}"
func extractSectionIdOrNameFromPagesURI(uri string) string <span class="cov0" title="0">{
        // URI format: onenote://pages/{sectionIdOrName}
        parts := strings.Split(uri, "/")
        if len(parts) &gt;= 4 &amp;&amp; parts[0] == "onenote:" &amp;&amp; parts[2] == "pages" </span><span class="cov0" title="0">{
                // URL decode the section ID or name since it's part of a URI
                decodedValue, err := url.QueryUnescape(parts[3])
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Warn("Failed to URL decode section ID or name from pages URI, using raw value",
                                "raw_value", parts[3],
                                "error", err,
                                "uri", uri)
                        return parts[3] // fallback to raw value
                }</span>
                <span class="cov0" title="0">logging.MainLogger.Debug("URL decoded section ID or name from pages URI",
                        "raw_value", parts[3],
                        "decoded_value", decodedValue,
                        "uri", uri)
                return decodedValue</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// extractPageIdFromPageURI extracts the page ID from a URI like "onenote://page/{pageId}"
func extractPageIdFromPageURI(uri string) string <span class="cov0" title="0">{
        // URI format: onenote://page/{pageId}
        parts := strings.Split(uri, "/")
        if len(parts) &gt;= 4 &amp;&amp; parts[0] == "onenote:" &amp;&amp; parts[2] == "page" </span><span class="cov0" title="0">{
                // URL decode the page ID since it's part of a URI
                decodedValue, err := url.QueryUnescape(parts[3])
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Warn("Failed to URL decode page ID from page URI, using raw value",
                                "raw_value", parts[3],
                                "error", err,
                                "uri", uri)
                        return parts[3] // fallback to raw value
                }</span>
                <span class="cov0" title="0">logging.MainLogger.Debug("URL decoded page ID from page URI",
                        "raw_value", parts[3],
                        "decoded_value", decodedValue,
                        "uri", uri)
                return decodedValue</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// getPageContentForResource fetches HTML content for a specific page with data-id attributes for updates
func getPageContentForResource(ctx context.Context, s *server.MCPServer, graphClient *graph.Client, pageID string) (string, error) <span class="cov0" title="0">{
        logging.MainLogger.Debug("getPageContentForResource called", "page_id", pageID)

        // Extract progress token from request metadata (MCP spec for resources)
        var progressToken string
        logging.MainLogger.Debug("Resource progress support - checking for progress token",
                "page_id", pageID)

        // Send initial progress notification
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 0, 100, "Starting to fetch page content...")
        }</span>

        // Create specialized page client
        <span class="cov0" title="0">pageClient := pages.NewPageClient(graphClient)

        // Create progress context
        progressCtx := context.WithValue(ctx, mcpServerKey, s)
        progressCtx = context.WithValue(progressCtx, progressTokenKey, progressToken)

        // Send progress for API call
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, progressCtx, progressToken, 30, 100, "Fetching page content with update IDs...")
        }</span>

        // Get page content with forUpdate=true to include data-id attributes
        <span class="cov0" title="0">htmlContent, err := pageClient.GetPageContent(pageID, true)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to fetch page content for resource",
                        "page_id", pageID,
                        "error", err)
                return "", fmt.Errorf("failed to fetch page content: %v", err)
        }</span>

        // Send progress for completion
        <span class="cov0" title="0">if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, progressCtx, progressToken, 100, 100, "Completed fetching page content")
        }</span>

        <span class="cov0" title="0">logging.MainLogger.Debug("Successfully prepared page content for resource",
                "page_id", pageID,
                "content_length", len(htmlContent))

        return htmlContent, nil</span>
}

// getPagesForSectionResource fetches all pages for a section identified by ID or name
func getPagesForSectionResource(ctx context.Context, s *server.MCPServer, graphClient *graph.Client, sectionIdOrName string) ([]byte, error) <span class="cov0" title="0">{
        logging.MainLogger.Debug("getPagesForSectionResource called", "section_id_or_name", sectionIdOrName)

        // Extract progress token from request metadata (MCP spec for resources)
        var progressToken string
        logging.MainLogger.Debug("Resource progress support - checking for progress token",
                "section_id_or_name", sectionIdOrName)

        // Send initial progress notification
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 0, 100, "Starting to fetch pages for section...")
        }</span>

        // Create specialized clients
        <span class="cov0" title="0">pageClient := pages.NewPageClient(graphClient)
        sectionClient := sections.NewSectionClient(graphClient)

        // Create progress context
        progressCtx := context.WithValue(ctx, mcpServerKey, s)
        progressCtx = context.WithValue(progressCtx, progressTokenKey, progressToken)

        // First, try to determine if this is an ID or name and resolve to section ID
        sectionID, err := resolveSectionIdOrName(progressCtx, sectionClient, sectionIdOrName)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to resolve section ID or name",
                        "section_id_or_name", sectionIdOrName,
                        "error", err)
                return nil, fmt.Errorf("failed to resolve section '%s': %v", sectionIdOrName, err)
        }</span>

        <span class="cov0" title="0">logging.MainLogger.Debug("Resolved section ID",
                "section_id_or_name", sectionIdOrName,
                "resolved_section_id", sectionID)

        // Send progress for API call
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 30, 100, "Fetching pages from section...")
        }</span>

        // Get pages for the resolved section ID
        <span class="cov0" title="0">pagesData, err := pageClient.ListPages(sectionID)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to fetch pages for section resource",
                        "section_id", sectionID,
                        "section_id_or_name", sectionIdOrName,
                        "error", err)
                return nil, fmt.Errorf("failed to fetch pages for section: %v", err)
        }</span>

        // Send progress for processing
        <span class="cov0" title="0">if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 70, 100, "Processing pages data...")
        }</span>

        // Filter the pages data to include only title and pageId
        <span class="cov0" title="0">var filteredPages []map[string]interface{}
        for _, page := range pagesData </span><span class="cov0" title="0">{
                filteredPage := make(map[string]interface{})

                // Extract title from the page data
                if title, exists := page["title"]; exists </span><span class="cov0" title="0">{
                        filteredPage["title"] = title
                }</span>

                // Extract pageId from the page data (could be "pageId" or "id")
                <span class="cov0" title="0">if pageId, exists := page["pageId"]; exists </span><span class="cov0" title="0">{
                        filteredPage["pageId"] = pageId
                }</span> else<span class="cov0" title="0"> if id, exists := page["id"]; exists </span><span class="cov0" title="0">{
                        filteredPage["pageId"] = id
                }</span>

                <span class="cov0" title="0">filteredPages = append(filteredPages, filteredPage)</span>
        }

        // Build response in the requested format
        <span class="cov0" title="0">response := map[string]interface{}{
                "pages":        filteredPages,
                "pages_count":  len(filteredPages),
                "section_id":   sectionID,
                "section_name": sectionIdOrName, // Original input (could be name or ID)
                "source":       "pages_resource_api",
        }

        // Send progress for marshaling
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 90, 100, "Preparing response...")
        }</span>

        <span class="cov0" title="0">jsonData, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to marshal pages for resource",
                        "error", err,
                        "section_id_or_name", sectionIdOrName)
                return nil, fmt.Errorf("failed to marshal pages: %v", err)
        }</span>

        // Send final progress notification
        <span class="cov0" title="0">if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 100, 100, "Completed fetching pages for section")
        }</span>

        <span class="cov0" title="0">logging.MainLogger.Debug("Successfully prepared pages for section resource",
                "section_id_or_name", sectionIdOrName,
                "section_id", sectionID,
                "pages_count", len(filteredPages))

        return jsonData, nil</span>
}

// resolveSectionIdOrName resolves a section identifier (ID or name) to a section ID
// If the input is already a valid section ID, returns it as-is
// If the input is a section name, searches for the section and returns its ID
func resolveSectionIdOrName(ctx context.Context, sectionClient *sections.SectionClient, sectionIdOrName string) (string, error) <span class="cov0" title="0">{
        logging.MainLogger.Debug("Resolving section ID or name", "input", sectionIdOrName)

        // First, try to use it as an ID directly - if it's a valid OneNote ID format, try it
        if isValidOneNoteIDFormat(sectionIdOrName) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Input appears to be a valid OneNote ID format, testing directly",
                        "section_id", sectionIdOrName)

                // We can't easily test if a section ID is valid without making an API call
                // So we'll first try the global sections API to see if we can find it
                allSections, err := sectionClient.ListAllSections()
                if err == nil </span><span class="cov0" title="0">{
                        for _, section := range allSections </span><span class="cov0" title="0">{
                                if id, exists := section["id"].(string); exists &amp;&amp; id == sectionIdOrName </span><span class="cov0" title="0">{
                                        logging.MainLogger.Debug("Found section by ID in global sections list",
                                                "section_id", sectionIdOrName)
                                        return sectionIdOrName, nil
                                }</span>
                        }
                }

                <span class="cov0" title="0">logging.MainLogger.Debug("Section ID not found in global sections, treating as name",
                        "input", sectionIdOrName)</span>
        }

        // Try to find section by display name
        <span class="cov0" title="0">logging.MainLogger.Debug("Searching for section by name", "section_name", sectionIdOrName)

        // Get all sections and search by name
        allSections, err := sectionClient.ListAllSections()
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to list all sections for name resolution",
                        "section_name", sectionIdOrName,
                        "error", err)
                return "", fmt.Errorf("failed to list sections for name resolution: %v", err)
        }</span>

        // Search for section with matching display name
        <span class="cov0" title="0">for _, section := range allSections </span><span class="cov0" title="0">{
                if displayName, exists := section["displayName"].(string); exists &amp;&amp; displayName == sectionIdOrName </span><span class="cov0" title="0">{
                        if id, exists := section["id"].(string); exists </span><span class="cov0" title="0">{
                                logging.MainLogger.Debug("Found section by name",
                                        "section_name", sectionIdOrName,
                                        "section_id", id)
                                return id, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">logging.MainLogger.Error("Section not found by ID or name",
                "section_id_or_name", sectionIdOrName)
        return "", fmt.Errorf("section not found: '%s' (searched by both ID and name)", sectionIdOrName)</span>
}

// isValidOneNoteIDFormat checks if a string looks like a valid OneNote ID
// OneNote IDs typically contain alphanumeric characters, hyphens, and exclamation marks
func isValidOneNoteIDFormat(id string) bool <span class="cov0" title="0">{
        if len(id) &lt; 10 </span><span class="cov0" title="0">{ // OneNote IDs are typically longer
                return false
        }</span>

        // OneNote IDs contain these characters: A-Za-z0-9-!
        <span class="cov0" title="0">for _, char := range id </span><span class="cov0" title="0">{
                if !((char &gt;= 'A' &amp;&amp; char &lt;= 'Z') ||
                        (char &gt;= 'a' &amp;&amp; char &lt;= 'z') ||
                        (char &gt;= '0' &amp;&amp; char &lt;= '9') ||
                        char == '-' || char == '!') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package main

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/authorization"
        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/notebooks"
        "github.com/gebl/onenote-mcp-server/internal/pages"
        "github.com/gebl/onenote-mcp-server/internal/resources"
        "github.com/gebl/onenote-mcp-server/internal/sections"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

// registerPageTools registers all page-related MCP tools
// verifySectionNotebookOwnership checks that a section belongs to the currently selected notebook
func verifySectionNotebookOwnership(ctx context.Context, sectionID string, sectionClient *sections.SectionClient, notebookCache *NotebookCache, operationName string) error <span class="cov0" title="0">{
        // SECURITY: Verify the section belongs to the currently selected notebook
        currentNotebook, hasNotebook := notebookCache.GetDisplayName()
        if !hasNotebook || currentNotebook == "" </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("Operation requires notebook selection", 
                        "operation", operationName,
                        "section_id", sectionID)
                return fmt.Errorf("no notebook selected. Use selectNotebook tool first")
        }</span>

        // Resolve which notebook owns this section
        <span class="cov0" title="0">resolvedNotebookID, resolvedNotebookName, err := sectionClient.ResolveSectionNotebook(ctx, sectionID)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("Operation failed to resolve section notebook ownership", 
                        "operation", operationName,
                        "section_id", sectionID, 
                        "error", err.Error(),
                        "security_action", "BLOCKING_UNVERIFIED_SECTION_ACCESS")
                return fmt.Errorf("could not verify section ownership: %v", err)
        }</span>

        // Check if the resolved notebook matches the currently selected notebook
        <span class="cov0" title="0">if resolvedNotebookName != currentNotebook </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("SECURITY VIOLATION: Section belongs to different notebook than selected",
                        "operation", operationName,
                        "section_id", sectionID,
                        "resolved_notebook", resolvedNotebookName,
                        "current_notebook", currentNotebook,
                        "security_action", "BLOCKING_CROSS_NOTEBOOK_SECTION_ACCESS")
                return fmt.Errorf("access denied: section belongs to notebook '%s' but '%s' is selected", resolvedNotebookName, currentNotebook)
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("Section notebook ownership verified",
                "operation", operationName,
                "section_id", sectionID,
                "notebook", resolvedNotebookName,
                "notebook_id", resolvedNotebookID)
        
        return nil</span>
}

// verifyPageNotebookOwnership checks that a page belongs to the currently selected notebook
func verifyPageNotebookOwnership(ctx context.Context, pageID string, pageClient *pages.PageClient, notebookCache *NotebookCache, operationName string) error <span class="cov0" title="0">{
        // SECURITY: Verify the page belongs to the currently selected notebook
        currentNotebook, hasNotebook := notebookCache.GetDisplayName()
        if !hasNotebook || currentNotebook == "" </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("Operation requires notebook selection", 
                        "operation", operationName,
                        "page_id", pageID)
                return fmt.Errorf("no notebook selected. Use selectNotebook tool first")
        }</span>

        // Resolve which notebook owns this page
        <span class="cov0" title="0">resolvedNotebookID, resolvedNotebookName, resolvedSectionID, resolvedSectionName, err := pageClient.ResolvePageNotebook(ctx, pageID)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("Operation failed to resolve page notebook ownership", 
                        "operation", operationName,
                        "page_id", pageID, 
                        "error", err.Error(),
                        "security_action", "BLOCKING_UNVERIFIED_PAGE_ACCESS")
                return fmt.Errorf("could not verify page ownership: %v", err)
        }</span>

        // Check if the resolved notebook matches the currently selected notebook
        <span class="cov0" title="0">if resolvedNotebookName != currentNotebook </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("SECURITY VIOLATION: Page belongs to different notebook than selected",
                        "operation", operationName,
                        "page_id", pageID,
                        "resolved_notebook", resolvedNotebookName,
                        "current_notebook", currentNotebook,
                        "resolved_section", resolvedSectionName,
                        "security_action", "BLOCKING_CROSS_NOTEBOOK_PAGE_ACCESS")
                return fmt.Errorf("access denied: page belongs to notebook '%s' but '%s' is selected", resolvedNotebookName, currentNotebook)
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("Page notebook ownership verified",
                "operation", operationName,
                "page_id", pageID,
                "notebook", resolvedNotebookName,
                "section", resolvedSectionName,
                "section_id", resolvedSectionID,
                "notebook_id", resolvedNotebookID)
        
        return nil</span>
}

func registerPageTools(s *server.MCPServer, pageClient *pages.PageClient, graphClient *graph.Client, notebookCache *NotebookCache, cfg *config.Config, authConfig *authorization.AuthorizationConfig, cache authorization.NotebookCache, quickNoteConfig authorization.QuickNoteConfig) <span class="cov8" title="1">{
        // listPages: List all pages in a section
        listPagesTool := mcp.NewTool(
                "listPages",
                mcp.WithDescription(resources.MustGetToolDescription("listPages")),
                mcp.WithString("sectionID", mcp.Required(), mcp.Description("Section ID - MUST be actual ID, NOT a section name. You must obtain the section ID through other means.")),
        )
        listPagesHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Starting page enumeration", "operation", "listPages", "type", "tool_invocation")

                sectionID, err := req.RequireString("sectionID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("listPages missing sectionID", "error", err)
                        return mcp.NewToolResultError("sectionID is required"), nil
                }</span>
                <span class="cov0" title="0">logging.ToolsLogger.Debug("listPages parameter", "sectionID", sectionID)

                // SECURITY: Verify the section belongs to the currently selected notebook  
                // We need to create a section client to resolve ownership
                sectionClient := sections.NewSectionClient(graphClient)
                if err := verifySectionNotebookOwnership(ctx, sectionID, sectionClient, notebookCache, "listPages"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                // Extract progress token early for use throughout the function
                <span class="cov0" title="0">progressToken := utils.ExtractProgressToken(req)
                
                // Check cache first
                if progressToken != "" </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 5, 100, "Checking page cache...")
                }</span>
                
                <span class="cov0" title="0">if notebookCache.IsPagesCached(sectionID) </span><span class="cov0" title="0">{
                        cachedPages, cached := notebookCache.GetPagesCache(sectionID)
                        if cached </span><span class="cov0" title="0">{
                                // Apply authorization filtering to cached pages
                                originalCachedCount := len(cachedPages)
                                if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                                        // Try to get section and notebook context for filtering
                                        var sectionName, notebookName string
                                        if cache != nil </span><span class="cov0" title="0">{
                                                // If sections aren't cached yet, try to fetch them for proper authorization context
                                                if !notebookCache.IsSectionsCached() </span><span class="cov0" title="0">{
                                                        logging.ToolsLogger.Debug("Sections not cached, fetching for authorization context", 
                                                                "section_id", sectionID)
                                                        
                                                        // Progress token already extracted above
                                                        if progressToken != "" </span><span class="cov0" title="0">{
                                                                sendProgressNotification(s, ctx, progressToken, 10, 100, "Fetching sections for authorization context...")
                                                        }</span>
                                                        
                                                        // Fetch sections to populate cache for authorization
                                                        <span class="cov0" title="0">if err := populateSectionsForAuthorization(s, ctx, graphClient, notebookCache, progressToken); err != nil </span><span class="cov0" title="0">{
                                                                logging.ToolsLogger.Warn("Failed to populate sections for authorization context", "error", err)
                                                        }</span>
                                                        
                                                        <span class="cov0" title="0">if progressToken != "" </span><span class="cov0" title="0">{
                                                                sendProgressNotification(s, ctx, progressToken, 30, 100, "Authorization context updated, applying filters...")
                                                        }</span>
                                                }
                                                // Try to get section name with progress-aware API lookup if cache misses
                                        <span class="cov0" title="0">if progressToken != "" </span><span class="cov0" title="0">{
                                                sendProgressNotification(s, ctx, progressToken, 32, 100, "Resolving section name for authorization...")
                                        }</span>
                                        // Note: Section name resolution simplified for authorization
                                        <span class="cov0" title="0">sectionName, _ = cache.GetDisplayName()
                                        notebookName, _ = cache.GetDisplayName()</span>
                                        }
                                        
                                        // Note: Page filtering removed - all pages within selected notebook are now accessible
                                        <span class="cov0" title="0">logging.ToolsLogger.Debug("Applied authorization filtering to cached pages",
                                                "section_id", sectionID,
                                                "section_name", sectionName,
                                                "notebook", notebookName,
                                                "original_count", originalCachedCount,
                                                "filtered_count", len(cachedPages))</span>
                                }

                                <span class="cov0" title="0">elapsed := time.Since(startTime)
                                logging.ToolsLogger.Debug("listPages using cached data",
                                        "section_id", sectionID,
                                        "duration", elapsed,
                                        "original_cached_count", originalCachedCount,
                                        "filtered_cached_count", len(cachedPages),
                                        "cache_hit", true)

                                // If cache returns empty results, fall back to fresh API call to be sure
                                if len(cachedPages) == 0 </span><span class="cov0" title="0">{
                                        logging.ToolsLogger.Debug("Cache returned 0 pages, falling back to fresh API call to verify",
                                                "section_id", sectionID)
                                        // Continue to fresh API call below instead of returning immediately
                                }</span> else<span class="cov0" title="0"> {
                                        // Cache has pages, use them
                                        // Create response with cache status
                                        cacheResponse := map[string]interface{}{
                                                "pages":       cachedPages,
                                                "cached":      true,
                                                "cache_hit":   true,
                                                "pages_count": len(cachedPages),
                                                "duration":    elapsed.String(),
                                        }

                                        // Convert cached response to JSON for proper formatting
                                        jsonResult, errMarshal := json.Marshal(cacheResponse)
                                        if errMarshal != nil </span><span class="cov0" title="0">{
                                                logging.ToolsLogger.Error("Failed to marshal cached pages response to JSON", "error", errMarshal)
                                                // Fall through to fetch from API if JSON marshaling fails
                                        }</span> else<span class="cov0" title="0"> {
                                                return mcp.NewToolResultText(string(jsonResult)), nil
                                        }</span>
                                }
                        }
                }

                // Cache miss or expired - fetch from API
                <span class="cov0" title="0">logging.ToolsLogger.Debug("listPages cache miss or expired, fetching from API", "section_id", sectionID)
                
                if progressToken != "" </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 40, 100, "Fetching pages from OneNote API...")
                }</span>
                
                <span class="cov0" title="0">pages, err := pageClient.ListPages(sectionID)
                
                if progressToken != "" </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 55, 100, "Pages retrieved, processing authorization...")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("listPages operation failed", "section_id", sectionID, "error", err, "operation", "listPages")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to list pages: %v", err)), nil
                }</span>

                // Apply authorization filtering to fresh pages
                <span class="cov0" title="0">originalApiCount := len(pages)
                if authConfig != nil &amp;&amp; authConfig.Enabled </span><span class="cov0" title="0">{
                        // Try to get section and notebook context for filtering
                        var sectionName, notebookName string
                        if cache != nil </span><span class="cov0" title="0">{
                                // If sections aren't cached yet, try to fetch them for proper authorization context
                                if !notebookCache.IsSectionsCached() </span><span class="cov0" title="0">{
                                        logging.ToolsLogger.Debug("Sections not cached, fetching for authorization context", 
                                                "section_id", sectionID)
                                        
                                        // Progress token already extracted above
                                        if progressToken != "" </span><span class="cov0" title="0">{
                                                sendProgressNotification(s, ctx, progressToken, 60, 100, "Fetching sections for authorization context...")
                                        }</span>
                                        
                                        // Fetch sections to populate cache for authorization
                                        <span class="cov0" title="0">if err := populateSectionsForAuthorization(s, ctx, graphClient, notebookCache, progressToken); err != nil </span><span class="cov0" title="0">{
                                                logging.ToolsLogger.Warn("Failed to populate sections for authorization context", "error", err)
                                        }</span>
                                        
                                        <span class="cov0" title="0">if progressToken != "" </span><span class="cov0" title="0">{
                                                sendProgressNotification(s, ctx, progressToken, 80, 100, "Authorization context updated, applying filters...")
                                        }</span>
                                }
                                // Try to get section name with progress-aware API lookup if cache misses
                        <span class="cov0" title="0">if progressToken != "" </span><span class="cov0" title="0">{
                                sendProgressNotification(s, ctx, progressToken, 82, 100, "Resolving section name for authorization...")
                        }</span>
                        // Note: Section name resolution simplified for authorization  
                        <span class="cov0" title="0">sectionName, _ = cache.GetDisplayName()
                        notebookName, _ = cache.GetDisplayName()</span>
                        }
                        
                        // Note: Page filtering removed - all pages within selected notebook are now accessible
                        <span class="cov0" title="0">logging.ToolsLogger.Debug("Applied authorization filtering to fresh pages",
                                "section_id", sectionID,
                                "section_name", sectionName,
                                "notebook", notebookName,
                                "original_count", originalApiCount,
                                "filtered_count", len(pages))
                        
                        if progressToken != "" </span><span class="cov0" title="0">{
                                sendProgressNotification(s, ctx, progressToken, 85, 100, "Authorization filtering completed, caching results...")
                        }</span>
                }

                // Cache the filtered results
                <span class="cov0" title="0">notebookCache.SetPagesCache(sectionID, pages)
                
                if progressToken != "" </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 90, 100, "Caching completed, preparing response...")
                }</span>
                <span class="cov0" title="0">logging.ToolsLogger.Debug("listPages cached fresh filtered data", 
                        "section_id", sectionID, 
                        "original_count", originalApiCount,
                        "filtered_count", len(pages))

                elapsed := time.Since(startTime)
                logging.ToolsLogger.Info("listPages operation completed", "duration", elapsed, "pages_count", len(pages), "success", true)

                // Handle empty results gracefully
                if len(pages) == 0 </span><span class="cov0" title="0">{
                        return mcp.NewToolResultText("No pages found in the specified section. The section may be empty or you may need to create pages first."), nil
                }</span>

                // Create response with cache status
                <span class="cov0" title="0">if progressToken != "" </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 95, 100, "Formatting response...")
                }</span>
                
                <span class="cov0" title="0">apiResponse := map[string]interface{}{
                        "pages":       pages,
                        "cached":      false,
                        "cache_hit":   false,
                        "pages_count": len(pages),
                        "duration":    elapsed.String(),
                }

                // Convert to JSON for proper formatting
                jsonResult, err := json.Marshal(apiResponse)
                
                if progressToken != "" </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 100, 100, "Complete!")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("Failed to marshal pages response to JSON", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to format pages: %v", err)), nil
                }</span>
                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonResult)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(listPagesTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("listPages", listPagesHandler, authConfig, cache, quickNoteConfig)))

        // createPage: Create a new page in a section
        createPageTool := mcp.NewTool(
                "createPage",
                mcp.WithDescription(resources.MustGetToolDescription("createPage")),
                mcp.WithString("sectionID", mcp.Required(), mcp.Description("Section ID to create page in")),
                mcp.WithString("title", mcp.Required(), mcp.Description("Page title (cannot contain: ?*\\/:&lt;&gt;|&amp;#''%%~)")),
                mcp.WithString("content", mcp.Required(), mcp.Description("Content for the page (HTML, Markdown, or plain text - automatically detected and converted)")),
        )
        createPageHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Creating new OneNote page", "operation", "createPage", "type", "tool_invocation")

                sectionID, err := req.RequireString("sectionID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createPage missing sectionID", "error", err)
                        return mcp.NewToolResultError("sectionID is required"), nil
                }</span>

                <span class="cov0" title="0">title, err := req.RequireString("title")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createPage missing title", "error", err)
                        return mcp.NewToolResultError("title is required"), nil
                }</span>

                <span class="cov0" title="0">content, err := req.RequireString("content")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createPage missing content", "error", err)
                        return mcp.NewToolResultError("content is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("createPage parameters", "sectionID", sectionID, "title", title, "content_length", len(content))

                // SECURITY: Verify the section belongs to the currently selected notebook
                sectionClient := sections.NewSectionClient(graphClient)
                if err := verifySectionNotebookOwnership(ctx, sectionID, sectionClient, notebookCache, "createPage"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                // Validate title for illegal characters
                <span class="cov0" title="0">illegalChars := []string{"?", "*", "\\", "/", ":", "&lt;", "&gt;", "|", "&amp;", "#", "'", "'", "%", "~"}
                for _, char := range illegalChars </span><span class="cov0" title="0">{
                        if strings.Contains(title, char) </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("createPage title contains illegal character", "character", char, "title", title)
                                suggestedName := utils.SuggestValidName(title, char)
                                return mcp.NewToolResultError(fmt.Sprintf("title contains illegal character '%s'. Illegal characters are: ?*\\/:&lt;&gt;|&amp;#''%%%%~\n\nSuggestion: Try using '%s' instead of '%s'.\n\nSuggested valid title: '%s'", char, utils.GetReplacementChar(char), char, suggestedName)), nil
                        }</span>
                }
                <span class="cov0" title="0">logging.ToolsLogger.Debug("createPage title validation passed")

                // Detect format and convert content to HTML
                convertedHTML, detectedFormat := utils.ConvertToHTML(content)
                logging.ToolsLogger.Debug("createPage content format detection",
                        "detected_format", detectedFormat.String(),
                        "original_length", len(content),
                        "converted_length", len(convertedHTML))

                result, err := pageClient.CreatePage(sectionID, title, convertedHTML)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createPage operation failed", "section_id", sectionID, "error", err, "operation", "createPage")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to create page: %v", err)), nil
                }</span>

                // Clear pages cache for this section since we added a new page
                <span class="cov0" title="0">notebookCache.ClearPagesCache(sectionID)
                logging.ToolsLogger.Debug("createPage cleared pages cache", "section_id", sectionID)

                // Extract only the essential information: success status and page ID
                pageID, exists := result["id"].(string)
                if !exists </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createPage result missing ID field", "result", result)
                        return mcp.NewToolResultError("Page creation succeeded but no ID was returned"), nil
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "success":         true,
                        "pageID":          pageID,
                        "detected_format": detectedFormat.String(),
                        "content_length":  len(content),
                        "html_length":     len(convertedHTML),
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("createPage failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("createPage operation completed", "duration", elapsed, "page_id", pageID)
                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(createPageTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("createPage", createPageHandler, authConfig, cache, quickNoteConfig)))

        // updatePageContent: Update the HTML content of a page
        updatePageContentTool := mcp.NewTool(
                "updatePageContent",
                mcp.WithDescription(resources.MustGetToolDescription("updatePageContent")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to update")),
                mcp.WithString("content", mcp.Required(), mcp.Description("New content for the page (HTML, Markdown, or plain text - automatically detected and converted)")),
        )
        updatePageContentHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Updating OneNote page content", "operation", "updatePageContent", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContent missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                <span class="cov0" title="0">content, err := req.RequireString("content")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContent missing content", "error", err)
                        return mcp.NewToolResultError("content is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("updatePageContent parameters", "pageID", pageID, "content_length", len(content))

                // SECURITY: Verify the page belongs to the currently selected notebook
                if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "updatePageContent"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                // Detect format and convert content to HTML
                <span class="cov0" title="0">convertedHTML, detectedFormat := utils.ConvertToHTML(content)
                logging.ToolsLogger.Debug("updatePageContent content format detection",
                        "detected_format", detectedFormat.String(),
                        "original_length", len(content),
                        "converted_length", len(convertedHTML))

                err = pageClient.UpdatePageContentSimple(pageID, convertedHTML)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContent operation failed", "page_id", pageID, "error", err, "operation", "updatePageContent")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to update page content: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("updatePageContent operation completed", "duration", elapsed)
                
                response := map[string]interface{}{
                        "success":         true,
                        "message":         "Page content updated successfully",
                        "detected_format": detectedFormat.String(),
                        "content_length":  len(content),
                        "html_length":     len(convertedHTML),
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContent failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(updatePageContentTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("updatePageContent", updatePageContentHandler, authConfig, cache, quickNoteConfig)))

        // updatePageContentAdvanced: Update page content with advanced commands
        updatePageContentAdvancedTool := mcp.NewTool(
                "updatePageContentAdvanced",
                mcp.WithDescription(resources.MustGetToolDescription("updatePageContentAdvanced")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to update")),
                mcp.WithString("commands", mcp.Required(), mcp.Description("JSON STRING containing an array of command objects. MUST be a string, not an array. Content in commands supports HTML, Markdown, or plain text (automatically detected and converted). Example: \"[{\\\"target\\\": \\\"body\\\", \\\"action\\\": \\\"append\\\", \\\"content\\\": \\\"# Header\\n- Item 1\\\"}]\"")),
        )
        updatePageContentAdvancedHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("MCP Tool: updatePageContentAdvanced", "operation", "updatePageContentAdvanced", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContentAdvanced missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                // SECURITY: Verify the page belongs to the currently selected notebook
                <span class="cov0" title="0">if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "updatePageContentAdvanced"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov0" title="0">commandsJSON, err := req.RequireString("commands")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContentAdvanced missing commands", "error", err)
                        return mcp.NewToolResultError("commands is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("updatePageContentAdvanced parameters", "pageID", pageID, "commands_length", len(commandsJSON))

                // Parse the commands JSON
                var commands []pages.UpdateCommand
                if errUnmarshal := json.Unmarshal([]byte(commandsJSON), &amp;commands); errUnmarshal != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContentAdvanced failed to parse commands JSON", "error", errUnmarshal)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to parse commands JSON: %v", errUnmarshal)), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("updatePageContentAdvanced commands parsed", "command_count", len(commands))

                // Apply format detection and conversion to each command's content
                var formatDetectionResults []map[string]interface{}
                for i, command := range commands </span><span class="cov0" title="0">{
                        if command.Content != "" </span><span class="cov0" title="0">{
                                originalContent := command.Content
                                convertedHTML, detectedFormat := utils.ConvertToHTML(command.Content)
                                commands[i].Content = convertedHTML

                                // Track format detection results
                                formatDetectionResults = append(formatDetectionResults, map[string]interface{}{
                                        "command_index":    i,
                                        "target":          command.Target,
                                        "action":          command.Action,
                                        "detected_format": detectedFormat.String(),
                                        "original_length": len(originalContent),
                                        "html_length":     len(convertedHTML),
                                })

                                logging.ToolsLogger.Debug("updatePageContentAdvanced command content format detection",
                                        "command_index", i,
                                        "target", command.Target,
                                        "action", command.Action,
                                        "detected_format", detectedFormat.String(),
                                        "original_length", len(originalContent),
                                        "converted_length", len(convertedHTML))
                        }</span>
                }

                <span class="cov0" title="0">err = pageClient.UpdatePageContent(pageID, commands)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContentAdvanced operation failed", "page_id", pageID, "error", err, "operation", "updatePageContentAdvanced")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to update page content: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("updatePageContentAdvanced operation completed", "duration", elapsed)
                
                response := map[string]interface{}{
                        "success":                true,
                        "message":               "Page content updated successfully with advanced commands",
                        "commands_processed":    len(commands),
                        "format_detection":      formatDetectionResults,
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("updatePageContentAdvanced failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(updatePageContentAdvancedTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("updatePageContentAdvanced", updatePageContentAdvancedHandler, authConfig, cache, quickNoteConfig)))

        // deletePage: Delete a page by ID
        deletePageTool := mcp.NewTool(
                "deletePage",
                mcp.WithDescription(resources.MustGetToolDescription("deletePage")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to delete")),
        )
        deletePageHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Deleting OneNote page", "operation", "deletePage", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("deletePage missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                // SECURITY: Verify the page belongs to the currently selected notebook
                <span class="cov0" title="0">if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "deletePage"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("deletePage parameter", "pageID", pageID)

                err = pageClient.DeletePage(pageID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("deletePage operation failed", "page_id", pageID, "error", err, "operation", "deletePage")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to delete page: %v", err)), nil
                }</span>

                // Clear all pages cache since we don't know which section the deleted page was in
                <span class="cov0" title="0">notebookCache.ClearAllPagesCache()
                logging.ToolsLogger.Debug("deletePage cleared all pages cache", "page_id", pageID)

                elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("deletePage operation completed", "duration", elapsed)
                return mcp.NewToolResultText("Page deleted successfully"), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(deletePageTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("deletePage", deletePageHandler, authConfig, cache, quickNoteConfig)))

        // getPageContent: Get the HTML content of a page by ID
        getPageContentTool := mcp.NewTool(
                "getPageContent",
                mcp.WithDescription(resources.MustGetToolDescription("getPageContent")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to fetch content for")),
                mcp.WithString("forUpdate", mcp.Description("Optional: set to 'true' to include includeIDs=true parameter for update operations")),
                mcp.WithString("format", mcp.Description("Optional: output format - 'HTML' (default), 'Markdown', or 'Text'. Note: forUpdate only works with HTML format.")),
        )
        getPageContentHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Retrieving OneNote page content", "operation", "getPageContent", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getPageContent missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                <span class="cov0" title="0">forUpdateStr := req.GetString("forUpdate", "")
                forUpdate := forUpdateStr == "true"
                
                formatStr := req.GetString("format", "HTML")
                format := strings.ToUpper(strings.TrimSpace(formatStr))
                
                // Validate format parameter
                validFormats := []string{"HTML", "MARKDOWN", "TEXT"}
                isValidFormat := false
                for _, validFormat := range validFormats </span><span class="cov0" title="0">{
                        if format == validFormat </span><span class="cov0" title="0">{
                                isValidFormat = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValidFormat </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getPageContent invalid format", "format", format, "valid_formats", validFormats)
                        return mcp.NewToolResultError(fmt.Sprintf("Invalid format '%s'. Valid formats are: HTML, Markdown, Text", formatStr)), nil
                }</span>
                
                // Check for incompatible parameter combinations
                <span class="cov0" title="0">if forUpdate &amp;&amp; format != "HTML" </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getPageContent forUpdate incompatible with non-HTML format", "forUpdate", forUpdate, "format", format)
                        return mcp.NewToolResultError("forUpdate parameter can only be used with HTML format (for page updates)"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("getPageContent parameters", "pageID", pageID, "forUpdate", forUpdate, "format", format)

                // SECURITY: Verify the page belongs to the currently selected notebook
                if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "getPageContent"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                // Always get HTML content first
                <span class="cov0" title="0">htmlContent, err := pageClient.GetPageContent(pageID, forUpdate)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getPageContent operation failed", "page_id", pageID, "error", err, "operation", "getPageContent")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to get page content: %v", err)), nil
                }</span>

                <span class="cov0" title="0">var finalContent string
                var conversionError error

                // Convert content based on requested format
                switch format </span>{
                case "HTML":<span class="cov0" title="0">
                        finalContent = htmlContent
                        logging.ToolsLogger.Debug("getPageContent returning HTML content as-is")</span>
                case "MARKDOWN":<span class="cov0" title="0">
                        logging.ToolsLogger.Debug("getPageContent converting HTML to Markdown")
                        finalContent, conversionError = utils.ConvertHTMLToMarkdown(htmlContent)
                        if conversionError != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("getPageContent HTML to Markdown conversion failed", "error", conversionError)
                                return mcp.NewToolResultError(fmt.Sprintf("Failed to convert content to Markdown: %v", conversionError)), nil
                        }</span>
                case "TEXT":<span class="cov0" title="0">
                        logging.ToolsLogger.Debug("getPageContent converting HTML to plain text")
                        finalContent, conversionError = utils.ConvertHTMLToText(htmlContent)
                        if conversionError != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("getPageContent HTML to plain text conversion failed", "error", conversionError)
                                return mcp.NewToolResultError(fmt.Sprintf("Failed to convert content to plain text: %v", conversionError)), nil
                        }</span>
                }

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("getPageContent operation completed", 
                        "duration", elapsed, 
                        "original_html_length", len(htmlContent), 
                        "final_content_length", len(finalContent),
                        "output_format", format)
                
                // Create response with format information
                response := map[string]interface{}{
                        "content":            finalContent,
                        "format":            format,
                        "original_html_length": len(htmlContent),
                        "final_content_length": len(finalContent),
                }
                
                // Add forUpdate info if applicable
                if forUpdate </span><span class="cov0" title="0">{
                        response["for_update"] = true
                }</span>

                <span class="cov0" title="0">jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getPageContent failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(getPageContentTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("getPageContent", getPageContentHandler, authConfig, cache, quickNoteConfig)))

        // getPageItemContent: Get a OneNote page item (e.g., image) by page item ID, returns binary data with proper MIME type
        getPageItemContentTool := mcp.NewTool(
                "getPageItemContent",
                mcp.WithDescription(resources.MustGetToolDescription("getPageItemContent")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to fetch item from")),
                mcp.WithString("pageItemID", mcp.Required(), mcp.Description("Page resource item ID to fetch")),
                mcp.WithString("filename", mcp.Description("Custom filename for binary download")),
                mcp.WithBoolean("fullSize", mcp.Description("Skip image scaling and return original size (default: false = scale images to 1024x768 max)")),
        )
        getPageItemContentHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("MCP Tool: getPageItemContent", "operation", "getPageItemContent", "type", "tool_invocation")

                pageID := req.GetString("pageID", "")
                pageItemID := req.GetString("pageItemID", "")
                customFilename := req.GetString("filename", "")
                fullSizeStr := req.GetString("fullSize", "false")
                fullSize := fullSizeStr == "true"

                // SECURITY: Verify the page belongs to the currently selected notebook
                if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "getPageItemContent"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("getPageItemContent parameters", "pageID", pageID, "pageItemID", pageItemID, "filename", customFilename, "fullSize", fullSize)

                // Use the enhanced GetPageItem with fullSize parameter
                pageItemData, err := pageClient.GetPageItem(pageID, pageItemID, fullSize)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("getPageItemContent operation failed", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to get page item: %v", err)), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("getPageItemContent retrieved page item", "filename", pageItemData.Filename, "content_type", pageItemData.ContentType, "size_bytes", pageItemData.Size, "tag_name", pageItemData.TagName, "full_size", fullSize)

                // Use custom filename if provided, otherwise use the one from page item data
                filename := pageItemData.Filename
                if customFilename != "" </span><span class="cov0" title="0">{
                        filename = customFilename
                        logging.ToolsLogger.Debug("Using custom filename", "filename", filename)
                }</span>

                // Return binary data with proper MIME type using mcp.NewToolResultImage
                // This should provide the raw binary data with the correct content type
                <span class="cov0" title="0">encoded := base64.StdEncoding.EncodeToString(pageItemData.Content)
                logging.ToolsLogger.Debug("Prepared content for return", "encoded_length", len(encoded), "content_type", pageItemData.ContentType, "filename", filename)

                elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("getPageItemContent operation completed", "duration", elapsed, "scaled", !fullSize &amp;&amp; strings.HasPrefix(pageItemData.ContentType, "image/"))
                return mcp.NewToolResultImage(filename, encoded, pageItemData.ContentType), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(getPageItemContentTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("getPageItemContent", getPageItemContentHandler, authConfig, cache, quickNoteConfig)))

        // listPageItems: List all OneNote page items (images, files, etc.) for a specific page
        listPageItemsTool := mcp.NewTool(
                "listPageItems",
                mcp.WithDescription(resources.MustGetToolDescription("listPageItems")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to list items for")),
        )
        listPageItemsHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("MCP Tool: listPageItems", "operation", "listPageItems", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("listPageItems missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                // SECURITY: Verify the page belongs to the currently selected notebook
                <span class="cov0" title="0">if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "listPageItems"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("listPageItems parameter", "pageID", pageID)

                pageItems, err := pageClient.ListPageItems(pageID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("listPageItems operation failed", "page_id", pageID, "error", err, "operation", "listPageItems")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to list page items: %v", err)), nil
                }</span>

                <span class="cov0" title="0">jsonBytes, err := json.Marshal(pageItems)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("listPageItems failed to marshal page items", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal page items: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Info("listPageItems operation completed", "duration", elapsed, "items_count", len(pageItems), "success", true)
                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(listPageItemsTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("listPageItems", listPageItemsHandler, authConfig, cache, quickNoteConfig)))

        // copyPage: Copy a page from one section to another
        copyPageTool := mcp.NewTool(
                "copyPage",
                mcp.WithDescription(resources.MustGetToolDescription("copyPage")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to copy")),
                mcp.WithString("targetSectionID", mcp.Required(), mcp.Description("Target section ID to copy the page to")),
        )
        copyPageHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Copying OneNote page", "operation", "copyPage", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("copyPage missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                // SECURITY: Verify the page belongs to the currently selected notebook
                <span class="cov0" title="0">if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "copyPage"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov0" title="0">targetSectionID, err := req.RequireString("targetSectionID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("copyPage missing targetSectionID", "error", err)
                        return mcp.NewToolResultError("targetSectionID is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("copyPage parameters", "pageID", pageID, "targetSectionID", targetSectionID)

                result, err := pageClient.CopyPage(pageID, targetSectionID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("copyPage operation failed", "page_id", pageID, "error", err, "operation", "copyPage")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to copy page: %v", err)), nil
                }</span>

                // Clear pages cache for target section since we added a new page
                <span class="cov0" title="0">notebookCache.ClearPagesCache(targetSectionID)
                logging.ToolsLogger.Debug("copyPage cleared pages cache for target section", "target_section_id", targetSectionID)

                jsonBytes, err := json.Marshal(result)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("copyPage failed to marshal copy result", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal copy result: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("copyPage operation completed", "duration", elapsed)
                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(copyPageTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("copyPage", copyPageHandler, authConfig, cache, quickNoteConfig)))

        // movePage: Move a page from one section to another (copy then delete)
        movePageTool := mcp.NewTool(
                "movePage",
                mcp.WithDescription(resources.MustGetToolDescription("movePage")),
                mcp.WithString("pageID", mcp.Required(), mcp.Description("Page ID to move")),
                mcp.WithString("targetSectionID", mcp.Required(), mcp.Description("Target section ID to move the page to")),
        )
        movePageHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Moving OneNote page", "operation", "movePage", "type", "tool_invocation")

                pageID, err := req.RequireString("pageID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("movePage missing pageID", "error", err)
                        return mcp.NewToolResultError("pageID is required"), nil
                }</span>

                // SECURITY: Verify the page belongs to the currently selected notebook
                <span class="cov0" title="0">if err := verifyPageNotebookOwnership(ctx, pageID, pageClient, notebookCache, "movePage"); err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov0" title="0">targetSectionID, err := req.RequireString("targetSectionID")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("movePage missing targetSectionID", "error", err)
                        return mcp.NewToolResultError("targetSectionID is required"), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("movePage parameters", "pageID", pageID, "targetSectionID", targetSectionID)

                result, err := pageClient.MovePage(pageID, targetSectionID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("movePage operation failed", "page_id", pageID, "error", err, "operation", "movePage")
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to move page: %v", err)), nil
                }</span>

                // Clear all pages cache since movePage affects both source and target sections
                // (we don't know the source section ID)
                <span class="cov0" title="0">notebookCache.ClearAllPagesCache()
                logging.ToolsLogger.Debug("movePage cleared all pages cache", "page_id", pageID, "target_section_id", targetSectionID)

                jsonBytes, err := json.Marshal(result)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("movePage failed to marshal move result", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal move result: %v", err)), nil
                }</span>

                <span class="cov0" title="0">elapsed := time.Since(startTime)
                logging.ToolsLogger.Debug("movePage operation completed", "duration", elapsed)
                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(movePageTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("movePage", movePageHandler, authConfig, cache, quickNoteConfig)))

        // quickNote: Add a timestamped note to a configured page
        quickNoteTool := mcp.NewTool(
                "quickNote",
                mcp.WithDescription("Add a timestamped note to a configured page. Uses quicknote settings from configuration file to determine target notebook, page, and date format. Appends content to the page with current timestamp."),
                mcp.WithString("content", mcp.Required(), mcp.Description("Content to add to the quicknote page")),
        )
        quickNoteHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                logging.ToolsLogger.Info("Adding quicknote entry", "operation", "quickNote", "type", "tool_invocation")

                // Extract progress token from request metadata for progress notifications
                var progressToken string
                logging.ToolsLogger.Debug("Starting progress token extraction",
                        "has_meta", req.Params.Meta != nil,
                        "has_progress_token_field", req.Params.Meta != nil &amp;&amp; req.Params.Meta.ProgressToken != nil)

                if req.Params.Meta != nil &amp;&amp; req.Params.Meta.ProgressToken != nil </span><span class="cov0" title="0">{
                        rawToken := req.Params.Meta.ProgressToken
                        logging.ToolsLogger.Debug("Raw progress token found",
                                "token_type", fmt.Sprintf("%T", rawToken),
                                "token_value", rawToken)

                        // Handle both string and numeric progress tokens
                        switch token := rawToken.(type) </span>{
                        case string:<span class="cov0" title="0">
                                progressToken = token
                                logging.ToolsLogger.Debug("Progress token extracted as string", "progress_token", progressToken)</span>
                        case int:<span class="cov0" title="0">
                                progressToken = fmt.Sprintf("%d", token)
                                logging.ToolsLogger.Debug("Progress token extracted as int", "progress_token", progressToken, "original_value", token)</span>
                        case int64:<span class="cov0" title="0">
                                progressToken = fmt.Sprintf("%d", token)
                                logging.ToolsLogger.Debug("Progress token extracted as int64", "progress_token", progressToken, "original_value", token)</span>
                        case float64:<span class="cov0" title="0">
                                // Check if it's a whole number and convert appropriately
                                if token == float64(int64(token)) </span><span class="cov0" title="0">{
                                        progressToken = fmt.Sprintf("%d", int64(token))
                                        logging.ToolsLogger.Debug("Progress token extracted as whole number from float64", "progress_token", progressToken, "original_value", token)
                                }</span> else<span class="cov0" title="0"> {
                                        progressToken = fmt.Sprintf("%.0f", token)
                                        logging.ToolsLogger.Debug("Progress token extracted as rounded float64", "progress_token", progressToken, "original_value", token)
                                }</span>
                        default:<span class="cov0" title="0">
                                logging.ToolsLogger.Debug("Progress token has unsupported type, converting to string", "type", fmt.Sprintf("%T", token), "value", token)
                                progressToken = fmt.Sprintf("%v", token)</span>
                        }
                } else<span class="cov0" title="0"> {
                        logging.ToolsLogger.Debug("No progress token found in request metadata")
                }</span>

                <span class="cov0" title="0">content, err := req.RequireString("content")
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote missing content", "error", err)
                        return mcp.NewToolResultError("content is required"), nil
                }</span>

                // Check if quicknote is configured
                <span class="cov0" title="0">if cfg.QuickNote == nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote not configured")
                        return mcp.NewToolResultError("QuickNote is not configured. Please set page_name and optionally notebook_name and date_format in your configuration."), nil
                }</span>

                <span class="cov0" title="0">if cfg.QuickNote.PageName == "" </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote page name not configured", "page", cfg.QuickNote.PageName)
                        return mcp.NewToolResultError("QuickNote page_name is required in quicknote configuration."), nil
                }</span>

                // Determine target notebook name - use quicknote-specific notebook or fall back to default
                <span class="cov0" title="0">targetNotebookName := cfg.QuickNote.NotebookName
                if targetNotebookName == "" </span><span class="cov0" title="0">{
                        targetNotebookName = cfg.NotebookName
                        logging.ToolsLogger.Debug("quickNote using default notebook name", "default_notebook", targetNotebookName)
                }</span>

                <span class="cov0" title="0">if targetNotebookName == "" </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote no notebook name available", "quicknote_notebook", cfg.QuickNote.NotebookName, "default_notebook", cfg.NotebookName)
                        return mcp.NewToolResultError("No notebook name configured. Please set either quicknote.notebook_name or notebook_name in your configuration."), nil
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("quickNote parameters",
                        "content_length", len(content),
                        "target_notebook", targetNotebookName,
                        "quicknote_notebook_config", cfg.QuickNote.NotebookName,
                        "default_notebook_config", cfg.NotebookName,
                        "target_page", cfg.QuickNote.PageName,
                        "date_format", cfg.QuickNote.DateFormat)

                // Send initial progress notification
                sendProgressNotification(s, ctx, progressToken, 10, 100, "Starting quicknote operation...")

                // Find the notebook by name using cached lookup
                notebookClient := notebooks.NewNotebookClient(graphClient)
                targetNotebook, fromCache, err := getDetailedNotebookByNameCached(notebookClient, notebookCache, targetNotebookName)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote failed to find target notebook", "notebook_name", targetNotebookName, "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to find notebook '%s': %v", targetNotebookName, err)), nil
                }</span>
                
                // Only send progress notification if we actually made an API call
                <span class="cov0" title="0">if fromCache </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 25, 100, fmt.Sprintf("Found notebook in cache: %s", targetNotebookName))
                }</span> else<span class="cov0" title="0"> {
                        sendProgressNotification(s, ctx, progressToken, 25, 100, fmt.Sprintf("Found notebook via API: %s", targetNotebookName))
                }</span>

                // Find the page within the notebook
                <span class="cov0" title="0">sectionClient := sections.NewSectionClient(graphClient)
                notebookID, ok := targetNotebook["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote notebook ID not found in response")
                        return mcp.NewToolResultError("Notebook ID not found in response"), nil
                }</span>

                // Progress notification will be sent based on cache status inside findPageInNotebookWithCache
                <span class="cov0" title="0">targetPage, targetSectionID, pageFromCache, err := findPageInNotebookWithCache(pageClient, sectionClient, notebookCache, s, notebookID, cfg.QuickNote.PageName, progressToken, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote failed to find target page", "page_name", cfg.QuickNote.PageName, "notebook_id", notebookID, "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to find page '%s' in notebook '%s': %v", cfg.QuickNote.PageName, targetNotebookName, err)), nil
                }</span>
                
                // Adjust progress based on cache usage
                <span class="cov0" title="0">if pageFromCache </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 75, 100, "Found page in cache, preparing content...")
                }</span> else<span class="cov0" title="0"> {
                        sendProgressNotification(s, ctx, progressToken, 75, 100, "Found page via search, preparing content...")
                }</span>

                // Format the current time using the configured date format
                <span class="cov0" title="0">currentTime := time.Now()
                formattedDate := currentTime.Format(cfg.QuickNote.DateFormat)

                // Detect format and convert content to HTML
                convertedHTML, detectedFormat := utils.ConvertToHTML(content)
                logging.ToolsLogger.Debug("quickNote content format detection",
                        "detected_format", detectedFormat.String(),
                        "original_length", len(content),
                        "converted_length", len(convertedHTML))

                // Create HTML content with timestamp header and converted content
                htmlContent := fmt.Sprintf(`&lt;h3&gt;%s&lt;/h3&gt;%s`, formattedDate, convertedHTML)

                // Create update command to append to the body
                commands := []pages.UpdateCommand{
                        {
                                Target:  "body",
                                Action:  "append",
                                Content: htmlContent,
                        },
                }

                // Update the page content
                sendProgressNotification(s, ctx, progressToken, 80, 100, "Adding timestamped content to page...")
                pageID, ok := targetPage["pageId"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote page ID not found in response")
                        return mcp.NewToolResultError("Page ID not found in response"), nil
                }</span>

                <span class="cov0" title="0">err = pageClient.UpdatePageContent(pageID, commands)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote failed to update page content", "page_id", pageID, "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to add quicknote to page: %v", err)), nil
                }</span>

                // Clear pages cache for this section and page search cache
                <span class="cov0" title="0">sendProgressNotification(s, ctx, progressToken, 90, 100, "Clearing cache and finalizing...")
                notebookCache.ClearPagesCache(targetSectionID)
                notebookCache.ClearAllPageSearchCache() // Clear page search cache since page content changed
                // Note: We don't clear notebook lookup cache as notebook metadata shouldn't change from page updates
                logging.ToolsLogger.Debug("quickNote cleared pages cache and page search cache", "section_id", targetSectionID)

                elapsed := time.Since(startTime)
                logging.ToolsLogger.Info("quickNote operation completed",
                        "duration", elapsed,
                        "notebook", targetNotebookName,
                        "page", cfg.QuickNote.PageName,
                        "timestamp", formattedDate,
                        "content_length", len(content))

                response := map[string]interface{}{
                        "success":         true,
                        "timestamp":       formattedDate,
                        "notebook":        targetNotebookName,
                        "page":            cfg.QuickNote.PageName,
                        "message":         "Quicknote added successfully",
                        "detected_format": detectedFormat.String(),
                        "content_length":  len(content),
                        "html_length":     len(convertedHTML),
                }

                jsonBytes, err := json.Marshal(response)
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("quickNote failed to marshal response", "error", err)
                        return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal response: %v", err)), nil
                }</span>

                // Send final progress notification
                <span class="cov0" title="0">sendProgressNotification(s, ctx, progressToken, 100, 100, "Quicknote added successfully!")

                return mcp.NewToolResultText(string(jsonBytes)), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(quickNoteTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("quickNote", quickNoteHandler, authConfig, cache, quickNoteConfig)))

        // NOTE: getOnenoteOperation tool is currently commented out in the original code
        // Uncomment this section if you want to enable it
        /*
                // getOnenoteOperation: Get the status of an asynchronous OneNote operation
                getOnenoteOperationTool := mcp.NewTool(
                        "getOnenoteOperation",
                        mcp.WithDescription("Check the status of an asynchronous OneNote operation (e.g., copy/move operations)."),
                        mcp.WithString("operationId", mcp.Required(), mcp.Description("Operation ID to check status for")),
                )
                getOnenoteOperationHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
                        startTime := time.Now()
                        logging.ToolsLogger.Info("MCP Tool: getOnenoteOperation", "operation", "getOnenoteOperation", "type", "tool_invocation")

                        operationId, err := req.RequireString("operationId")
                        if err != nil {
                                logging.ToolsLogger.Error("getOnenoteOperation missing operationId", "error", err)
                                return mcp.NewToolResultError("operationId is required"), nil
                        }

                        logging.ToolsLogger.Debug("getOnenoteOperation parameters", "operationId", operationId)

                        result, err := graphClient.GetOnenoteOperation(operationId)
                        if err != nil {
                                logging.ToolsLogger.Error("getOnenoteOperation operation failed", "operation_id", operationId, "error", err, "operation", "getOnenoteOperation")
                                return mcp.NewToolResultError(fmt.Sprintf("Failed to get operation status: %v", err)), nil
                        }

                        jsonBytes, err := json.Marshal(result)
                        if err != nil {
                                logging.ToolsLogger.Error("getOnenoteOperation failed to marshal operation status", "error", err)
                                return mcp.NewToolResultError(fmt.Sprintf("Failed to marshal operation status: %v", err)), nil
                        }

                        elapsed := time.Since(startTime)
                        logging.ToolsLogger.Debug("getOnenoteOperation completed", "duration", elapsed)
                        return mcp.NewToolResultText(string(jsonBytes)), nil
                }
                s.AddTool(getOnenoteOperationTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("getOnenoteOperation", getOnenoteOperationHandler, authConfig, cache, quickNoteConfig)))
        */

        logging.ToolsLogger.Debug("Page tools registered successfully")</span>
}


// findPageInNotebookWithCache searches for a page by name using cached listPages calls
// This leverages the existing page cache and progress notification system
// Returns the page data, section ID where the page was found, whether result was from cache, and any error
func findPageInNotebookWithCache(pageClient *pages.PageClient, sectionClient *sections.SectionClient, notebookCache *NotebookCache, s *server.MCPServer, notebookID string, pageName string, progressToken string, ctx context.Context) (map[string]interface{}, string, bool, error) <span class="cov0" title="0">{
        logging.ToolsLogger.Debug("Searching for page in notebook using cached listPages", "notebook_id", notebookID, "page_name", pageName)

        // Check if page search results are already cached
        if cachedResult, cached := notebookCache.GetPageSearchCache(notebookID, pageName); cached </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Found cached page search result", 
                        "notebook_id", notebookID, 
                        "page_name", pageName,
                        "found", cachedResult.Found)
                
                if cachedResult.Found </span><span class="cov0" title="0">{
                        sendProgressNotification(s, ctx, progressToken, 30, 100, "Page found in search cache")
                        logging.ToolsLogger.Info("Found target page from search cache",
                                "page_title", pageName,
                                "section_id", cachedResult.SectionID)
                        return cachedResult.Page, cachedResult.SectionID, true, nil
                }</span> else<span class="cov0" title="0"> {
                        // Cached result indicates page was not found
                        sendProgressNotification(s, ctx, progressToken, 30, 100, "Page not found (from cache)")
                        return nil, "", true, fmt.Errorf("page '%s' not found in notebook (from cache)", pageName)
                }</span>
        }

        <span class="cov0" title="0">logging.ToolsLogger.Debug("No cached search result found, performing fresh search")
        sendProgressNotification(s, ctx, progressToken, 30, 100, "Getting notebook sections for page search...")

        // Create progress callback for section listing (30-35%)
        sectionProgressCallback := func(progress int, message string) </span><span class="cov0" title="0">{
                adjustedProgress := 30 + (progress * 5 / 100) // Map 0-100% to 30-35%
                sendProgressNotification(s, ctx, progressToken, adjustedProgress, 100, fmt.Sprintf("Sections: %s", message))
        }</span>

        // Get all sections in the notebook using progress-aware method
        <span class="cov0" title="0">sections, err := sectionClient.ListSectionsWithProgress(notebookID, sectionProgressCallback)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", false, fmt.Errorf("failed to list sections in notebook: %v", err)
        }</span>

        <span class="cov0" title="0">totalSections := len(sections)
        logging.ToolsLogger.Debug("Found sections in notebook for cached search", "notebook_id", notebookID, "sections_count", totalSections)

        sendProgressNotification(s, ctx, progressToken, 35, 100, fmt.Sprintf("Found %d sections, starting page search...", totalSections))

        // Search through each section using cached listPages calls with progress
        for i, section := range sections </span><span class="cov0" title="0">{
                sectionID, ok := section["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Debug("Skipping section with invalid ID in cached search", "section_index", i+1)
                        continue</span> // Skip if ID is not available
                }

                <span class="cov0" title="0">sectionName, ok := section["displayName"].(string)
                if !ok </span><span class="cov0" title="0">{
                        sectionName = "unknown"
                }</span>

                // Calculate progress for this section (35-70% range)
                <span class="cov0" title="0">baseProgress := 35 + int(float64(i)/float64(totalSections)*35) // Distribute 35% across sections
                sendProgressNotification(s, ctx, progressToken, baseProgress, 100, fmt.Sprintf("Searching section %d of %d: %s", i+1, totalSections, sectionName))

                logging.ToolsLogger.Debug("Searching in section using cached listPages",
                        "section_index", i+1,
                        "total_sections", totalSections,
                        "section_id", sectionID,
                        "section_name", sectionName)

                // Use the same cache logic as the listPages tool
                var pages []map[string]interface{}
                var fromCache bool

                if notebookCache.IsPagesCached(sectionID) </span><span class="cov0" title="0">{
                        cachedPages, cached := notebookCache.GetPagesCache(sectionID)
                        if cached </span><span class="cov0" title="0">{
                                pages = cachedPages
                                fromCache = true
                                sendProgressNotification(s, ctx, progressToken, baseProgress+1, 100, fmt.Sprintf("Using cached pages for section: %s", sectionName))
                                logging.ToolsLogger.Debug("Using cached pages for section",
                                        "section_id", sectionID,
                                        "section_name", sectionName,
                                        "pages_count", len(pages))
                        }</span>
                }

                <span class="cov0" title="0">if !fromCache </span><span class="cov0" title="0">{
                        // Cache miss - fetch from API with progress
                        logging.ToolsLogger.Debug("Cache miss, fetching pages from API with progress",
                                "section_id", sectionID,
                                "section_name", sectionName)

                        // Create progress callback for page listing within section
                        pageProgressCallback := func(progress int, message string) </span><span class="cov0" title="0">{
                                // Map page progress to a small portion of overall progress
                                adjustedProgress := baseProgress + (progress * 2 / 100) // Allow 2% per section for page loading
                                if adjustedProgress &gt; baseProgress + 2 </span><span class="cov0" title="0">{
                                        adjustedProgress = baseProgress + 2
                                }</span>
                                <span class="cov0" title="0">sendProgressNotification(s, ctx, progressToken, adjustedProgress, 100, fmt.Sprintf("Section %s: %s", sectionName, message))</span>
                        }

                        <span class="cov0" title="0">pagesFromAPI, err := pageClient.ListPagesWithProgress(sectionID, pageProgressCallback)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Warn("Failed to list pages in section during cached search",
                                        "section_id", sectionID,
                                        "section_name", sectionName,
                                        "error", err)
                                continue</span> // Continue searching other sections
                        }
                        <span class="cov0" title="0">pages = pagesFromAPI
                        // Cache the results
                        notebookCache.SetPagesCache(sectionID, pages)
                        logging.ToolsLogger.Debug("Cached fresh pages data",
                                "section_id", sectionID,
                                "section_name", sectionName,
                                "pages_count", len(pages))</span>
                }

                // Extract page names for logging
                <span class="cov0" title="0">var pageNames []string
                for _, page := range pages </span><span class="cov0" title="0">{
                        if pageTitle, ok := page["title"].(string); ok </span><span class="cov0" title="0">{
                                pageNames = append(pageNames, pageTitle)
                        }</span> else<span class="cov0" title="0"> {
                                pageNames = append(pageNames, "&lt;invalid title&gt;")
                        }</span>
                }

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Found pages in section (cached search)",
                        "section_id", sectionID,
                        "section_name", sectionName,
                        "pages_count", len(pages),
                        "page_names", pageNames,
                        "from_cache", fromCache)

                // Look for the page by name
                for j, page := range pages </span><span class="cov0" title="0">{
                        pageTitle, ok := page["title"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Debug("Skipping page with invalid title in cached search",
                                        "section_name", sectionName,
                                        "page_index", j+1)
                                continue</span> // Skip if title is not available
                        }

                        <span class="cov0" title="0">logging.ToolsLogger.Debug("Examining page in cached search",
                                "section_name", sectionName,
                                "page_index", j+1,
                                "total_pages", len(pages),
                                "page_title", pageTitle,
                                "target_page", pageName,
                                "title_match", pageTitle == pageName,
                                "from_cache", fromCache)

                        if pageTitle == pageName </span><span class="cov0" title="0">{
                                pageID, ok := page["pageId"].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        logging.ToolsLogger.Debug("Found matching page but invalid ID in cached search",
                                                "page_title", pageTitle,
                                                "section_name", sectionName)
                                        continue</span> // Skip if ID is not available
                                }

                                // Cache the successful search result
                                <span class="cov0" title="0">searchResult := PageSearchResult{
                                        Page:      page,
                                        SectionID: sectionID,
                                        Found:     true,
                                }
                                notebookCache.SetPageSearchCache(notebookID, pageName, searchResult)
                                logging.ToolsLogger.Debug("Cached successful page search result",
                                        "notebook_id", notebookID,
                                        "page_name", pageName,
                                        "section_id", sectionID)

                                // Send completion notification if available
                                sendProgressNotification(s, ctx, progressToken, 75, 100, fmt.Sprintf("Page found in section: %s", sectionName))

                                logging.ToolsLogger.Info("Found target page using cached search",
                                        "page_id", pageID,
                                        "page_title", pageTitle,
                                        "section_id", sectionID,
                                        "section_name", sectionName,
                                        "from_cache", fromCache)
                                return page, sectionID, false, nil</span>
                        }
                }

                <span class="cov0" title="0">logging.ToolsLogger.Debug("Page not found in section (cached search)",
                        "section_name", sectionName,
                        "target_page", pageName,
                        "searched_pages", len(pages),
                        "from_cache", fromCache)</span>
        }

        // Cache the failed search result
        <span class="cov0" title="0">searchResult := PageSearchResult{
                Page:      nil,
                SectionID: "",
                Found:     false,
        }
        notebookCache.SetPageSearchCache(notebookID, pageName, searchResult)
        logging.ToolsLogger.Debug("Cached failed page search result",
                "notebook_id", notebookID,
                "page_name", pageName)

        return nil, "", false, fmt.Errorf("page '%s' not found in notebook", pageName)</span>
}

// getDetailedNotebookByNameCached retrieves comprehensive notebook information by display name with caching
// This is a cached wrapper around notebooks.GetDetailedNotebookByName
// Returns the notebook data and a boolean indicating if it was from cache
func getDetailedNotebookByNameCached(notebookClient *notebooks.NotebookClient, notebookCache *NotebookCache, notebookName string) (map[string]interface{}, bool, error) <span class="cov0" title="0">{
        logging.ToolsLogger.Debug("Getting detailed notebook by name with caching", "notebook_name", notebookName)

        // Check if notebook lookup is already cached
        if cachedNotebook, cached := notebookCache.GetNotebookLookupCache(notebookName); cached </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Found cached notebook lookup result", 
                        "notebook_name", notebookName,
                        "cached_notebook_id", cachedNotebook["id"],
                        "cached_notebook_data", cachedNotebook)
                logging.ToolsLogger.Info("Found notebook from lookup cache",
                        "notebook_name", notebookName,
                        "notebook_id", cachedNotebook["id"])
                return cachedNotebook, true, nil
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("No cached notebook lookup found, performing fresh lookup")

        // Cache miss - fetch from API
        notebook, err := notebookClient.GetDetailedNotebookByName(notebookName)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Failed to get notebook by name", "notebook_name", notebookName, "error", err)
                return nil, false, err
        }</span>

        // Log the fresh notebook data before caching
        <span class="cov0" title="0">logging.ToolsLogger.Debug("Fresh notebook lookup result", 
                "notebook_name", notebookName,
                "fresh_notebook_id", notebook["id"],
                "fresh_notebook_data", notebook)

        // Cache the successful result
        notebookCache.SetNotebookLookupCache(notebookName, notebook)
        logging.ToolsLogger.Debug("Cached notebook lookup result", "notebook_name", notebookName, "notebook_id", notebook["id"])

        return notebook, false, nil</span>
}

// Helper functions for progress notifications and section population

// extractProgressToken extracts progress token from MCP request for notifications

// populateSectionsForAuthorization fetches sections to populate cache for authorization context
func populateSectionsForAuthorization(s *server.MCPServer, ctx context.Context, graphClient *graph.Client, notebookCache *NotebookCache, progressToken string) error <span class="cov0" title="0">{
        // Check if notebook is selected
        notebookID, isSet := notebookCache.GetNotebookID()
        if !isSet </span><span class="cov0" title="0">{
                return fmt.Errorf("no notebook selected")
        }</span>
        
        <span class="cov0" title="0">logging.ToolsLogger.Debug("Populating sections for authorization context", 
                "notebook_id", notebookID,
                "has_progress_token", progressToken != "")
        
        // Create section client for fetching sections
        sectionClient := sections.NewSectionClient(graphClient)
        
        // Get sections with progress notifications
        if progressToken != "" </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 15, 100, "Fetching notebook sections for authorization...")
        }</span>
        
        // Create a progress context with typed keys (compatible with fetchAllNotebookContentWithProgress)
        <span class="cov0" title="0">progressCtx := context.WithValue(ctx, mcpServerKey, s)
        progressCtx = context.WithValue(progressCtx, progressTokenKey, progressToken)
        
        if progressToken != "" </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 18, 100, "Calling sections API...")
        }</span>
        
        // Fetch all sections and section groups recursively using the same function as getNotebookSections
        <span class="cov0" title="0">sectionItems, err := fetchAllNotebookContentWithProgress(sectionClient, notebookID, progressCtx)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Warn("Failed to fetch sections for authorization context", "error", err)
                return err
        }</span>
        
        <span class="cov0" title="0">if progressToken != "" </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 22, 100, "Processing section tree structure...")
        }</span>
        
        // Create sections tree structure compatible with cache format
        <span class="cov0" title="0">sectionsTreeStructure := map[string]interface{}{
                "sections": sectionItems,
        }
        
        if progressToken != "" </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 24, 100, "Caching section information...")
        }</span>
        
        // Cache the sections tree
        <span class="cov0" title="0">notebookCache.SetSectionsTree(sectionsTreeStructure)
        
        if progressToken != "" </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 25, 100, "Sections cached for authorization context")
        }</span>
        
        <span class="cov0" title="0">logging.ToolsLogger.Debug("Successfully populated sections for authorization context", "sections_count", len(sectionItems))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// OneNote MCP Server Section Resources
//
// This file implements MCP (Model Context Protocol) section-related resources for accessing
// Microsoft OneNote sections and section groups through a hierarchical REST-like URI structure.
//
// ## Section Resource URIs
//
// ### Available Section Resource URIs
//
// #### 1. List Sections in a Notebook
// **URI:** `onenote://notebooks/{NotebookDisplayName}/sections`
// **Purpose:** Get hierarchical view of all sections and section groups within a notebook
// **Parameters:**
//   - `{NotebookDisplayName}`: URL-encoded display name of the notebook
// **Returns:** JSON object with hierarchical structure showing sections and section groups
//
// #### 2. List All Sections Across All Notebooks
// **URI:** `onenote://sections`
// **Purpose:** Get all sections across all notebooks using Microsoft Graph global sections endpoint
// **Parameters:** None
// **API Equivalent:** `https://graph.microsoft.com/v1.0/me/onenote/sections?$select=displayName,id`
// **Returns:** JSON object with flat list of all sections with displayName and id fields
//

package main

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "strings"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/notebooks"
        "github.com/gebl/onenote-mcp-server/internal/sections"
)

// registerSectionResources registers all section-related MCP resources
func registerSectionResources(s *server.MCPServer, graphClient *graph.Client, cfg *config.Config) <span class="cov0" title="0">{
        logging.MainLogger.Debug("Starting section resource registration process")

        // Register sections by notebook name resource template
        logging.MainLogger.Debug("Creating sections by notebook resource template",
                "template_pattern", "onenote://notebooks/{name}/sections",
                "resource_type", "template_resource")
        sectionsTemplate := mcp.NewResourceTemplate(
                "onenote://notebooks/{name}/sections",
                "OneNote Sections for Notebook",
                mcp.WithTemplateDescription("Hierarchical view of sections and section groups within a specific notebook to understand its organizational structure"),
                mcp.WithTemplateMIMEType("application/json"),
        )

        s.AddResourceTemplate(sectionsTemplate, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Resource template handler invoked",
                        "template_pattern", "onenote://notebooks/{name}/sections",
                        "request_uri", request.Params.URI,
                        "handler_type", "notebook_sections")

                // Extract notebook name from URI
                notebookName := extractNotebookNameFromSectionsURI(request.Params.URI)
                if notebookName == "" </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Invalid notebook name in sections URI",
                                "request_uri", request.Params.URI,
                                "extracted_name", notebookName)
                        return nil, fmt.Errorf("invalid notebook name in URI: %s", request.Params.URI)
                }</span>

                <span class="cov0" title="0">logging.MainLogger.Debug("Extracted notebook name from sections URI",
                        "notebook_name", notebookName,
                        "request_uri", request.Params.URI)

                // Call the same logic as getNotebookSections tool with progress support
                jsonData, err := getNotebookSectionsForResource(ctx, s, graphClient, notebookName, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to get notebook sections for resource",
                                "notebook_name", notebookName,
                                "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">responseSize := len(jsonData)
                logging.MainLogger.Debug("Successfully prepared sections resource response",
                        "notebook_name", notebookName,
                        "request_uri", request.Params.URI,
                        "response_size_bytes", responseSize)

                return []mcp.ResourceContents{
                        mcp.TextResourceContents{
                                URI:      request.Params.URI,
                                MIMEType: "application/json",
                                Text:     string(jsonData),
                        },
                }, nil</span>
        })
        <span class="cov0" title="0">logging.MainLogger.Debug("Registered sections by notebook resource template successfully",
                "template_pattern", "onenote://notebooks/{name}/sections")

        // Register global sections resource - static resource without parameters
        logging.MainLogger.Debug("Creating global sections resource",
                "resource_uri", "onenote://sections",
                "resource_type", "static_resource")
        globalSectionsResource := mcp.NewResource(
                "onenote://sections",
                "OneNote All Sections",
                mcp.WithResourceDescription("Get all sections across all notebooks using Microsoft Graph global sections endpoint (/me/onenote/sections?$select=displayName,id)"),
                mcp.WithMIMEType("application/json"),
        )

        s.AddResource(globalSectionsResource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Global sections resource handler invoked",
                        "resource_uri", "onenote://sections",
                        "request_uri", request.Params.URI,
                        "handler_type", "global_sections")

                // Call the global sections API with progress support
                jsonData, err := getAllSectionsForResource(ctx, s, graphClient, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Error("Failed to get all sections for resource",
                                "error", err)
                        return nil, err
                }</span>

                <span class="cov0" title="0">responseSize := len(jsonData)
                logging.MainLogger.Debug("Successfully prepared global sections resource response",
                        "request_uri", request.Params.URI,
                        "response_size_bytes", responseSize)

                return []mcp.ResourceContents{
                        mcp.TextResourceContents{
                                URI:      request.Params.URI,
                                MIMEType: "application/json",
                                Text:     string(jsonData),
                        },
                }, nil</span>
        })
        <span class="cov0" title="0">logging.MainLogger.Debug("Registered global sections resource successfully",
                "resource_uri", "onenote://sections")

        logging.MainLogger.Debug("Section resource registration completed successfully",
                "total_resources", 2,
                "template_resources", 1,
                "static_resources", 1)</span>
}

// Section-specific URI extraction functions

// extractNotebookNameFromSectionsURI extracts the notebook name from a URI like "onenote://notebooks/{name}/sections"
func extractNotebookNameFromSectionsURI(uri string) string <span class="cov0" title="0">{
        // URI format: onenote://notebooks/{name}/sections
        parts := strings.Split(uri, "/")
        if len(parts) &gt;= 5 &amp;&amp; parts[0] == "onenote:" &amp;&amp; parts[2] == "notebooks" &amp;&amp; parts[4] == "sections" </span><span class="cov0" title="0">{
                // URL decode the notebook name since it's part of a URI
                decodedName, err := url.QueryUnescape(parts[3])
                if err != nil </span><span class="cov0" title="0">{
                        logging.MainLogger.Warn("Failed to URL decode notebook name from sections URI, using raw value",
                                "raw_name", parts[3],
                                "error", err,
                                "uri", uri)
                        return parts[3] // fallback to raw value
                }</span>
                <span class="cov0" title="0">logging.MainLogger.Debug("URL decoded notebook name from sections URI",
                        "raw_name", parts[3],
                        "decoded_name", decodedName,
                        "uri", uri)
                return decodedName</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Shared helper functions used by both notebook and section resources

// getMapKeys returns a slice of all keys in a map[string]interface{} for debugging purposes
func getMapKeys(m map[string]interface{}) []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// getNotebookSectionsForResource calls the same logic as getNotebookSections tool with progress support
// This function reuses the logic from NotebookTools.go to get notebook sections with caching and progress notifications
func getNotebookSectionsForResource(ctx context.Context, s *server.MCPServer, graphClient *graph.Client, notebookName string, cfg *config.Config) ([]byte, error) <span class="cov0" title="0">{
        logging.MainLogger.Debug("getNotebookSectionsForResource called", "notebook_name", notebookName)

        // Create specialized clients
        notebookClient := notebooks.NewNotebookClient(graphClient)
        sectionClient := sections.NewSectionClient(graphClient)

        // Get the specific notebook by name
        logging.MainLogger.Debug("Getting notebook details for resource",
                "notebook_name", notebookName)
        notebook, err := notebookClient.GetDetailedNotebookByName(notebookName)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to get notebook for resource",
                        "notebook_name", notebookName,
                        "error", err)
                return nil, fmt.Errorf("failed to get notebook '%s': %v", notebookName, err)
        }</span>

        <span class="cov0" title="0">notebookID, exists := notebook["notebookId"].(string)
        if !exists </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Notebook ID not found in notebook data",
                        "notebook_name", notebookName,
                        "notebook_data_keys", getMapKeys(notebook))
                return nil, fmt.Errorf("notebook ID not found for notebook '%s'", notebookName)
        }</span>

        <span class="cov0" title="0">logging.MainLogger.Debug("Retrieved notebook ID for resource",
                "notebook_name", notebookName,
                "notebook_id", notebookID)

        // Extract progress token from request metadata (MCP spec for resources)
        var progressToken string
        // For resources, progress tokens might be provided differently than tools
        // We'll check if there's a way to extract it from the context or request
        logging.MainLogger.Debug("Resource progress support - checking for progress token",
                "notebook_name", notebookName)

        // Import the shared types and functions from NotebookTools.go
        // We need to call the same fetchAllNotebookContentWithProgress function
        // Create progress context using the same keys as NotebookTools.go
        progressCtx := context.WithValue(ctx, mcpServerKey, s)
        progressCtx = context.WithValue(progressCtx, progressTokenKey, progressToken)

        // Use the existing fetchAllNotebookContentWithProgress function from NotebookTools.go
        sectionItems, err := fetchAllNotebookContentWithProgress(sectionClient, notebookID, progressCtx)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to fetch all content for resource",
                        "notebook_id", notebookID,
                        "notebook_name", notebookName,
                        "error", err)
                return nil, fmt.Errorf("failed to fetch sections: %v", err)
        }</span>

        // Get notebook display name from the retrieved notebook data
        <span class="cov0" title="0">var notebookDisplayName string
        if displayName, ok := notebook["displayName"].(string); ok </span><span class="cov0" title="0">{
                notebookDisplayName = displayName
        }</span> else<span class="cov0" title="0"> {
                notebookDisplayName = notebookName
        }</span>

        // Apply authorization filtering if enabled
        <span class="cov0" title="0">if cfg != nil &amp;&amp; cfg.Authorization != nil &amp;&amp; cfg.Authorization.Enabled </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Applying authorization filtering to resource sections",
                        "notebook_name", notebookDisplayName,
                        "sections_count_before_filtering", len(sectionItems))
                
                // Convert SectionItem slice to []map[string]interface{} for filtering
                var sectionsForFiltering []map[string]interface{}
                for _, item := range sectionItems </span><span class="cov0" title="0">{
                        sectionMap := map[string]interface{}{
                                "displayName": item.Name,
                                "id":          item.ID,
                                "type":        item.Type,
                        }
                        sectionsForFiltering = append(sectionsForFiltering, sectionMap)
                }</span>
                
                // Apply filtering
                // Note: Section filtering removed - all sections within selected notebook are now accessible
                <span class="cov0" title="0">filteredSections := sectionsForFiltering
                
                // Convert back to SectionItem slice
                var filteredSectionItems []SectionItem
                for _, filteredSection := range filteredSections </span><span class="cov0" title="0">{
                        for _, originalItem := range sectionItems </span><span class="cov0" title="0">{
                                if originalItem.ID == filteredSection["id"].(string) </span><span class="cov0" title="0">{
                                        filteredSectionItems = append(filteredSectionItems, originalItem)
                                        break</span>
                                }
                        }
                }
                
                <span class="cov0" title="0">sectionItems = filteredSectionItems
                
                logging.MainLogger.Debug("Authorization filtering completed for resource sections",
                        "notebook_name", notebookDisplayName,
                        "sections_count_after_filtering", len(sectionItems))</span>
        }

        // Build the same response format as getNotebookSections tool
        <span class="cov0" title="0">response := map[string]interface{}{
                "notebook_name":  notebookDisplayName,
                "notebook_id":    notebookID,
                "sections":       sectionItems,
                "sections_count": len(sectionItems),
                "cached":         false, // Resources typically don't use cache
                "source":         "resource_api",
        }

        jsonData, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to marshal sections for resource",
                        "error", err,
                        "notebook_name", notebookName)
                return nil, fmt.Errorf("failed to marshal sections: %v", err)
        }</span>

        <span class="cov0" title="0">logging.MainLogger.Debug("Successfully prepared notebook sections for resource",
                "notebook_name", notebookName,
                "notebook_id", notebookID,
                "sections_count", len(sectionItems))

        return jsonData, nil</span>
}

// getAllSectionsForResource fetches all sections across all notebooks using the global sections endpoint
// This function calls the Microsoft Graph API equivalent of https://graph.microsoft.com/v1.0/me/onenote/sections?$select=displayName,id
func getAllSectionsForResource(ctx context.Context, s *server.MCPServer, graphClient *graph.Client, cfg *config.Config) ([]byte, error) <span class="cov0" title="0">{
        logging.MainLogger.Debug("getAllSectionsForResource called")

        // Extract progress token from request metadata (MCP spec for resources)
        var progressToken string
        // For resources, progress tokens might be provided differently than tools
        logging.MainLogger.Debug("Resource progress support - checking for progress token")

        // Send initial progress notification
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 0, 100, "Starting to fetch all sections...")
        }</span>

        // Create sections client
        <span class="cov0" title="0">sectionClient := sections.NewSectionClient(graphClient)

        // Create progress context
        progressCtx := context.WithValue(ctx, mcpServerKey, s)
        progressCtx = context.WithValue(progressCtx, progressTokenKey, progressToken)

        // Send progress for API call
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 20, 100, "Calling Microsoft Graph sections API...")
        }</span>

        // Use the new global sections method with context
        <span class="cov0" title="0">sectionsData, err := sectionClient.ListAllSectionsWithContext(progressCtx)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to fetch all sections for resource",
                        "error", err)
                return nil, fmt.Errorf("failed to fetch all sections: %v", err)
        }</span>

        // Send progress for processing
        <span class="cov0" title="0">if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 70, 100, "Processing sections data...")
        }</span>

        // Apply authorization filtering if enabled
        // Note: For global sections, we can only apply section name-based permissions
        // since we don't have notebook context for each section
        <span class="cov0" title="0">if cfg != nil &amp;&amp; cfg.Authorization != nil &amp;&amp; cfg.Authorization.Enabled </span><span class="cov0" title="0">{
                logging.MainLogger.Debug("Applying authorization filtering to global sections resource",
                        "sections_count_before_filtering", len(sectionsData))
                
                var filteredSections []map[string]interface{}
                for _, section := range sectionsData </span><span class="cov0" title="0">{
                        // Note: Section filtering removed - all sections are now accessible
                        filteredSections = append(filteredSections, section)
                }</span>
                <span class="cov0" title="0">sectionsData = filteredSections
                
                logging.MainLogger.Debug("Authorization filtering completed for global sections resource",
                        "sections_count_after_filtering", len(sectionsData))</span>
        }

        // Build response in the same format as the original API
        <span class="cov0" title="0">response := map[string]interface{}{
                "sections":       sectionsData,
                "sections_count": len(sectionsData),
                "source":         "global_sections_api",
                "api_endpoint":   "/me/onenote/sections?$select=displayName,id",
        }

        // Send progress for marshaling
        if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 90, 100, "Preparing response...")
        }</span>

        <span class="cov0" title="0">jsonData, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                logging.MainLogger.Error("Failed to marshal all sections for resource",
                        "error", err)
                return nil, fmt.Errorf("failed to marshal sections: %v", err)
        }</span>

        // Send final progress notification
        <span class="cov0" title="0">if s != nil </span><span class="cov0" title="0">{
                sendProgressNotification(s, ctx, progressToken, 100, 100, "Completed fetching all sections")
        }</span>

        <span class="cov0" title="0">logging.MainLogger.Debug("Successfully prepared all sections for resource",
                "sections_count", len(sectionsData))

        return jsonData, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package main

import (
        "context"
        "fmt"
        "time"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/authorization"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// registerTestTools registers test and utility MCP tools
func registerTestTools(s *server.MCPServer, authConfig *authorization.AuthorizationConfig, cache authorization.NotebookCache, quickNoteConfig authorization.QuickNoteConfig) <span class="cov8" title="1">{
        // testProgress: A tool that emits progress messages for testing progress notifications
        testProgressTool := mcp.NewTool(
                "testProgress",
                mcp.WithDescription("A tool that emits progress messages to test progress notification functionality. Sends progress updates from 0 to 10 over 10 seconds."),
        )
        testProgressHandler := func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                logging.ToolsLogger.Info("Starting test progress tool", "operation", "testProgress", "type", "tool_invocation")

                mcpServer := server.ServerFromContext(ctx)
                if mcpServer == nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("testProgress: No server context available")
                        return mcp.NewToolResultError("Server context not available"), nil
                }</span>

                // Get progress token from meta if available
                <span class="cov0" title="0">var progressToken mcp.ProgressToken
                if req.Params.Meta != nil &amp;&amp; req.Params.Meta.ProgressToken != nil </span><span class="cov0" title="0">{
                        progressToken = req.Params.Meta.ProgressToken
                }</span> else<span class="cov0" title="0"> {
                        // Use a default token if none provided
                        progressToken = "test-progress"
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("testProgress: Using progress token", "token", progressToken)

                // Send initial progress notification
                total := float64(10)
                message := "Starting progress test"
                err := mcpServer.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      0.0,
                        "total":         total,
                        "message":       message,
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Error("testProgress: Failed to send initial progress", "error", err)
                }</span>

                <span class="cov0" title="0">logging.ToolsLogger.Debug("testProgress: Sent initial progress notification", "message", message)

                // Send progress updates from 1 to 10
                for i := 1; i &lt;= 10; i++ </span><span class="cov0" title="0">{
                        time.Sleep(1 * time.Second)
                        progress := float64(i)
                        progressMsg := fmt.Sprintf("Progress: %d/10", i)

                        err := mcpServer.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                                "progressToken": progressToken,
                                "progress":      progress,
                                "total":         total,
                                "message":       progressMsg,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Error("testProgress: Failed to send progress update", "error", err, "step", i)
                        }</span>

                        <span class="cov0" title="0">logging.ToolsLogger.Debug("testProgress: Sent progress update", "step", i, "message", progressMsg)</span>
                }

                <span class="cov0" title="0">logging.ToolsLogger.Info("testProgress operation completed successfully")
                // Return final result
                return mcp.NewToolResultText("Test progress completed successfully"), nil</span>
        }
        <span class="cov8" title="1">s.AddTool(testProgressTool, server.ToolHandlerFunc(authorization.AuthorizedToolHandler("testProgress", testProgressHandler, authConfig, cache, quickNoteConfig)))

        logging.ToolsLogger.Debug("Test tools registered successfully")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// main.go - Entry point for the OneNote MCP Server.
//
// This file sets up the Model Context Protocol (MCP) server that provides seamless
// integration with Microsoft OneNote via the Microsoft Graph API. The server enables
// AI assistants and other MCP clients to read, create, update, and manage OneNote
// notebooks, sections, pages, and embedded content.
//
// Key Features:
// - OAuth 2.0 PKCE authentication with automatic token refresh
// - Complete OneNote CRUD operations (Create, Read, Update, Delete)
// - Rich content handling with HTML support and embedded media
// - Image optimization and metadata extraction
// - Search capabilities using OData filters
// - Comprehensive error handling and logging
//
// Available MCP Tools:
// - listNotebooks: List all OneNote notebooks for the user
// - listAllSections: Get all sections across all notebooks (useful for searching)
// - listSections: List sections within a specific notebook or section group (requires containerId)
// - listPages: List pages within a section
// - createSection: Create new sections in a notebook
// - createPage: Create new pages with HTML content
// - updatePageContent: Update existing page content
// - deletePage: Delete pages by ID
// - copyPage: Copy pages between sections using Microsoft Graph API
// - movePage: Move pages between sections (copy then delete)
// - getPageContent: Retrieve page HTML content
// - listPageItems: List embedded items (images, files) in a page
// - getPageItemContent: Get complete page item data with binary content
//
// Authentication Flow:
// 1. Server loads configuration from environment variables or config file
// 2. OAuth 2.0 PKCE flow handles user authentication
// 3. Access and refresh tokens are stored locally
// 4. Automatic token refresh prevents authentication failures
//
// Configuration:
// - Environment variables: ONENOTE_CLIENT_ID, ONENOTE_TENANT_ID, ONENOTE_REDIRECT_URI
// - Optional config file: Set ONENOTE_MCP_CONFIG environment variable
// - Logging: Set MCP_LOG_FILE for file-based logging
//
// Usage:
//   go build -o onenote-mcp-server ./cmd/onenote-mcp-server
//   ./onenote-mcp-server                    # stdio mode (default)
//   ./onenote-mcp-server -mode=streamable  # Streamable HTTP mode on port 8080
//   ./onenote-mcp-server -mode=streamable -port=8081 # Streamable HTTP mode on custom port
//
// Docker:
//   docker build -t onenote-mcp-server .
//   docker run -p 8080:8080 onenote-mcp-server
//
// For detailed setup instructions, see README.md and docs/setup.md

package main

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/auth"
        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/notebooks"
        "github.com/gebl/onenote-mcp-server/internal/sections"
)

const (
        // Version is the current version of the OneNote MCP server
        Version        = "1.7.0"
        emptyJSONArray = "[]"
)

// PageSearchResult holds the result of a page search operation
type PageSearchResult struct {
        Page      map[string]interface{} // The found page data
        SectionID string                 // Section ID where the page was found
        Found     bool                   // Whether the page was found
}

// NotebookCache holds the currently selected notebook information and sections cache
type NotebookCache struct {
        mu                  sync.RWMutex
        notebook            map[string]interface{}
        notebookID          string
        displayName         string
        isSet               bool
        sectionsTree        map[string]interface{}              // Cached sections tree structure
        sectionsCached      bool                                // Whether sections have been cached
        pagesCache          map[string][]map[string]interface{} // Pages cache by section ID
        pagesCacheTime      map[string]time.Time                // Cache timestamps by section ID
        pageSearchCache     map[string]PageSearchResult         // Page search results cache by notebook:page key
        pageSearchTime      map[string]time.Time                // Page search cache timestamps
        notebookLookupCache map[string]map[string]interface{}   // Notebook lookup results cache by notebook name
        notebookLookupTime  map[string]time.Time                // Notebook lookup cache timestamps
        
        // Optional references for API fallback in authorization
        graphClient         interface{}                         // Graph client for API calls
        mcpServer           interface{}                         // MCP server for progress notifications
}

// NewNotebookCache creates a new notebook cache
func NewNotebookCache() *NotebookCache <span class="cov0" title="0">{
        return &amp;NotebookCache{
                notebook:            make(map[string]interface{}),
                sectionsTree:        make(map[string]interface{}),
                pagesCache:          make(map[string][]map[string]interface{}),
                pagesCacheTime:      make(map[string]time.Time),
                pageSearchCache:     make(map[string]PageSearchResult),
                pageSearchTime:      make(map[string]time.Time),
                notebookLookupCache: make(map[string]map[string]interface{}),
                notebookLookupTime:  make(map[string]time.Time),
        }
}</span>

// SetAPIReferences sets the graph client and MCP server references for API fallback
func (nc *NotebookCache) SetAPIReferences(graphClient interface{}, mcpServer interface{}) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()
        
        nc.graphClient = graphClient
        nc.mcpServer = mcpServer
        
        logging.ToolsLogger.Debug("API references set in notebook cache for authorization fallback",
                "has_graph_client", graphClient != nil,
                "has_mcp_server", mcpServer != nil)
}</span>

// GetAPIReferences returns the stored API references
func (nc *NotebookCache) GetAPIReferences() (interface{}, interface{}) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()
        
        return nc.graphClient, nc.mcpServer
}</span>

// SetNotebook sets the selected notebook in cache and clears sections cache
func (nc *NotebookCache) SetNotebook(notebook map[string]interface{}) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.notebook = notebook
        nc.isSet = true

        // Clear sections cache when notebook changes
        nc.sectionsTree = make(map[string]interface{})
        nc.sectionsCached = false

        // Clear pages cache when notebook changes
        nc.pagesCache = make(map[string][]map[string]interface{})
        nc.pagesCacheTime = make(map[string]time.Time)

        // Clear page search cache when notebook changes
        nc.pageSearchCache = make(map[string]PageSearchResult)
        nc.pageSearchTime = make(map[string]time.Time)

        // Clear notebook lookup cache when notebook changes
        nc.notebookLookupCache = make(map[string]map[string]interface{})
        nc.notebookLookupTime = make(map[string]time.Time)

        // Extract ID and display name for easy access
        if id, ok := notebook["id"].(string); ok </span><span class="cov0" title="0">{
                nc.notebookID = id
        }</span>
        <span class="cov0" title="0">if name, ok := notebook["displayName"].(string); ok </span><span class="cov0" title="0">{
                nc.displayName = name
        }</span>
}

// GetNotebook returns the currently selected notebook
func (nc *NotebookCache) GetNotebook() (map[string]interface{}, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        if !nc.isSet </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Return a copy to prevent race conditions
        <span class="cov0" title="0">notebookCopy := make(map[string]interface{})
        for k, v := range nc.notebook </span><span class="cov0" title="0">{
                notebookCopy[k] = v
        }</span>

        <span class="cov0" title="0">return notebookCopy, true</span>
}

// GetNotebookID returns the currently selected notebook ID
func (nc *NotebookCache) GetNotebookID() (string, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        return nc.notebookID, nc.isSet
}</span>

// GetDisplayName returns the currently selected notebook display name
func (nc *NotebookCache) GetDisplayName() (string, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        return nc.displayName, nc.isSet
}</span>

// GetSectionName returns the section name for a given section ID by searching through the cached sections tree
func (nc *NotebookCache) GetSectionName(sectionID string) (string, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        if !nc.sectionsCached </span><span class="cov0" title="0">{
                return "", false
        }</span>

        // Search through the sections tree to find the section with the given ID
        <span class="cov0" title="0">return nc.findSectionNameInTree(nc.sectionsTree, sectionID)</span>
}

// GetSectionNameWithAutoFetch returns the section name for a given section ID, 
// optionally fetching sections if they're not cached (for authorization context)
func (nc *NotebookCache) GetSectionNameWithAutoFetch(sectionID string, graphClient interface{}, enableAutoFetch bool) (string, bool) <span class="cov0" title="0">{
        // First try the fast cache lookup
        if name, found := nc.GetSectionName(sectionID); found </span><span class="cov0" title="0">{
                return name, true
        }</span>

        // If not found and auto-fetch is disabled, return false
        <span class="cov0" title="0">if !enableAutoFetch </span><span class="cov0" title="0">{
                return "", false
        }</span>

        // If sections aren't cached and we have a graph client, try to fetch them
        // This is primarily for authorization context when sections haven't been loaded yet
        <span class="cov0" title="0">if !nc.IsSectionsCached() &amp;&amp; graphClient != nil </span><span class="cov0" title="0">{
                // This is a simplified auto-fetch - in a real implementation we would:
                // 1. Create a notebook client from the graph client
                // 2. Fetch sections with progress notifications
                // 3. Cache the results
                // 4. Retry the lookup
                // For now, we'll just return false to avoid complexity
                return "", false
        }</span>

        <span class="cov0" title="0">return "", false</span>
}

// GetSectionNameWithProgress returns the section name for a given section ID with progress notification support.
// If not found in cache, it will perform a live API lookup with progress notifications.
func (nc *NotebookCache) GetSectionNameWithProgress(ctx context.Context, sectionID string, mcpServer interface{}, progressToken string, graphClient interface{}) (string, bool) <span class="cov0" title="0">{
        
        logging.ToolsLogger.Debug("Looking up section name with progress support",
                "section_id", sectionID,
                "has_progress_token", progressToken != "",
                "progress_token", progressToken)

        // First try the fast cache lookup
        if name, found := nc.GetSectionName(sectionID); found </span><span class="cov0" title="0">{
                logging.ToolsLogger.Debug("Section name found in cache",
                        "section_id", sectionID,
                        "section_name", name)
                return name, true
        }</span>

        <span class="cov0" title="0">logging.ToolsLogger.Debug("Section name not found in cache, attempting live API lookup",
                "section_id", sectionID,
                "sections_cached", nc.IsSectionsCached())

        // Cast the graph client and MCP server
        graphClientTyped, ok := graphClient.(*graph.Client)
        if !ok </span><span class="cov0" title="0">{
                logging.ToolsLogger.Warn("Invalid graph client type for section lookup",
                        "section_id", sectionID,
                        "client_type", fmt.Sprintf("%T", graphClient))
                return "", false
        }</span>

        <span class="cov0" title="0">var mcpServerTyped *server.MCPServer
        if mcpServer != nil </span><span class="cov0" title="0">{
                mcpServerTyped, _ = mcpServer.(*server.MCPServer)
        }</span>

        // Send progress notification for API lookup
        <span class="cov0" title="0">if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      5,
                        "total":         100,
                        "message":       fmt.Sprintf("Looking up section name for %s via API...", sectionID),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Warn("Failed to send progress notification for section lookup",
                                "error", err,
                                "section_id", sectionID)
                }</span>
        }

        // Create section client for direct API call
        <span class="cov0" title="0">sectionClient := sections.NewSectionClient(graphClientTyped)

        // Try to fetch section details directly by ID
        logging.ToolsLogger.Debug("Attempting direct section lookup by ID",
                "section_id", sectionID)

        // Send progress notification for API call
        if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      10,
                        "total":         100,
                        "message":       "Fetching section details from OneNote API...",
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Warn("Failed to send API progress notification",
                                "error", err,
                                "section_id", sectionID)
                }</span>
        }

        // Try to get section details using the section ID directly
        // This uses the Microsoft Graph API endpoint: /me/onenote/sections/{section-id}
        <span class="cov0" title="0">sectionDetails, err := sectionClient.GetSectionByID(sectionID)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Warn("Failed to fetch section details by ID",
                        "section_id", sectionID,
                        "error", err)

                // Send failure progress notification
                if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                        err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                                "progressToken": progressToken,
                                "progress":      15,
                                "total":         100,
                                "message":       "Section lookup failed, section name unavailable",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Warn("Failed to send failure progress notification", "error", err)
                        }</span>
                }

                <span class="cov0" title="0">return "", false</span>
        }

        // Extract section name from the response
        <span class="cov0" title="0">sectionName := ""
        if displayName, ok := sectionDetails["displayName"].(string); ok </span><span class="cov0" title="0">{
                sectionName = displayName
        }</span>

        <span class="cov0" title="0">if sectionName == "" </span><span class="cov0" title="0">{
                logging.ToolsLogger.Warn("Section details retrieved but displayName is missing",
                        "section_id", sectionID,
                        "section_details", sectionDetails)

                // Send failure progress notification
                if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                        err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                                "progressToken": progressToken,
                                "progress":      20,
                                "total":         100,
                                "message":       "Section found but name is missing",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logging.ToolsLogger.Warn("Failed to send missing name progress notification", "error", err)
                        }</span>
                }

                <span class="cov0" title="0">return "", false</span>
        }

        // Send success progress notification
        <span class="cov0" title="0">if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      25,
                        "total":         100,
                        "message":       fmt.Sprintf("Section name resolved: %s", sectionName),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.ToolsLogger.Warn("Failed to send success progress notification", "error", err)
                }</span>
        }

        <span class="cov0" title="0">logging.ToolsLogger.Debug("Successfully resolved section name via API",
                "section_id", sectionID,
                "section_name", sectionName)

        return sectionName, true</span>
}

// findSectionNameInTree recursively searches through a sections tree structure to find a section by ID
func (nc *NotebookCache) findSectionNameInTree(tree map[string]interface{}, targetSectionID string) (string, bool) <span class="cov0" title="0">{
        // Check if this tree node has sections
        if sectionsInterface, exists := tree["sections"]; exists </span><span class="cov0" title="0">{
                if sections, ok := sectionsInterface.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, sectionInterface := range sections </span><span class="cov0" title="0">{
                                if section, ok := sectionInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        // Check if this section matches the target ID
                                        if sectionID, idExists := section["id"].(string); idExists &amp;&amp; sectionID == targetSectionID </span><span class="cov0" title="0">{
                                                if displayName, nameExists := section["displayName"].(string); nameExists </span><span class="cov0" title="0">{
                                                        return displayName, true
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Check if this tree node has section groups
        <span class="cov0" title="0">if sectionGroupsInterface, exists := tree["sectionGroups"]; exists </span><span class="cov0" title="0">{
                if sectionGroups, ok := sectionGroupsInterface.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, sectionGroupInterface := range sectionGroups </span><span class="cov0" title="0">{
                                if sectionGroup, ok := sectionGroupInterface.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        // Recursively search in section groups
                                        if name, found := nc.findSectionNameInTree(sectionGroup, targetSectionID); found </span><span class="cov0" title="0">{
                                                return name, true
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return "", false</span>
}

// IsSet returns whether a notebook is currently selected
func (nc *NotebookCache) IsSet() bool <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        return nc.isSet
}</span>

// SetSectionsTree sets the cached sections tree structure
func (nc *NotebookCache) SetSectionsTree(sectionsTree map[string]interface{}) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.sectionsTree = sectionsTree
        nc.sectionsCached = true
}</span>

// GetSectionsTree returns the cached sections tree structure
func (nc *NotebookCache) GetSectionsTree() (map[string]interface{}, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        if !nc.sectionsCached </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Return a copy to prevent race conditions
        <span class="cov0" title="0">treeCopy := make(map[string]interface{})
        for k, v := range nc.sectionsTree </span><span class="cov0" title="0">{
                treeCopy[k] = v
        }</span>

        <span class="cov0" title="0">return treeCopy, true</span>
}

// IsSectionsCached returns whether sections have been cached
func (nc *NotebookCache) IsSectionsCached() bool <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        return nc.sectionsCached
}</span>

// ClearSectionsCache clears the sections cache
func (nc *NotebookCache) ClearSectionsCache() <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.sectionsTree = make(map[string]interface{})
        nc.sectionsCached = false
}</span>

// SetPagesCache sets the cached pages for a specific section
func (nc *NotebookCache) SetPagesCache(sectionID string, pages []map[string]interface{}) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.pagesCache[sectionID] = pages
        nc.pagesCacheTime[sectionID] = time.Now()
}</span>

// GetPagesCache returns the cached pages for a specific section
func (nc *NotebookCache) GetPagesCache(sectionID string) ([]map[string]interface{}, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        pages, exists := nc.pagesCache[sectionID]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if cache is still fresh (within 5 minutes)
        <span class="cov0" title="0">cacheTime, timeExists := nc.pagesCacheTime[sectionID]
        if !timeExists || time.Since(cacheTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Return a copy to prevent race conditions
        <span class="cov0" title="0">result := make([]map[string]interface{}, len(pages))
        for i, page := range pages </span><span class="cov0" title="0">{
                pageCopy := make(map[string]interface{})
                for k, v := range page </span><span class="cov0" title="0">{
                        pageCopy[k] = v
                }</span>
                <span class="cov0" title="0">result[i] = pageCopy</span>
        }

        <span class="cov0" title="0">return result, true</span>
}

// IsPagesCached returns whether pages are cached for a specific section
func (nc *NotebookCache) IsPagesCached(sectionID string) bool <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        _, exists := nc.pagesCache[sectionID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if cache is still fresh
        <span class="cov0" title="0">cacheTime, timeExists := nc.pagesCacheTime[sectionID]
        if !timeExists || time.Since(cacheTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// ClearPagesCache clears the pages cache for a specific section
func (nc *NotebookCache) ClearPagesCache(sectionID string) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        delete(nc.pagesCache, sectionID)
        delete(nc.pagesCacheTime, sectionID)
}</span>

// ClearAllPagesCache clears all pages cache
func (nc *NotebookCache) ClearAllPagesCache() <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.pagesCache = make(map[string][]map[string]interface{})
        nc.pagesCacheTime = make(map[string]time.Time)
}</span>

// ClearAllCache clears all cached data (notebook, sections, and pages)
func (nc *NotebookCache) ClearAllCache() <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        // Clear notebook cache (but don't unset the selection)
        // Only clear cached data, keep the notebook selection intact

        // Clear sections cache
        nc.sectionsTree = make(map[string]interface{})
        nc.sectionsCached = false

        // Clear all pages cache
        nc.pagesCache = make(map[string][]map[string]interface{})
        nc.pagesCacheTime = make(map[string]time.Time)

        // Clear page search cache
        nc.pageSearchCache = make(map[string]PageSearchResult)
        nc.pageSearchTime = make(map[string]time.Time)

        // Clear notebook lookup cache
        nc.notebookLookupCache = make(map[string]map[string]interface{})
        nc.notebookLookupTime = make(map[string]time.Time)
}</span>

// GetPageSearchCacheKey creates a cache key for page search results
func (nc *NotebookCache) GetPageSearchCacheKey(notebookID, pageName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", notebookID, pageName)
}</span>

// SetPageSearchCache sets the cached page search result
func (nc *NotebookCache) SetPageSearchCache(notebookID, pageName string, result PageSearchResult) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        key := nc.GetPageSearchCacheKey(notebookID, pageName)
        nc.pageSearchCache[key] = result
        nc.pageSearchTime[key] = time.Now()
}</span>

// GetPageSearchCache returns the cached page search result
func (nc *NotebookCache) GetPageSearchCache(notebookID, pageName string) (PageSearchResult, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        key := nc.GetPageSearchCacheKey(notebookID, pageName)
        result, exists := nc.pageSearchCache[key]
        if !exists </span><span class="cov0" title="0">{
                return PageSearchResult{}, false
        }</span>

        // Check if cache is still fresh (within 5 minutes)
        <span class="cov0" title="0">cacheTime, timeExists := nc.pageSearchTime[key]
        if !timeExists || time.Since(cacheTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return PageSearchResult{}, false
        }</span>

        <span class="cov0" title="0">return result, true</span>
}

// IsPageSearchCached returns whether page search results are cached
func (nc *NotebookCache) IsPageSearchCached(notebookID, pageName string) bool <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        key := nc.GetPageSearchCacheKey(notebookID, pageName)
        _, exists := nc.pageSearchCache[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if cache is still fresh
        <span class="cov0" title="0">cacheTime, timeExists := nc.pageSearchTime[key]
        if !timeExists || time.Since(cacheTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// ClearPageSearchCache clears the page search cache for a specific notebook/page combination
func (nc *NotebookCache) ClearPageSearchCache(notebookID, pageName string) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        key := nc.GetPageSearchCacheKey(notebookID, pageName)
        delete(nc.pageSearchCache, key)
        delete(nc.pageSearchTime, key)
}</span>

// ClearAllPageSearchCache clears all page search cache
func (nc *NotebookCache) ClearAllPageSearchCache() <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.pageSearchCache = make(map[string]PageSearchResult)
        nc.pageSearchTime = make(map[string]time.Time)
}</span>

// SetNotebookLookupCache sets the cached notebook lookup result
func (nc *NotebookCache) SetNotebookLookupCache(notebookName string, notebook map[string]interface{}) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        logging.NotebookLogger.Debug("Storing notebook in cache", 
                "notebook_name", notebookName, 
                "notebook_id", notebook["id"], 
                "notebook_data", notebook)

        nc.notebookLookupCache[notebookName] = notebook
        nc.notebookLookupTime[notebookName] = time.Now()
}</span>

// GetNotebookLookupCache returns the cached notebook lookup result
func (nc *NotebookCache) GetNotebookLookupCache(notebookName string) (map[string]interface{}, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        notebook, exists := nc.notebookLookupCache[notebookName]
        if !exists </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Notebook lookup cache miss - not found in cache", "notebook_name", notebookName)
                return nil, false
        }</span>

        // Check if cache is still fresh (within 5 minutes)
        <span class="cov0" title="0">cacheTime, timeExists := nc.notebookLookupTime[notebookName]
        if !timeExists </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Notebook lookup cache miss - no timestamp", "notebook_name", notebookName)
                return nil, false
        }</span>
        
        <span class="cov0" title="0">age := time.Since(cacheTime)
        if age &gt; 5*time.Minute </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Notebook lookup cache expired", "notebook_name", notebookName, "age", age)
                return nil, false
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Notebook lookup cache hit", "notebook_name", notebookName, "age", age, "notebook_id", notebook["id"])

        // Return a copy to prevent race conditions
        notebookCopy := make(map[string]interface{})
        for k, v := range notebook </span><span class="cov0" title="0">{
                notebookCopy[k] = v
        }</span>

        <span class="cov0" title="0">return notebookCopy, true</span>
}

// IsNotebookLookupCached returns whether notebook lookup results are cached
func (nc *NotebookCache) IsNotebookLookupCached(notebookName string) bool <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        _, exists := nc.notebookLookupCache[notebookName]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if cache is still fresh
        <span class="cov0" title="0">cacheTime, timeExists := nc.notebookLookupTime[notebookName]
        if !timeExists || time.Since(cacheTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// ClearNotebookLookupCache clears the notebook lookup cache for a specific notebook name
func (nc *NotebookCache) ClearNotebookLookupCache(notebookName string) <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        delete(nc.notebookLookupCache, notebookName)
        delete(nc.notebookLookupTime, notebookName)
}</span>

// ClearAllNotebookLookupCache clears all notebook lookup cache
func (nc *NotebookCache) ClearAllNotebookLookupCache() <span class="cov0" title="0">{
        nc.mu.Lock()
        defer nc.mu.Unlock()

        nc.notebookLookupCache = make(map[string]map[string]interface{})
        nc.notebookLookupTime = make(map[string]time.Time)
}</span>

// GetPageName returns the page name for a given page ID by searching through all cached pages
func (nc *NotebookCache) GetPageName(pageID string) (string, bool) <span class="cov0" title="0">{
        nc.mu.RLock()
        defer nc.mu.RUnlock()

        // Search through all cached pages in all sections
        for sectionID, pages := range nc.pagesCache </span><span class="cov0" title="0">{
                // Check if this section's cache is still fresh
                if cacheTime, exists := nc.pagesCacheTime[sectionID]; !exists || time.Since(cacheTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                        continue</span> // Skip expired cache entries
                }

                // Search through pages in this section
                <span class="cov0" title="0">for _, page := range pages </span><span class="cov0" title="0">{
                        // Check both possible field names for page ID
                        var currentPageID string
                        if id, ok := page["id"].(string); ok </span><span class="cov0" title="0">{
                                currentPageID = id
                        }</span> else<span class="cov0" title="0"> if id, ok := page["pageId"].(string); ok </span><span class="cov0" title="0">{
                                currentPageID = id
                        }</span>

                        <span class="cov0" title="0">if currentPageID == pageID </span><span class="cov0" title="0">{
                                if title, ok := page["title"].(string); ok </span><span class="cov0" title="0">{
                                        logging.AuthorizationLogger.Debug("Page name found in cache",
                                                "page_id", pageID,
                                                "page_name", title,
                                                "section_id", sectionID)
                                        return title, true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">logging.AuthorizationLogger.Debug("Page name not found in cache", "page_id", pageID)
        return "", false</span>
}

// GetPageNameWithProgress returns the page name for a given page ID with progress notification support.
// If not found in cache, it will perform a live API lookup with progress notifications.
func (nc *NotebookCache) GetPageNameWithProgress(ctx context.Context, pageID string, mcpServer interface{}, progressToken string, graphClient interface{}) (string, bool) <span class="cov0" title="0">{
        logging.AuthorizationLogger.Debug("Looking up page name with progress support",
                "page_id", pageID,
                "has_progress_token", progressToken != "",
                "progress_token", progressToken)

        // First try the fast cache lookup
        if name, found := nc.GetPageName(pageID); found </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Debug("Page name found in cache",
                        "page_id", pageID,
                        "page_name", name)
                return name, true
        }</span>

        <span class="cov0" title="0">logging.AuthorizationLogger.Debug("Page name not found in cache, attempting live API lookup",
                "page_id", pageID)

        // Cast the graph client and MCP server
        graphClientTyped, ok := graphClient.(*graph.Client)
        if !ok </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Warn("Invalid graph client type for page lookup",
                        "page_id", pageID,
                        "client_type", fmt.Sprintf("%T", graphClient))
                return "", false
        }</span>

        <span class="cov0" title="0">var mcpServerTyped *server.MCPServer
        if mcpServer != nil </span><span class="cov0" title="0">{
                mcpServerTyped, _ = mcpServer.(*server.MCPServer)
        }</span>

        // Send progress notification for API lookup
        <span class="cov0" title="0">if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      5,
                        "total":         100,
                        "message":       fmt.Sprintf("Looking up page name for %s via API...", pageID),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthorizationLogger.Warn("Failed to send progress notification for page lookup",
                                "error", err,
                                "page_id", pageID)
                }</span>
        }

        // Create a basic page client to fetch page details
        // We use the GetPageContent method to get page details including title
        <span class="cov0" title="0">pageApiURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s?$select=id,title", pageID)
        
        if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      10,
                        "total":         100,
                        "message":       "Fetching page details from OneNote API...",
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthorizationLogger.Warn("Failed to send API progress notification",
                                "error", err,
                                "page_id", pageID)
                }</span>
        }

        // Make API call to get page details
        <span class="cov0" title="0">httpResponse, err := graphClientTyped.MakeAuthenticatedRequest("GET", pageApiURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Warn("Failed to fetch page details by ID",
                        "page_id", pageID,
                        "error", err)

                // Send failure progress notification
                if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                        err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                                "progressToken": progressToken,
                                "progress":      15,
                                "total":         100,
                                "message":       "Page lookup failed, page name unavailable",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logging.AuthorizationLogger.Warn("Failed to send failure progress notification", "error", err)
                        }</span>
                }

                <span class="cov0" title="0">return "", false</span>
        }
        <span class="cov0" title="0">defer httpResponse.Body.Close()

        // Read and parse the response body
        var pageDetails map[string]interface{}
        err = json.NewDecoder(httpResponse.Body).Decode(&amp;pageDetails)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Warn("Failed to parse page details response",
                        "page_id", pageID,
                        "error", err)
                return "", false
        }</span>

        // Extract page name from the response
        <span class="cov0" title="0">pageName := ""
        if title, ok := pageDetails["title"].(string); ok </span><span class="cov0" title="0">{
                pageName = title
        }</span>

        <span class="cov0" title="0">if pageName == "" </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Warn("Page details retrieved but title is missing",
                        "page_id", pageID,
                        "page_details", pageDetails)

                // Send failure progress notification
                if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                        err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                                "progressToken": progressToken,
                                "progress":      20,
                                "total":         100,
                                "message":       "Page found but title is missing",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logging.AuthorizationLogger.Warn("Failed to send missing title progress notification", "error", err)
                        }</span>
                }

                <span class="cov0" title="0">return "", false</span>
        }

        // Send success progress notification
        <span class="cov0" title="0">if mcpServerTyped != nil &amp;&amp; progressToken != "" </span><span class="cov0" title="0">{
                err := mcpServerTyped.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                        "progressToken": progressToken,
                        "progress":      25,
                        "total":         100,
                        "message":       fmt.Sprintf("Page name resolved: %s", pageName),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthorizationLogger.Warn("Failed to send success progress notification", "error", err)
                }</span>
        }

        <span class="cov0" title="0">logging.AuthorizationLogger.Info("Page name resolved via API lookup",
                "page_id", pageID,
                "page_name", pageName)

        return pageName, true</span>
}

// Global notebook cache instance
var globalNotebookCache *NotebookCache

// initializeDefaultNotebook initializes the default notebook on server startup
// with authorization filtering and priority-based selection
func initializeDefaultNotebook(graphClient *graph.Client, cfg *config.Config, cache *NotebookCache, logger *slog.Logger) <span class="cov0" title="0">{
        // Only initialize if we have valid authentication
        if graphClient.AccessToken == "" </span><span class="cov0" title="0">{
                logger.Info("No authentication available, skipping default notebook initialization")
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Initializing default notebook", "configured_name", cfg.NotebookName)

        // Import the notebooks package for client creation
        notebookClient := notebooks.NewNotebookClient(graphClient)

        // Get all available notebooks
        allNotebooks, err := notebookClient.ListNotebooks()
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to list notebooks for default initialization", "error", err)
                return
        }</span>

        <span class="cov0" title="0">if len(allNotebooks) == 0 </span><span class="cov0" title="0">{
                logger.Info("No notebooks found, default notebook not set")
                return
        }</span>

        // Apply authorization filtering if enabled
        <span class="cov0" title="0">var availableNotebooks []map[string]interface{}
        if cfg.Authorization != nil &amp;&amp; cfg.Authorization.Enabled </span><span class="cov0" title="0">{
                availableNotebooks = cfg.Authorization.FilterNotebooks(allNotebooks)
                logger.Debug("Applied authorization filtering", 
                        "total_notebooks", len(allNotebooks), 
                        "authorized_notebooks", len(availableNotebooks))
        }</span> else<span class="cov0" title="0"> {
                availableNotebooks = allNotebooks
                logger.Debug("Authorization disabled, all notebooks available",
                        "total_notebooks", len(allNotebooks))
        }</span>

        <span class="cov0" title="0">if len(availableNotebooks) == 0 </span><span class="cov0" title="0">{
                logger.Warn("No notebooks available after authorization filtering")
                return
        }</span>

        <span class="cov0" title="0">var selectedNotebook map[string]interface{}
        var selectionReason string

        // Priority 1: Use configured default notebook name (if authorized)
        if cfg.NotebookName != "" </span><span class="cov0" title="0">{
                logger.Debug("Looking for configured default notebook", "notebook_name", cfg.NotebookName)
                for _, notebook := range availableNotebooks </span><span class="cov0" title="0">{
                        if displayName, ok := notebook["displayName"].(string); ok &amp;&amp; displayName == cfg.NotebookName </span><span class="cov0" title="0">{
                                selectedNotebook = notebook
                                selectionReason = "configured_default"
                                logger.Debug("Found configured default notebook", "notebook_name", displayName)
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if selectedNotebook == nil </span><span class="cov0" title="0">{
                        logger.Warn("Configured default notebook not found or not authorized",
                                "notebook_name", cfg.NotebookName)
                }</span>
        }

        // Priority 2: Look for a notebook marked as default in the API response
        <span class="cov0" title="0">if selectedNotebook == nil </span><span class="cov0" title="0">{
                logger.Debug("Looking for API-marked default notebook")
                for _, notebook := range availableNotebooks </span><span class="cov0" title="0">{
                        if isDefault, ok := notebook["isDefault"].(bool); ok &amp;&amp; isDefault </span><span class="cov0" title="0">{
                                selectedNotebook = notebook
                                selectionReason = "api_marked_default"
                                if displayName, ok := notebook["displayName"].(string); ok </span><span class="cov0" title="0">{
                                        logger.Debug("Found API-marked default notebook", "notebook_name", displayName)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Priority 3: Select the first available authorized notebook
        <span class="cov0" title="0">if selectedNotebook == nil </span><span class="cov0" title="0">{
                selectedNotebook = availableNotebooks[0]
                selectionReason = "first_available"
                if displayName, ok := selectedNotebook["displayName"].(string); ok </span><span class="cov0" title="0">{
                        logger.Debug("Selected first available notebook", "notebook_name", displayName)
                }</span>
        }

        // Perform the selection
        <span class="cov0" title="0">if selectedNotebook != nil </span><span class="cov0" title="0">{
                notebookDisplayName, _ := selectedNotebook["displayName"].(string)
                notebookID, _ := selectedNotebook["id"].(string)

                // Validate authorization if enabled (double-check)
                if cfg.Authorization != nil &amp;&amp; cfg.Authorization.Enabled </span><span class="cov0" title="0">{
                        if err := cfg.Authorization.SetCurrentNotebook(notebookDisplayName); err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to authorize default notebook selection",
                                        "notebook_name", notebookDisplayName,
                                        "error", err)
                                return
                        }</span>
                }

                // Get detailed notebook info for full metadata
                <span class="cov0" title="0">detailedNotebook, err := notebookClient.GetDetailedNotebookByName(notebookDisplayName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Failed to get detailed notebook info, using basic info",
                                "notebook_name", notebookDisplayName, "error", err)
                        cache.SetNotebook(selectedNotebook)
                }</span> else<span class="cov0" title="0"> {
                        cache.SetNotebook(detailedNotebook)
                }</span>

                <span class="cov0" title="0">logger.Info("Default notebook initialized successfully",
                        "notebook_name", notebookDisplayName,
                        "notebook_id", notebookID,
                        "selection_reason", selectionReason)</span>
        }
}

func main() <span class="cov0" title="0">{
        // Initialize structured logging first
        logging.Initialize()
        logger := logging.MainLogger

        // Initialize notebook cache
        globalNotebookCache = NewNotebookCache()

        // Parse command line flags
        mode := flag.String("mode", "stdio", "Server mode: stdio or streamable")
        port := flag.String("port", "8080", "Port for HTTP server (used with streamable mode)")
        flag.Parse()

        // Log version on startup
        logger.Info("OneNote MCP Server starting", "version", Version, "mode", *mode, "port", *port)

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load configuration", "error", err)
                os.Exit(1)
        }</span>

        // Reinitialize logging with configuration values
        <span class="cov0" title="0">logging.InitializeFromConfig(cfg)
        logger = logging.MainLogger // Get fresh logger instance after reinitialization
        logger.Debug("Logging reconfigured based on loaded configuration")

        // Initialize authentication
        oauthConfig := auth.NewOAuth2Config(cfg.ClientID, cfg.TenantID, cfg.RedirectURI)

        // Get token file path from environment variable or use default
        tokenPath := auth.GetTokenPath("tokens.json")

        // Get absolute path for token file
        absTokenPath, err := filepath.Abs(tokenPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Could not get absolute path for token file", "path", tokenPath, "error", err)
                absTokenPath = "unknown"
        }</span>
        <span class="cov0" title="0">logger.Debug("Loading tokens (non-blocking)", "path", absTokenPath)

        // Try to load existing tokens, but don't block if they don't exist or are invalid
        tokenManager, err := auth.LoadTokens(tokenPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("No valid tokens found, server will start without authentication", "error", err)
                logger.Info("Use the 'initiateAuth' MCP tool to authenticate")
                // Create empty token manager to allow server startup
                tokenManager = &amp;auth.TokenManager{
                        AccessToken:  "",
                        RefreshToken: "",
                        Expiry:       0,
                }
        }</span> else<span class="cov0" title="0"> if tokenManager.IsExpired() </span><span class="cov0" title="0">{
                logger.Info("Existing tokens are expired, server will start without authentication")
                logger.Info("Use the 'initiateAuth' MCP tool to re-authenticate")
                // Keep the existing token manager but it will be handled as expired
        }</span> else<span class="cov0" title="0"> {
                logger.Info("Valid authentication tokens loaded successfully")
        }</span>

        // Create Graph client with token refresh capability
        <span class="cov0" title="0">graphConfig := &amp;graph.Config{
                NotebookName: cfg.NotebookName,
        }
        logger.Debug("Creating Graph client", "token_path", absTokenPath)
        graphClient := graph.NewClientWithTokenRefresh(tokenManager.AccessToken, oauthConfig, tokenManager, tokenPath, graphConfig)

        // Create authentication manager for MCP tools
        authManager := auth.NewAuthManager(oauthConfig, tokenManager, tokenPath)

        // Set up token refresh callback to update the graph client
        authManager.SetTokenRefreshCallback(func(newAccessToken string) </span><span class="cov0" title="0">{
                logger.Debug("Updating graph client with new access token")
                graphClient.UpdateToken(newAccessToken)
        }</span>)

        <span class="cov0" title="0">logger.Debug("Authentication manager created")

        // Create MCP server with progress streaming support
        s := server.NewMCPServer("OneNote MCP Server", "1.6.0",
                server.WithToolCapabilities(true),
                server.WithResourceCapabilities(true, true),
                server.WithPromptCapabilities(false))

        // Register MCP Tools and Resources
        registerTools(s, graphClient, authManager, globalNotebookCache, cfg)
        registerResources(s, graphClient, cfg)
        
        // Set API references in cache for authorization fallback
        globalNotebookCache.SetAPIReferences(graphClient, s)

        // Initialize default notebook if authentication is available
        initializeDefaultNotebook(graphClient, cfg, globalNotebookCache, logger)

        switch *mode </span>{
        case "streamable":<span class="cov0" title="0">
                logger.Info("Starting MCP server", "transport", "Streamable HTTP", "port", *port, "request_logging", "enabled")
                streamableServer := server.NewStreamableHTTPServer(s,
                        server.WithStateLess(*cfg.Stateless))
                handler := applyAuthIfEnabled(streamableServer, cfg)
                logger.Info("Streamable HTTP server listening", "address", fmt.Sprintf("http://localhost:%s", *port))
                if err := http.ListenAndServe(":"+*port, handler); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Streamable HTTP server error", "error", err)
                        os.Exit(1)
                }</span>
        case "stdio":<span class="cov0" title="0">
                logger.Info("Starting MCP server", "transport", "stdio")
                if err := server.ServeStdio(s); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Stdio server error", "error", err)
                        os.Exit(1)
                }</span>
        default:<span class="cov0" title="0">
                logger.Error("Invalid mode specified", "mode", *mode, "valid_modes", []string{"stdio", "streamable"})
                os.Exit(1)</span>
        }
}

// applyAuthIfEnabled applies bearer token authentication middleware if enabled in configuration.
// Also applies request logging middleware for all HTTP/SSE requests.
// Returns the handler with middleware applied.
func applyAuthIfEnabled(handler http.Handler, cfg *config.Config) http.Handler <span class="cov0" title="0">{
        logger := logging.MainLogger

        // Always apply request logging middleware first (outermost)
        //handler = auth.RequestLoggingMiddleware()(handler)
        //logger.Debug("Request logging middleware enabled for HTTP transport")

        // Check if MCP authentication is enabled and properly configured
        if cfg.MCPAuth != nil &amp;&amp; cfg.MCPAuth.Enabled </span><span class="cov0" title="0">{
                if cfg.MCPAuth.BearerToken == "" </span><span class="cov0" title="0">{
                        logger.Warn("MCP authentication is enabled but no bearer token is configured",
                                "recommendation", "set MCP_BEARER_TOKEN environment variable or add bearer_token to config file")
                        return handler
                }</span>

                <span class="cov0" title="0">logger.Info("MCP authentication enabled for HTTP transport",
                        "token_length", len(cfg.MCPAuth.BearerToken))
                return auth.BearerTokenMiddleware(cfg.MCPAuth.BearerToken)(handler)</span>
        }

        <span class="cov0" title="0">logger.Debug("MCP authentication disabled - HTTP endpoints are not protected")
        return handler</span>
}

// stringifySections formats sections for output.
func stringifySections(sections interface{}) string <span class="cov8" title="1">{
        if sections == nil </span><span class="cov8" title="1">{
                return emptyJSONArray
        }</span>

        <span class="cov8" title="1">jsonBytes, err := json.Marshal(sections)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to marshal sections", "error", err)
                return fmt.Sprintf("%v", sections)
        }</span>
        <span class="cov8" title="1">return string(jsonBytes)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// OneNote MCP Server Resources
//
// This file implements MCP (Model Context Protocol) resources for accessing Microsoft OneNote data
// through a hierarchical REST-like URI structure. The resources provide AI models with structured
// access to OneNote notebooks, sections, and pages.
//
// Note: Notebook-related resources have been moved to NotebookResources.go for better organization.
// This file now contains only non-notebook resources and the main registration function.

package main

import (
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// registerResources registers all MCP resources for the OneNote server
func registerResources(s *server.MCPServer, graphClient *graph.Client, cfg *config.Config) <span class="cov0" title="0">{
        logging.MainLogger.Debug("Starting resource registration process")

        // Register notebook-related resources from the separate NotebookResources.go file
        registerNotebookResources(s, graphClient, cfg)

        // Register section-related resources from the separate SectionResources.go file
        registerSectionResources(s, graphClient, cfg)

        // Register page-related resources from the separate PageResources.go file
        registerPageResources(s, graphClient, cfg)

        // Future: Additional resources can be registered here
        // For example: direct section access, etc.

        logging.MainLogger.Debug("Resource registration completed successfully")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package main

import (
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/auth"
        "github.com/gebl/onenote-mcp-server/internal/authorization"
        "github.com/gebl/onenote-mcp-server/internal/config"
        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/pages"
)

// registerTools registers all MCP tools for the OneNote server
func registerTools(s *server.MCPServer, graphClient *graph.Client, authManager *auth.AuthManager, notebookCache *NotebookCache, cfg *config.Config) <span class="cov8" title="1">{
        // Create specialized clients for each domain
        pageClient := pages.NewPageClient(graphClient)
        logging.ToolsLogger.Debug("Starting tool registration")

        // Create authorization adapters if authorization is enabled
        var cacheAdapter authorization.NotebookCache
        var quickNoteAdapter authorization.QuickNoteConfig
        var authConfig *authorization.AuthorizationConfig
        
        if cfg != nil &amp;&amp; cfg.Authorization != nil &amp;&amp; cfg.Authorization.Enabled </span><span class="cov0" title="0">{
                authConfig = cfg.Authorization
                cacheAdapter = authorization.NewNotebookCacheAdapter(notebookCache)
                quickNoteAdapter = authorization.NewQuickNoteConfigAdapter(cfg.QuickNote, cfg.NotebookName)
                
                authInfo := authorization.GetAuthorizationInfo(cfg.Authorization)
                logging.ToolsLogger.Info("Authorization is enabled and integrated into tool registration",
                        "enabled", authInfo.Enabled,
                        "default_notebook_mode", authInfo.DefaultNotebookMode,
                        "notebook_rules", authInfo.NotebookRules,
                        "current_notebook", authInfo.CurrentNotebook,
                        "current_notebook_perm", authInfo.CurrentNotebookPerm)
        }</span> else<span class="cov8" title="1"> {
                logging.ToolsLogger.Debug("Authorization is disabled or not configured")
        }</span>

        // Register authentication tools
        <span class="cov8" title="1">registerAuthTools(s, authManager, authConfig, cacheAdapter, quickNoteAdapter)

        // Register notebook and section tools
        registerNotebookTools(s, graphClient, notebookCache, authConfig, cacheAdapter, quickNoteAdapter)

        // Register page tools
        registerPageTools(s, pageClient, graphClient, notebookCache, cfg, authConfig, cacheAdapter, quickNoteAdapter)

        // Register test tools
        registerTestTools(s, authConfig, cacheAdapter, quickNoteAdapter)

        logging.ToolsLogger.Debug("All tools registered successfully")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// auth.go - OAuth2 authentication and token management for the OneNote MCP server.
//
// This file provides a complete OAuth 2.0 PKCE (Proof Key for Code Exchange) implementation
// for authenticating with Microsoft Graph API. It handles the entire authentication flow
// from initial authorization to token refresh and secure storage.
//
// Key Features:
// - OAuth 2.0 PKCE flow for secure public client authentication
// - Automatic token refresh with exponential backoff
// - Local token persistence with secure storage
// - CSRF protection with state parameter validation
// - Comprehensive error handling and logging
// - Support for both single-tenant and multi-tenant Azure applications
//
// Authentication Flow:
// 1. Generate PKCE code verifier and challenge
// 2. Redirect user to Microsoft login with authorization URL
// 3. Handle OAuth callback with authorization code
// 4. Exchange authorization code for access and refresh tokens
// 5. Store tokens securely for future use
// 6. Automatically refresh tokens before expiration
//
// Token Management:
// - Access tokens: Short-lived (1 hour) for API requests
// - Refresh tokens: Long-lived for obtaining new access tokens
// - Automatic expiry detection and refresh
// - Secure local storage in JSON format
// - Token validation and error recovery
//
// Security Features:
// - PKCE prevents authorization code interception attacks
// - State parameter prevents CSRF attacks
// - Input validation and sanitization
// - Secure token storage with file permissions
// - Automatic cleanup of sensitive data
//
// Configuration Requirements:
// - Azure App Registration with OAuth 2.0 configuration
// - Redirect URI: http://localhost:8080/callback (for local development)
// - API Permissions: Notes.ReadWrite (delegated)
// - Supported account types: Single tenant or multi-tenant
//
// Error Handling:
// - PKCE code verifier mismatch detection
// - Token expiration and refresh failures
// - Network connectivity issues
// - Invalid or expired authorization codes
// - Azure app configuration errors
//
// Usage Example:
//   oauthCfg := auth.NewOAuth2Config(clientID, tenantID, redirectURI)
//   tokenManager, err := auth.AuthenticateUser(oauthCfg, "tokens.json")
//   if err != nil {
//       logging.AuthLogger.Error("Authentication failed", "error", err)
//   }
//
// For detailed setup instructions, see README.md and docs/setup.md

package auth

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

const (
        unknownPath = "unknown"
)

// OAuth2Config holds Microsoft Identity Platform OAuth2 configuration for public clients (PKCE).
type OAuth2Config struct {
        ClientID    string // Application (client) ID
        TenantID    string // Directory (tenant) ID
        RedirectURI string // Redirect URI for OAuth2 callback
}

// TokenManager handles access/refresh tokens and their expiry.
type TokenManager struct {
        AccessToken  string `json:"access_token"`  // OAuth2 access token
        RefreshToken string `json:"refresh_token"` // OAuth2 refresh token
        Expiry       int64  `json:"expiry"`        // Unix timestamp for token expiry
}

// NewOAuth2Config creates a new OAuth2Config from config values.
// clientID: Application (client) ID
// tenantID: Directory (tenant) ID
// redirectURI: Redirect URI for OAuth2 callback
// Returns a pointer to an OAuth2Config instance.
func NewOAuth2Config(clientID, tenantID, redirectURI string) *OAuth2Config <span class="cov8" title="1">{
        logging.AuthLogger.Debug("Initializing OAuth2 configuration for Microsoft Graph",
                "client_id", maskSensitiveData(clientID),
                "tenant_id", tenantID,
                "redirect_uri", redirectURI,
                "flow_type", "PKCE")

        config := &amp;OAuth2Config{
                ClientID:    clientID,
                TenantID:    tenantID,
                RedirectURI: redirectURI,
        }

        logging.AuthLogger.Debug("OAuth2 configuration created successfully")
        return config
}</span>

// maskSensitiveData masks sensitive configuration values for logging
func maskSensitiveData(value string) string <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return "&lt;empty&gt;"
        }</span>
        <span class="cov8" title="1">if len(value) &lt;= 8 </span><span class="cov8" title="1">{
                return "***"
        }</span>
        <span class="cov8" title="1">return value[:4] + "***" + value[len(value)-4:]</span>
}

// GenerateCodeVerifier creates a random PKCE code verifier string.
// Returns the code verifier and an error, if any.
func GenerateCodeVerifier() (string, error) <span class="cov8" title="1">{
        b := make([]byte, 32)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return base64.RawURLEncoding.EncodeToString(b), nil</span>
}

// CodeChallengeS256 generates a code challenge from a code verifier using SHA-256.
// Returns the base64url-encoded code challenge string.
func CodeChallengeS256(verifier string) string <span class="cov8" title="1">{
        h := sha256.Sum256([]byte(verifier))
        return base64.RawURLEncoding.EncodeToString(h[:])
}</span>

// GetAuthURL generates the Microsoft login URL for user consent (PKCE).
// state: Opaque value to maintain state between request and callback.
// codeChallenge: PKCE code challenge string.
// Returns the full authorization URL as a string.
func (c *OAuth2Config) GetAuthURL(state, codeChallenge string) string <span class="cov8" title="1">{
        authURL := fmt.Sprintf(
                "https://login.microsoftonline.com/%s/oauth2/v2.0/authorize?client_id=%s&amp;response_type=code&amp;redirect_uri=%s&amp;response_mode=query&amp;scope=%s&amp;state=%s&amp;code_challenge=%s&amp;code_challenge_method=S256",
                url.PathEscape(c.TenantIDOrCommon()),
                url.QueryEscape(c.ClientID),
                url.QueryEscape(c.RedirectURI),
                url.QueryEscape("offline_access Notes.ReadWrite"),
                url.QueryEscape(state),
                url.QueryEscape(codeChallenge),
        )
        
        // Enhanced debugging for troubleshooting unauthorized_client error
        logging.AuthLogger.Info("Generated OAuth authorization URL", 
                "tenant", c.TenantIDOrCommon(), 
                "scope", "Notes.ReadWrite")
        logging.AuthLogger.Debug("OAuth URL components for troubleshooting", 
                "client_id", maskSensitiveData(c.ClientID),
                "redirect_uri", c.RedirectURI,
                "tenant_id_original", c.TenantID,
                "tenant_id_used", c.TenantIDOrCommon(),
                "tenant_is_common", c.TenantID == "" || c.TenantID == "common")
        return authURL
}</span>

// TenantIDOrCommon returns the tenant ID or "common" if not set.
func (c *OAuth2Config) TenantIDOrCommon() string <span class="cov8" title="1">{
        if c.TenantID == "" </span><span class="cov8" title="1">{
                return "common"
        }</span>
        <span class="cov8" title="1">return c.TenantID</span>
}

// ExchangeCode exchanges the auth code for access and refresh tokens (PKCE).
// ctx: Context for the HTTP request.
// code: Authorization code received from the callback.
// codeVerifier: PKCE code verifier string.
// Returns a pointer to a TokenManager and an error, if any.
func (c *OAuth2Config) ExchangeCode(ctx context.Context, code, codeVerifier string) (*TokenManager, error) <span class="cov0" title="0">{
        logging.AuthLogger.Info("Exchanging authorization code for access tokens", "endpoint", "Microsoft Identity Platform")
        endpoint := fmt.Sprintf("https://login.microsoftonline.com/%s/oauth2/v2.0/token", c.TenantIDOrCommon())
        data := url.Values{}
        data.Set("client_id", c.ClientID)
        data.Set("scope", "offline_access Notes.ReadWrite")
        data.Set("code", code)
        data.Set("redirect_uri", c.RedirectURI)
        data.Set("grant_type", "authorization_code")
        data.Set("code_verifier", codeVerifier)

        req, err := http.NewRequestWithContext(ctx, "POST", endpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to create token exchange request", "error", err, "endpoint", endpoint)
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to send token exchange request", "error", err, "endpoint", endpoint)
                return nil, err
        }</span>
        
        <span class="cov0" title="0">var body []byte
        var statusCode int
        err = httputils.WithAutoCleanup(resp, func(resp *http.Response) error </span><span class="cov0" title="0">{
                statusCode = resp.StatusCode
                responseBody, readErr := io.ReadAll(resp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        return readErr
                }</span>
                <span class="cov0" title="0">body = responseBody
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to read response body", "error", err, "endpoint", endpoint)
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if statusCode != 200 </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Token exchange failed", "status_code", statusCode, "response_body", string(body))

                // Check for specific PKCE errors
                if strings.Contains(string(body), "invalid_grant") &amp;&amp; strings.Contains(string(body), "code_verifier") </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("PKCE code verifier mismatch detected",
                                "possible_causes", []string{
                                        "Authorization code used with different code verifier",
                                        "Authorization code expired (10 minute limit)",
                                        "Authorization code already used",
                                },
                                "action_required", "Restart authentication flow")
                        return nil, fmt.Errorf("PKCE code verifier mismatch - please restart authentication flow")
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("token exchange failed: %s", string(body))</span>
        }
        <span class="cov0" title="0">var res struct {
                AccessToken  string `json:"access_token"`
                RefreshToken string `json:"refresh_token"`
                ExpiresIn    int64  `json:"expires_in"`
        }
        if err := json.Unmarshal(body, &amp;res); err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to decode token response JSON", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">logging.AuthLogger.Info("Successfully obtained access and refresh tokens", "expires_in_seconds", res.ExpiresIn)
        return &amp;TokenManager{
                AccessToken:  res.AccessToken,
                RefreshToken: res.RefreshToken,
                Expiry:       time.Now().Unix() + res.ExpiresIn,
        }, nil</span>
}

// StartLocalServer starts a local HTTP server to capture the auth code from the OAuth2 redirect.
// redirectPath: Path to listen for the callback (e.g., "/callback").
// codeCh: Channel to send the received code.
// state: Expected state value for CSRF protection.
// Returns the HTTP server pointer and an error, if any.
func StartLocalServer(redirectPath string, codeCh chan&lt;- string, state string) (*http.Server, error) <span class="cov8" title="1">{
        logging.AuthLogger.Info("Starting local HTTP server to receive auth code", "port", 8080, "redirect_path", redirectPath)
        mux := http.NewServeMux()
        mux.HandleFunc(redirectPath, func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Query().Get("state") != state </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid state", http.StatusBadRequest)
                        logging.AuthLogger.Info("Invalid state received in redirect.")
                        return
                }</span>
                <span class="cov0" title="0">code := r.URL.Query().Get("code")
                if code == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Missing code", http.StatusBadRequest)
                        logging.AuthLogger.Info("Missing code in redirect.")
                        return
                }</span>
                <span class="cov0" title="0">w.Write([]byte("Authentication successful. You may close this window."))
                logging.AuthLogger.Info("Received authorization code from redirect.")
                codeCh &lt;- code</span>
        })
        <span class="cov8" title="1">server := &amp;http.Server{Addr: ":8080", Handler: mux}
        go func() </span><span class="cov8" title="1">{
                _ = server.ListenAndServe()
        }</span>()
        <span class="cov8" title="1">return server, nil</span>
}

// SaveTokens saves tokens to a file (for demo; use secure storage in production).
// path: File path to save the tokens.
// Returns an error if saving fails.
func (tm *TokenManager) SaveTokens(path string) error <span class="cov8" title="1">{
        // Get absolute path for better debugging
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Debug("Could not resolve absolute path", "path", path, "error", err)
                absPath = unknownPath
        }</span>

        <span class="cov8" title="1">logging.AuthLogger.Debug("Saving authentication tokens to file",
                "path", path,
                "absolute_path", absPath,
                "access_token", maskSensitiveData(tm.AccessToken),
                "refresh_token", maskSensitiveData(tm.RefreshToken),
                "expires_at", time.Unix(tm.Expiry, 0).Format(time.RFC3339))

        f, err := os.Create(path)
        if err != nil </span><span class="cov8" title="1">{
                logging.AuthLogger.Error("Failed to create token file", "path", path, "absolute_path", absPath, "error", err)
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        if err := json.NewEncoder(f).Encode(tm); err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to encode tokens to file", "path", path, "absolute_path", absPath, "error", err)
                return err
        }</span>

        <span class="cov8" title="1">logging.AuthLogger.Debug("Tokens saved successfully", "path", path, "absolute_path", absPath)
        return nil</span>
}

// GetTokenPath returns the token file path, using TOKEN_FILE environment variable if set
func GetTokenPath(defaultPath string) string <span class="cov0" title="0">{
        if envPath := os.Getenv("TOKEN_FILE"); envPath != "" </span><span class="cov0" title="0">{
                logging.AuthLogger.Debug("Using TOKEN_FILE environment variable", "path", envPath)
                return envPath
        }</span>
        <span class="cov0" title="0">logging.AuthLogger.Debug("TOKEN_FILE environment variable not set, using default", "default_path", defaultPath)
        return defaultPath</span>
}

// LoadTokens loads tokens from a file.
// path: File path to load the tokens from.
// Returns a pointer to a TokenManager and an error, if any.
func LoadTokens(path string) (*TokenManager, error) <span class="cov8" title="1">{
        // Get absolute path for better debugging
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Debug("Could not resolve absolute path", "path", path, "error", err)
                absPath = unknownPath
        }</span>

        <span class="cov8" title="1">logging.AuthLogger.Debug("Loading tokens from file", "path", path, "absolute_path", absPath)

        fileInfo, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                logging.AuthLogger.Debug("No token file found", "path", path, "absolute_path", absPath, "error", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">logging.AuthLogger.Debug("Token file found:")
        logging.AuthLogger.Debug("Token file details", "path", path)
        logging.AuthLogger.Debug("Token file details", "absolute_path", absPath)
        logging.AuthLogger.Debug("Token file details", "size_bytes", fileInfo.Size())
        logging.AuthLogger.Debug("Token file details", "modified_time", fileInfo.ModTime())
        logging.AuthLogger.Debug("Token file details", "permissions", fileInfo.Mode().String())

        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to open token file", "path", path, "absolute_path", absPath, "error", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        tm := &amp;TokenManager{}
        if err := json.NewDecoder(f).Decode(tm); err != nil </span><span class="cov8" title="1">{
                logging.AuthLogger.Error("Failed to decode token file", "path", path, "absolute_path", absPath, "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">logging.AuthLogger.Debug("Tokens loaded successfully", "path", path, "absolute_path", absPath)
        logging.AuthLogger.Debug("Token details", "access_token", maskSensitiveData(tm.AccessToken))
        logging.AuthLogger.Debug("Token details", "refresh_token", maskSensitiveData(tm.RefreshToken))
        logging.AuthLogger.Debug("Token details", "expiry_timestamp", tm.Expiry, "expires_at", time.Unix(tm.Expiry, 0).Format(time.RFC3339))
        
        // Additional debugging to understand token format issues
        logging.AuthLogger.Debug("Token format validation", 
                "access_token_length", len(tm.AccessToken),
                "access_token_empty", tm.AccessToken == "",
                "access_token_has_dots", strings.Count(tm.AccessToken, "."),
                "access_token_starts_with", func() string </span><span class="cov8" title="1">{
                        if len(tm.AccessToken) &gt;= 10 </span><span class="cov8" title="1">{
                                return tm.AccessToken[:10]
                        }</span>
                        <span class="cov0" title="0">return tm.AccessToken</span>
                }())

        <span class="cov8" title="1">return tm, nil</span>
}

// RefreshToken refreshes the access token using the refresh token.
// ctx: Context for the HTTP request.
// refreshToken: The refresh token to use for refreshing the access token.
// Returns a pointer to a TokenManager and an error, if any.
func (c *OAuth2Config) RefreshToken(ctx context.Context, refreshToken string) (*TokenManager, error) <span class="cov0" title="0">{
        logging.AuthLogger.Info("Refreshing access token using refresh token...")
        endpoint := fmt.Sprintf("https://login.microsoftonline.com/%s/oauth2/v2.0/token", c.TenantIDOrCommon())
        data := url.Values{}
        data.Set("client_id", c.ClientID)
        data.Set("scope", "offline_access Notes.ReadWrite")
        data.Set("refresh_token", refreshToken)
        data.Set("redirect_uri", c.RedirectURI)
        data.Set("grant_type", "refresh_token")

        req, err := http.NewRequestWithContext(ctx, "POST", endpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Error creating refresh request", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Error sending refresh request", "error", err)
                return nil, err
        }</span>
        
        <span class="cov0" title="0">var body []byte
        var statusCode int
        err = httputils.WithAutoCleanup(resp, func(resp *http.Response) error </span><span class="cov0" title="0">{
                statusCode = resp.StatusCode
                responseBody, readErr := io.ReadAll(resp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        return readErr
                }</span>
                <span class="cov0" title="0">body = responseBody
                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to read refresh response body", "error", err)
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if statusCode != 200 </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Token refresh failed", "response_body", string(body))
                return nil, fmt.Errorf("token refresh failed: %s", string(body))
        }</span>
        <span class="cov0" title="0">var res struct {
                AccessToken  string `json:"access_token"`
                RefreshToken string `json:"refresh_token"`
                ExpiresIn    int64  `json:"expires_in"`
        }
        if err := json.Unmarshal(body, &amp;res); err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Error decoding refresh response", "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">logging.AuthLogger.Info("Token refresh successful.")
        return &amp;TokenManager{
                AccessToken:  res.AccessToken,
                RefreshToken: res.RefreshToken,
                Expiry:       time.Now().Unix() + res.ExpiresIn,
        }, nil</span>
}

// IsExpired returns true if the access token is expired.
// Returns true if the current time is after the token's expiry time minus a buffer.
func (tm *TokenManager) IsExpired() bool <span class="cov8" title="1">{
        now := time.Now().Unix()
        expiryWithBuffer := tm.Expiry - 60 // 60s buffer
        isExpired := now &gt; expiryWithBuffer

        logging.AuthLogger.Debug("Token expiry check:")
        logging.AuthLogger.Debug("Token expiry check - current time", "timestamp", now, "formatted", time.Unix(now, 0).Format(time.RFC3339))
        logging.AuthLogger.Debug("Token expiry check - token expiry", "timestamp", tm.Expiry, "formatted", time.Unix(tm.Expiry, 0).Format(time.RFC3339))
        logging.AuthLogger.Debug("Token expiry check - expiry with buffer", "timestamp", expiryWithBuffer, "formatted", time.Unix(expiryWithBuffer, 0).Format(time.RFC3339))
        logging.AuthLogger.Debug("Token expiry check - result", "is_expired", isExpired)

        return isExpired
}</span>

// SaveCodeVerifier saves the code verifier to a temporary file for the current auth session.
// This helps prevent PKCE mismatches if the auth flow is interrupted.
func SaveCodeVerifier(codeVerifier string) error <span class="cov0" title="0">{
        logging.AuthLogger.Info("Saving code verifier for PKCE session...")
        data := map[string]string{
                "code_verifier": codeVerifier,
                "timestamp":     fmt.Sprintf("%d", time.Now().Unix()),
        }
        f, err := os.Create("code_verifier.json")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        return json.NewEncoder(f).Encode(data)</span>
}

// LoadCodeVerifier loads the code verifier from the temporary file.
// Returns the code verifier and an error, if any.
func LoadCodeVerifier() (string, error) <span class="cov0" title="0">{
        logging.AuthLogger.Info("Loading code verifier for PKCE session...")
        f, err := os.Open("code_verifier.json")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        var data map[string]string
        if err := json.NewDecoder(f).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if the code verifier is not too old (within 10 minutes)
        <span class="cov0" title="0">if timestamp, exists := data["timestamp"]; exists </span><span class="cov0" title="0">{
                if ts, err := strconv.ParseInt(timestamp, 10, 64); err == nil </span><span class="cov0" title="0">{
                        if time.Now().Unix()-ts &gt; 600 </span><span class="cov0" title="0">{ // 10 minutes
                                logging.AuthLogger.Info("Code verifier is too old, will generate new one")
                                return "", fmt.Errorf("code verifier expired")
                        }</span>
                }
        }

        <span class="cov0" title="0">return data["code_verifier"], nil</span>
}

// CleanupCodeVerifier removes the temporary code verifier file.
func CleanupCodeVerifier() <span class="cov0" title="0">{
        logging.AuthLogger.Info("Cleaning up code verifier file...")
        os.Remove("code_verifier.json")
}</span>

// AuthenticateUser handles the complete authentication flow including token loading,
// PKCE authentication if needed, and token saving. This function encapsulates the
// authentication logic that was previously in main.go.
// oauthCfg: OAuth2 configuration for the application
// tokenPath: Path to save/load tokens
// Returns a TokenManager and an error, if any
func AuthenticateUser(oauthCfg *OAuth2Config, tokenPath string) (*TokenManager, error) <span class="cov0" title="0">{
        // Load or obtain authentication tokens
        tm, err := LoadTokens(tokenPath)
        if err != nil || tm == nil || tm.IsExpired() </span><span class="cov0" title="0">{
                logging.AuthLogger.Info("No valid token found or token expired. Starting PKCE flow...")

                // Try to load existing code verifier first (in case of interrupted auth flow)
                codeVerifier, err := LoadCodeVerifier()
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Info("No valid code verifier found, generating new one...")
                        // Set up PKCE (Proof Key for Code Exchange) for OAuth2
                        codeVerifier, err = GenerateCodeVerifier()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to generate code verifier: %v", err)
                        }</span>
                        // Save the code verifier for this auth session
                        <span class="cov0" title="0">if errSave := SaveCodeVerifier(codeVerifier); errSave != nil </span><span class="cov0" title="0">{
                                logging.AuthLogger.Warn("Failed to save code verifier", "error", errSave)
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.AuthLogger.Info("Using existing code verifier from previous auth session...")
                }</span>

                <span class="cov0" title="0">codeChallenge := CodeChallengeS256(codeVerifier)
                state := "mcp-onenote-state" // could randomize for extra security
                redirectPath := "/callback"
                codeCh := make(chan string)

                // Start local server to receive OAuth2 code
                server, err := StartLocalServer(redirectPath, codeCh, state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to start local server: %v", err)
                }</span>

                // Print auth URL for user to complete authentication
                <span class="cov0" title="0">authURL := oauthCfg.GetAuthURL(state, codeChallenge)
                logging.AuthLogger.Info("Please visit the following URL in your browser to authenticate", "auth_url", authURL)

                // Wait for code from local server
                code := &lt;-codeCh

                // Shutdown the HTTP server gracefully after receiving the code
                logging.AuthLogger.Info("OAuth callback received, shutting down local HTTP server...")
                if shutdownErr := server.Shutdown(context.Background()); shutdownErr != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to shutdown HTTP server gracefully", "error", shutdownErr)
                }</span> else<span class="cov0" title="0"> {
                        logging.AuthLogger.Info("Local HTTP server shut down successfully")
                }</span>

                // Exchange code for tokens
                <span class="cov0" title="0">tm, err = oauthCfg.ExchangeCode(context.Background(), code, codeVerifier)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to exchange code for tokens: %v", err)
                }</span>

                // Save tokens for future use
                <span class="cov0" title="0">if err := tm.SaveTokens(tokenPath); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to save tokens", "error", err)
                }</span>

                // Clean up the code verifier file after successful authentication
                <span class="cov0" title="0">CleanupCodeVerifier()
                logging.AuthLogger.Info("Authentication complete. Tokens saved.")</span>
        }

        <span class="cov0" title="0">return tm, nil</span>
}

// IsAuthError checks if an error is due to authentication issues.
// err: The error to check
// Returns true if the error is authentication-related
func IsAuthError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">errStr := err.Error()
        return strings.Contains(errStr, "401") ||
                strings.Contains(errStr, "403") ||
                strings.Contains(errStr, "unauthorized") ||
                strings.Contains(errStr, "forbidden") ||
                strings.Contains(errStr, "invalid_token") ||
                strings.Contains(errStr, "expired_token")</span>
}

// RefreshTokenAndRetry attempts to refresh the access token and retry the given operation.
// oauthCfg: OAuth2 configuration for token refresh
// tokenManager: Token manager for refresh operations
// tokenPath: Path to save refreshed tokens
// operation: Function to retry after token refresh
// onTokenRefresh: Optional callback function called when token is refreshed
// Returns an error if the operation fails
func RefreshTokenAndRetry(oauthCfg *OAuth2Config, tokenManager *TokenManager, tokenPath string, operation func() error, onTokenRefresh func(string)) error <span class="cov0" title="0">{
        logging.AuthLogger.Info("=== TOKEN REFRESH DEBUG START ===")

        if oauthCfg == nil || tokenManager == nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Info("ERROR: Token refresh not configured - OAuthConfig or TokenManager is nil")
                return fmt.Errorf("token refresh not configured")
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Debug("Token refresh debug - current token expiry", "expiry_timestamp", tokenManager.Expiry)
        logging.AuthLogger.Debug("Token refresh debug - current time", "current_timestamp", time.Now().Unix())
        logging.AuthLogger.Debug("Token refresh debug - expiry status", "is_expired", tokenManager.IsExpired())
        logging.AuthLogger.Debug("Token refresh debug - refresh token status", "refresh_token_available", tokenManager.RefreshToken != "")

        logging.AuthLogger.Info("Authentication error detected, attempting token refresh...")

        // Refresh the token
        logging.AuthLogger.Info("Calling OAuth2Config.RefreshToken...")
        newTokenManager, err := oauthCfg.RefreshToken(context.Background(), tokenManager.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to refresh token", "error", err)
                logging.AuthLogger.Info("=== TOKEN REFRESH DEBUG END (FAILED) ===")
                return fmt.Errorf("failed to refresh token: %v", err)
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Info("Token refresh successful!")
        logging.AuthLogger.Debug("Token refresh success - new expiry", "expiry_timestamp", newTokenManager.Expiry)
        logging.AuthLogger.Debug("Token refresh success - access token", "token_length", len(newTokenManager.AccessToken))
        logging.AuthLogger.Debug("Token refresh success - refresh token", "token_length", len(newTokenManager.RefreshToken))

        // Update the token manager
        logging.AuthLogger.Info("Updating token manager with new token...")
        tokenManager.AccessToken = newTokenManager.AccessToken
        tokenManager.RefreshToken = newTokenManager.RefreshToken
        tokenManager.Expiry = newTokenManager.Expiry

        // Call the token refresh callback if provided
        if onTokenRefresh != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Info("Calling token refresh callback...")
                onTokenRefresh(newTokenManager.AccessToken)
        }</span>

        // Save the new tokens
        <span class="cov0" title="0">if tokenPath != "" </span><span class="cov0" title="0">{
                // Get absolute path for better debugging
                absTokenPath, err := filepath.Abs(tokenPath)
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Debug("Could not get absolute path", "token_path", tokenPath, "error", err)
                        absTokenPath = "unknown"
                }</span>

                <span class="cov0" title="0">logging.AuthLogger.Debug("Saving refreshed tokens", "path", tokenPath, "absolute_path", absTokenPath)
                if err := newTokenManager.SaveTokens(tokenPath); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to save refreshed tokens", "path", tokenPath, "absolute_path", absTokenPath, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        logging.AuthLogger.Debug("Tokens saved successfully", "path", tokenPath, "absolute_path", absTokenPath)
                }</span>
        } else<span class="cov0" title="0"> {
                logging.AuthLogger.Info("No token path configured, skipping token save")
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Info("Token refreshed successfully, retrying operation...")
        logging.AuthLogger.Info("=== TOKEN REFRESH DEBUG END (SUCCESS) ===")

        // Retry the operation
        return operation()</span>
}

// MakeAuthenticatedRequest makes an HTTP request with authentication and handles token refresh if needed.
// req: The HTTP request to make
// accessToken: Current access token
// oauthCfg: OAuth2 configuration for token refresh
// tokenManager: Token manager for refresh operations
// tokenPath: Path to save refreshed tokens
// Returns the HTTP response and an error, if any
func MakeAuthenticatedRequest(req *http.Request, accessToken string, oauthCfg *OAuth2Config, tokenManager *TokenManager, tokenPath string) (*http.Response, error) <span class="cov0" title="0">{
        logging.AuthLogger.Info("Making authenticated request", "method", req.Method, "url", req.URL.String())

        // Store the original request body for potential retry after token refresh
        var bodyBytes []byte
        if req.Body != nil </span><span class="cov0" title="0">{
                var err error
                bodyBytes, err = io.ReadAll(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Error("Failed to read request body", "error", err)
                        return nil, fmt.Errorf("failed to read request body: %v", err)
                }</span>
                <span class="cov0" title="0">req.Body.Close()
                // Replace the consumed body with a fresh reader
                req.Body = io.NopCloser(strings.NewReader(string(bodyBytes)))
                logging.AuthLogger.Debug("Stored request body for potential retry", "body_size", len(bodyBytes))</span>
        }

        // Set the current access token
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)

        // Make the request
        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Request failed", "error", err)
                return resp, err
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Debug("Response received", "status_code", resp.StatusCode)

        // Check if we got an auth error
        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                logging.AuthLogger.Info("Authentication error detected, checking if token refresh is available", "status_code", resp.StatusCode)

                // Try to refresh token and retry
                if oauthCfg != nil &amp;&amp; tokenManager != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Info("Token refresh is available, attempting refresh...")

                        // Close the current response
                        resp.Body.Close()

                        // Create a new request with fresh body content
                        var newBody io.Reader
                        if len(bodyBytes) &gt; 0 </span><span class="cov0" title="0">{
                                newBody = strings.NewReader(string(bodyBytes))
                                logging.AuthLogger.Debug("Creating retry request with body", "body_size", len(bodyBytes))
                        }</span>

                        <span class="cov0" title="0">newReq, err := http.NewRequest(req.Method, req.URL.String(), newBody)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.AuthLogger.Error("Failed to create new request for retry", "error", err)
                                return nil, err
                        }</span>

                        // Copy headers (excluding Authorization which will be set with new token)
                        <span class="cov0" title="0">for key, values := range req.Header </span><span class="cov0" title="0">{
                                if key != "Authorization" </span><span class="cov0" title="0">{
                                        for _, value := range values </span><span class="cov0" title="0">{
                                                newReq.Header.Add(key, value)
                                        }</span>
                                }
                        }

                        // Refresh token and retry
                        <span class="cov0" title="0">err = RefreshTokenAndRetry(oauthCfg, tokenManager, tokenPath, func() error </span><span class="cov0" title="0">{
                                logging.AuthLogger.Info("Retrying request after token refresh", "method", newReq.Method, "url", newReq.URL.String())
                                newReq.Header.Set("Authorization", "Bearer "+tokenManager.AccessToken)
                                retryResp, retryErr := http.DefaultClient.Do(newReq)
                                if retryErr != nil </span><span class="cov0" title="0">{
                                        logging.AuthLogger.Error("Retry request failed", "error", retryErr)
                                        return retryErr
                                }</span>
                                <span class="cov0" title="0">logging.AuthLogger.Debug("Retry response received", "status_code", retryResp.StatusCode)
                                if retryResp.StatusCode == 401 || retryResp.StatusCode == 403 </span><span class="cov0" title="0">{
                                        logging.AuthLogger.Info("ERROR: Authentication still failed after token refresh")
                                        return fmt.Errorf("authentication failed even after token refresh")
                                }</span>
                                // Replace the response
                                <span class="cov0" title="0">resp = retryResp
                                logging.AuthLogger.Info("Request succeeded after token refresh!")
                                return nil</span>
                        }, nil) // No callback needed for direct HTTP requests

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                logging.AuthLogger.Error("Token refresh and retry failed", "error", err)
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.AuthLogger.Warn("Authentication error but token refresh not available",
                                "oauth_config_available", oauthCfg != nil,
                                "token_manager_available", tokenManager != nil)
                }</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

// MakeAuthenticatedRequestWithCallback makes an HTTP request with authentication and handles token refresh if needed.
// This version accepts a callback function that will be called when the token is refreshed.
// req: The HTTP request to make
// accessToken: Current access token
// oauthCfg: OAuth2 configuration for token refresh
// tokenManager: Token manager for refresh operations
// tokenPath: Path to save refreshed tokens
// onTokenRefresh: Callback function called when token is refreshed
// Returns the HTTP response and an error, if any
func MakeAuthenticatedRequestWithCallback(req *http.Request, accessToken string, oauthCfg *OAuth2Config, tokenManager *TokenManager, tokenPath string, onTokenRefresh func(string)) (*http.Response, error) <span class="cov0" title="0">{
        logging.AuthLogger.Info("Making authenticated request", "method", req.Method, "url", req.URL.String())

        // Store the original request body for potential retry after token refresh
        var bodyBytes []byte
        if req.Body != nil </span><span class="cov0" title="0">{
                var err error
                bodyBytes, err = io.ReadAll(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Error("Failed to read request body", "error", err)
                        return nil, fmt.Errorf("failed to read request body: %v", err)
                }</span>
                <span class="cov0" title="0">req.Body.Close()
                // Replace the consumed body with a fresh reader
                req.Body = io.NopCloser(strings.NewReader(string(bodyBytes)))
                logging.AuthLogger.Debug("Stored request body for potential retry", "body_size", len(bodyBytes))</span>
        }

        // Set the current access token
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)

        // Make the request
        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Request failed", "error", err)
                return resp, err
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Debug("Response received", "status_code", resp.StatusCode)

        // Check if we got an auth error
        if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                logging.AuthLogger.Info("Authentication error detected, checking if token refresh is available", "status_code", resp.StatusCode)

                // Try to refresh token and retry
                if oauthCfg != nil &amp;&amp; tokenManager != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Info("Token refresh is available, attempting refresh...")

                        // Close the current response
                        resp.Body.Close()

                        // Create a new request with fresh body content
                        var newBody io.Reader
                        if len(bodyBytes) &gt; 0 </span><span class="cov0" title="0">{
                                newBody = strings.NewReader(string(bodyBytes))
                                logging.AuthLogger.Debug("Creating retry request with body", "body_size", len(bodyBytes))
                        }</span>

                        <span class="cov0" title="0">newReq, err := http.NewRequest(req.Method, req.URL.String(), newBody)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.AuthLogger.Error("Failed to create new request for retry", "error", err)
                                return nil, err
                        }</span>

                        // Copy headers (excluding Authorization which will be set with new token)
                        <span class="cov0" title="0">for key, values := range req.Header </span><span class="cov0" title="0">{
                                if key != "Authorization" </span><span class="cov0" title="0">{
                                        for _, value := range values </span><span class="cov0" title="0">{
                                                newReq.Header.Add(key, value)
                                        }</span>
                                }
                        }

                        // Refresh token and retry
                        <span class="cov0" title="0">err = RefreshTokenAndRetry(oauthCfg, tokenManager, tokenPath, func() error </span><span class="cov0" title="0">{
                                logging.AuthLogger.Info("Retrying request after token refresh", "method", newReq.Method, "url", newReq.URL.String())
                                newReq.Header.Set("Authorization", "Bearer "+tokenManager.AccessToken)
                                retryResp, retryErr := http.DefaultClient.Do(newReq)
                                if retryErr != nil </span><span class="cov0" title="0">{
                                        logging.AuthLogger.Error("Retry request failed", "error", retryErr)
                                        return retryErr
                                }</span>
                                <span class="cov0" title="0">logging.AuthLogger.Debug("Retry response received", "status_code", retryResp.StatusCode)
                                if retryResp.StatusCode == 401 || retryResp.StatusCode == 403 </span><span class="cov0" title="0">{
                                        logging.AuthLogger.Info("ERROR: Authentication still failed after token refresh")
                                        return fmt.Errorf("authentication failed even after token refresh")
                                }</span>
                                // Replace the response
                                <span class="cov0" title="0">resp = retryResp
                                logging.AuthLogger.Info("Request succeeded after token refresh!")
                                return nil</span>
                        }, onTokenRefresh)

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                logging.AuthLogger.Error("Token refresh and retry failed", "error", err)
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.AuthLogger.Warn("Authentication error but token refresh not available",
                                "oauth_config_available", oauthCfg != nil,
                                "token_manager_available", tokenManager != nil)
                }</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// manager.go - Authentication state manager for MCP tools.
//
// This file provides an authentication manager that allows MCP tools to check,
// refresh, and manage authentication state independently of the main server startup.
// It maintains a global view of authentication status while ensuring thread safety.
//
// Key Features:
// - Thread-safe authentication state management
// - Authentication status reporting without exposing tokens
// - Manual token refresh capabilities
// - Re-authentication flow initiation
// - Authentication clearing (logout)
//
// Security Features:
// - Never exposes actual access/refresh tokens in responses
// - Secure state parameter generation for auth sessions
// - Timeout handling for auth sessions
// - Safe concurrent access to auth state

package auth

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// AuthStatus represents the current authentication state without exposing sensitive tokens
type AuthStatus struct {
        Authenticated         bool       `json:"authenticated"`
        TokenExpiry           *time.Time `json:"tokenExpiry,omitempty"`
        TokenExpiresIn        string     `json:"tokenExpiresIn,omitempty"`
        RefreshTokenAvailable bool       `json:"refreshTokenAvailable"`
        LastRefresh           *time.Time `json:"lastRefresh,omitempty"`
        AuthMethod            string     `json:"authMethod"`
        Message               string     `json:"message,omitempty"`
}

// AuthSession represents an active authentication session
type AuthSession struct {
        State           string    `json:"state"`
        CodeVerifier    string    `json:"codeVerifier"`
        CodeChallenge   string    `json:"codeChallenge"`
        AuthURL         string    `json:"authUrl"`
        CreatedAt       time.Time `json:"createdAt"`
        TimeoutMinutes  int       `json:"timeoutMinutes"`
        LocalServerPort int       `json:"localServerPort"`
}

// AuthManager manages authentication state and operations for MCP tools
type AuthManager struct {
        mu             sync.RWMutex
        oauthConfig    *OAuth2Config
        tokenManager   *TokenManager
        tokenPath      string
        activeSession  *AuthSession
        lastRefresh    *time.Time
        onTokenRefresh func(string) // Callback for when token is refreshed
}

// NewAuthManager creates a new authentication manager
func NewAuthManager(oauthConfig *OAuth2Config, tokenManager *TokenManager, tokenPath string) *AuthManager <span class="cov8" title="1">{
        return &amp;AuthManager{
                oauthConfig:  oauthConfig,
                tokenManager: tokenManager,
                tokenPath:    tokenPath,
        }
}</span>

// SetTokenRefreshCallback sets a callback function that will be called when tokens are refreshed
func (am *AuthManager) SetTokenRefreshCallback(callback func(string)) <span class="cov8" title="1">{
        am.mu.Lock()
        defer am.mu.Unlock()
        am.onTokenRefresh = callback
}</span>

// GetAuthStatus returns the current authentication status without exposing sensitive data
func (am *AuthManager) GetAuthStatus() *AuthStatus <span class="cov8" title="1">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        status := &amp;AuthStatus{
                AuthMethod: "OAuth2_PKCE",
        }

        if am.tokenManager == nil || am.tokenManager.AccessToken == "" </span><span class="cov8" title="1">{
                status.Authenticated = false
                status.Message = "No authentication tokens found"
                return status
        }</span>

        <span class="cov8" title="1">status.Authenticated = true
        status.RefreshTokenAvailable = am.tokenManager.RefreshToken != ""

        if am.tokenManager.Expiry &gt; 0 </span><span class="cov0" title="0">{
                expiry := time.Unix(am.tokenManager.Expiry, 0)
                status.TokenExpiry = &amp;expiry

                timeUntilExpiry := time.Until(expiry)
                if timeUntilExpiry &gt; 0 </span><span class="cov0" title="0">{
                        status.TokenExpiresIn = formatDuration(timeUntilExpiry)
                }</span> else<span class="cov0" title="0"> {
                        status.TokenExpiresIn = "expired"
                }</span>
        }

        <span class="cov8" title="1">if am.lastRefresh != nil </span><span class="cov8" title="1">{
                status.LastRefresh = am.lastRefresh
        }</span>

        // Check if token is expired
        <span class="cov8" title="1">if am.tokenManager.IsExpired() </span><span class="cov8" title="1">{
                status.Message = "Token is expired but can be refreshed"
        }</span> else<span class="cov0" title="0"> {
                status.Message = "Authentication is valid"
        }</span>

        <span class="cov8" title="1">return status</span>
}

// RefreshToken manually triggers a token refresh
func (am *AuthManager) RefreshToken() (*AuthStatus, error) <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()

        if am.oauthConfig == nil || am.tokenManager == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("authentication not configured")
        }</span>

        <span class="cov0" title="0">if am.tokenManager.RefreshToken == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no refresh token available")
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Info("Manually refreshing token via MCP tool")

        // Refresh the token
        newTokenManager, err := am.oauthConfig.RefreshToken(context.Background(), am.tokenManager.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Token refresh failed", "error", err)
                return nil, fmt.Errorf("failed to refresh token: %v", err)
        }</span>

        // Update the token manager
        <span class="cov0" title="0">am.tokenManager.AccessToken = newTokenManager.AccessToken
        am.tokenManager.RefreshToken = newTokenManager.RefreshToken
        am.tokenManager.Expiry = newTokenManager.Expiry

        // Save the new tokens
        if am.tokenPath != "" </span><span class="cov0" title="0">{
                if err := newTokenManager.SaveTokens(am.tokenPath); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to save refreshed tokens", "error", err)
                }</span>
        }

        <span class="cov0" title="0">now := time.Now()
        am.lastRefresh = &amp;now

        // Call the token refresh callback if set
        if am.onTokenRefresh != nil </span><span class="cov0" title="0">{
                am.onTokenRefresh(newTokenManager.AccessToken)
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Info("Token refresh successful via MCP tool")

        // Return updated status
        return am.GetAuthStatus(), nil</span>
}

// InitiateAuth starts a new authentication flow with a local HTTP server
func (am *AuthManager) InitiateAuth() (*AuthSession, error) <span class="cov8" title="1">{
        am.mu.Lock()
        defer am.mu.Unlock()

        if am.oauthConfig == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OAuth configuration not available")
        }</span>

        <span class="cov8" title="1">logging.AuthLogger.Info("Initiating new authentication flow via MCP tool")

        // Generate PKCE parameters
        codeVerifier, err := GenerateCodeVerifier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate code verifier: %v", err)
        }</span>

        <span class="cov8" title="1">codeChallenge := CodeChallengeS256(codeVerifier)

        // Generate secure state parameter
        state, err := generateSecureState()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate state parameter: %v", err)
        }</span>

        // Create auth URL
        <span class="cov8" title="1">authURL := am.oauthConfig.GetAuthURL(state, codeChallenge)

        // Create session
        session := &amp;AuthSession{
                State:           state,
                CodeVerifier:    codeVerifier,
                CodeChallenge:   codeChallenge,
                AuthURL:         authURL,
                CreatedAt:       time.Now(),
                TimeoutMinutes:  10, // 10 minute timeout
                LocalServerPort: 8080,
        }

        am.activeSession = session

        // Start the OAuth callback server in the background
        go am.startOAuthCallbackServer(session)

        logging.AuthLogger.Debug("Authentication session created", "state", state)

        return session, nil</span>
}

// startOAuthCallbackServer starts a temporary HTTP server to handle OAuth callback
func (am *AuthManager) startOAuthCallbackServer(session *AuthSession) <span class="cov8" title="1">{
        codeCh := make(chan string, 1)

        // Start local server to receive OAuth2 code
        server, err := StartLocalServer("/callback", codeCh, session.State)
        if err != nil </span><span class="cov0" title="0">{
                logging.AuthLogger.Error("Failed to start OAuth callback server", "error", err)
                return
        }</span>

        // Set up timeout
        <span class="cov8" title="1">timeout := time.Duration(session.TimeoutMinutes) * time.Minute
        timeoutTimer := time.NewTimer(timeout)

        select </span>{
        case code := &lt;-codeCh:<span class="cov0" title="0">
                // We received the auth code
                timeoutTimer.Stop()

                // Shutdown the server gracefully
                logging.AuthLogger.Info("OAuth callback received, shutting down local HTTP server")
                if err := server.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to shutdown HTTP server gracefully", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        logging.AuthLogger.Debug("Local HTTP server shut down successfully")
                }</span>

                // Complete the authentication
                <span class="cov0" title="0">if err := am.CompleteAuth(code); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Error("Failed to complete authentication", "error", err)
                }</span>

        case &lt;-timeoutTimer.C:<span class="cov0" title="0">
                // Timeout occurred
                logging.AuthLogger.Info("OAuth session timed out", "timeout_minutes", session.TimeoutMinutes)

                // Shutdown the server
                if err := server.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to shutdown HTTP server after timeout", "error", err)
                }</span>

                // Clear the active session
                <span class="cov0" title="0">am.mu.Lock()
                am.activeSession = nil
                am.mu.Unlock()</span>
        }
}

// CompleteAuth completes an authentication flow with the received code
func (am *AuthManager) CompleteAuth(code string) error <span class="cov0" title="0">{
        am.mu.Lock()
        defer am.mu.Unlock()

        if am.activeSession == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no active authentication session")
        }</span>

        // Check if session has expired
        <span class="cov0" title="0">if time.Since(am.activeSession.CreatedAt) &gt; time.Duration(am.activeSession.TimeoutMinutes)*time.Minute </span><span class="cov0" title="0">{
                am.activeSession = nil
                return fmt.Errorf("authentication session has expired")
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Info("Completing authentication with received code")

        // Exchange code for tokens
        tokenManager, err := am.oauthConfig.ExchangeCode(context.Background(), code, am.activeSession.CodeVerifier)
        if err != nil </span><span class="cov0" title="0">{
                am.activeSession = nil
                return fmt.Errorf("failed to exchange code for tokens: %v", err)
        }</span>

        // Update token manager
        <span class="cov0" title="0">am.tokenManager.AccessToken = tokenManager.AccessToken
        am.tokenManager.RefreshToken = tokenManager.RefreshToken
        am.tokenManager.Expiry = tokenManager.Expiry

        // Save tokens
        if am.tokenPath != "" </span><span class="cov0" title="0">{
                if err := tokenManager.SaveTokens(am.tokenPath); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to save tokens", "error", err)
                }</span>
        }

        <span class="cov0" title="0">now := time.Now()
        am.lastRefresh = &amp;now
        am.activeSession = nil

        // Call the token refresh callback if set
        if am.onTokenRefresh != nil </span><span class="cov0" title="0">{
                am.onTokenRefresh(tokenManager.AccessToken)
        }</span>

        <span class="cov0" title="0">logging.AuthLogger.Info("Authentication completed successfully via MCP tool")

        return nil</span>
}

// ClearAuth clears stored authentication tokens (logout)
func (am *AuthManager) ClearAuth() error <span class="cov8" title="1">{
        am.mu.Lock()
        defer am.mu.Unlock()

        logging.AuthLogger.Info("Clearing authentication tokens via MCP tool")

        // Clear in-memory tokens
        if am.tokenManager != nil </span><span class="cov8" title="1">{
                am.tokenManager.AccessToken = ""
                am.tokenManager.RefreshToken = ""
                am.tokenManager.Expiry = 0
        }</span>

        <span class="cov8" title="1">am.lastRefresh = nil
        am.activeSession = nil

        // Remove token file
        if am.tokenPath != "" </span><span class="cov8" title="1">{
                // Create empty token manager and save it (effectively clearing the file)
                emptyTokenManager := &amp;TokenManager{}
                if err := emptyTokenManager.SaveTokens(am.tokenPath); err != nil </span><span class="cov0" title="0">{
                        logging.AuthLogger.Warn("Failed to clear token file", "error", err)
                }</span>
        }

        // Call the token refresh callback with empty token to clear Graph client
        <span class="cov8" title="1">if am.onTokenRefresh != nil </span><span class="cov0" title="0">{
                am.onTokenRefresh("")
        }</span>

        <span class="cov8" title="1">logging.AuthLogger.Info("Authentication cleared successfully")

        return nil</span>
}

// UpdateTokenManager updates the internal token manager (called by external refresh operations)
func (am *AuthManager) UpdateTokenManager(tokenManager *TokenManager) <span class="cov8" title="1">{
        am.mu.Lock()
        defer am.mu.Unlock()

        am.tokenManager = tokenManager
        now := time.Now()
        am.lastRefresh = &amp;now
}</span>

// GetActiveSession returns the current active authentication session, if any
func (am *AuthManager) GetActiveSession() *AuthSession <span class="cov0" title="0">{
        am.mu.RLock()
        defer am.mu.RUnlock()

        return am.activeSession
}</span>

// generateSecureState generates a cryptographically secure state parameter
func generateSecureState() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(bytes), nil</span>
}

// formatDuration formats a duration in a human-readable format
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d seconds", int(d.Seconds()))
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d minutes", int(d.Minutes()))
        }</span> else<span class="cov0" title="0"> if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                hours := int(d.Hours())
                minutes := int(d.Minutes()) % 60
                return fmt.Sprintf("%d hours %d minutes", hours, minutes)
        }</span> else<span class="cov0" title="0"> {
                days := int(d.Hours()) / 24
                hours := int(d.Hours()) % 24
                return fmt.Sprintf("%d days %d hours", days, hours)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// middleware.go - HTTP authentication middleware for MCP server.
//
// This file provides HTTP authentication middleware for securing the OneNote MCP server
// when running in HTTP/SSE transport modes. The middleware validates Bearer tokens
// in the Authorization header against a configured token value.
//
// Key Features:
// - Simple bearer token validation using string comparison
// - Configurable authentication bypass for health check endpoints
// - Comprehensive logging of authentication attempts
// - Standards-compliant HTTP responses for authentication failures
// - No external dependencies or complex crypto operations
//
// Security Considerations:
// - Bearer tokens should be transmitted over HTTPS only in production
// - Tokens should be sufficiently long and random for security
// - Failed authentication attempts are logged for security monitoring
// - Authentication is only applied to HTTP/SSE modes, not stdio mode
//
// Usage:
//   middleware := auth.BearerTokenMiddleware("your-secret-token")
//   handler := middleware(httpHandler)
//
// HTTP Client Usage:
//   Authorization: Bearer your-secret-token
//
// For detailed configuration options, see internal/config/config.go

package auth

import (
        "net/http"
        "strings"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// BearerTokenMiddleware creates HTTP middleware that validates Bearer tokens
// against the provided expectedToken. Returns 401 Unauthorized for invalid
// or missing tokens.
//
// The middleware:
// - Extracts the Authorization header from incoming requests
// - Validates the Bearer token format and value
// - Allows requests with valid tokens to proceed
// - Returns 401 for missing, malformed, or invalid tokens
// - Logs authentication attempts for security monitoring
func BearerTokenMiddleware(expectedToken string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        logger := logging.AuthLogger

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Skip authentication for health check endpoints if needed
                        if r.URL.Path == "/health" || r.URL.Path == "/ping" </span><span class="cov0" title="0">{
                                logger.Debug("Skipping authentication for health check endpoint", "path", r.URL.Path)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Extract Authorization header
                        <span class="cov0" title="0">auth := r.Header.Get("Authorization")
                        if auth == "" </span><span class="cov0" title="0">{
                                logger.Warn("Authentication failed: missing Authorization header",
                                        "remote_addr", r.RemoteAddr,
                                        "user_agent", r.Header.Get("User-Agent"),
                                        "path", r.URL.Path,
                                        "method", r.Method)
                                w.Header().Set("WWW-Authenticate", "Bearer")
                                http.Error(w, "Authorization header required", http.StatusUnauthorized)
                                return
                        }</span>

                        // Extract token - handle both "Bearer token" and raw "token" formats
                        <span class="cov0" title="0">var token string
                        if strings.HasPrefix(auth, "Bearer ") </span><span class="cov0" title="0">{
                                // Standard Bearer token format
                                token = strings.TrimPrefix(auth, "Bearer ")
                                logger.Debug("Received standard Bearer token format")
                        }</span> else<span class="cov0" title="0"> {
                                // Raw token format (for compatibility with some MCP clients)
                                token = auth
                                logger.Debug("Received raw token format (no Bearer prefix)")
                        }</span>

                        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                                logger.Warn("Authentication failed: empty token",
                                        "remote_addr", r.RemoteAddr,
                                        "user_agent", r.Header.Get("User-Agent"),
                                        "path", r.URL.Path,
                                        "method", r.Method)
                                w.Header().Set("WWW-Authenticate", "Bearer")
                                http.Error(w, "Token cannot be empty", http.StatusUnauthorized)
                                return
                        }</span>

                        // Validate token against expected value
                        <span class="cov0" title="0">if token != expectedToken </span><span class="cov0" title="0">{
                                logger.Warn("Authentication failed: invalid Bearer token",
                                        "remote_addr", r.RemoteAddr,
                                        "user_agent", r.Header.Get("User-Agent"),
                                        "path", r.URL.Path,
                                        "method", r.Method,
                                        "token_length", len(token),
                                        "expected_length", len(expectedToken))
                                w.Header().Set("WWW-Authenticate", "Bearer")
                                http.Error(w, "Invalid token", http.StatusUnauthorized)
                                return
                        }</span>

                        // Authentication successful
                        <span class="cov0" title="0">logger.Debug("Authentication successful",
                                "remote_addr", r.RemoteAddr,
                                "user_agent", r.Header.Get("User-Agent"),
                                "path", r.URL.Path,
                                "method", r.Method,
                                "token_length", len(token))

                        // Proceed to the next handler
                        next.ServeHTTP(w, r)</span>
                })
        }
}

// RequestLoggingMiddleware creates HTTP middleware that logs request details
// including method, path, remote address, and user agent. This is useful
// for debugging HTTP/SSE transport issues and monitoring server usage.
//
// The middleware logs:
// - HTTP method (GET, POST, etc.)
// - Request path and query parameters
// - Remote client address
// - User-Agent header
// - Response status code (after request completion)
func RequestLoggingMiddleware() func(http.Handler) http.Handler <span class="cov0" title="0">{
        logger := logging.MainLogger

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Log incoming request
                        logger.Info("HTTP request received",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "query", r.URL.RawQuery,
                                "remote_addr", r.RemoteAddr,
                                "user_agent", r.Header.Get("User-Agent"),
                                "content_length", r.ContentLength,
                                "host", r.Host)

                        // Create a response writer wrapper to capture status code
                        wrapped := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                        // Call the next handler
                        next.ServeHTTP(wrapped, r)

                        // Log response with additional context for errors
                        if wrapped.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                                logger.Warn("HTTP request completed with error",
                                        "method", r.Method,
                                        "path", r.URL.Path,
                                        "query", r.URL.RawQuery,
                                        "status_code", wrapped.statusCode,
                                        "remote_addr", r.RemoteAddr,
                                        "user_agent", r.Header.Get("User-Agent"))
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info("HTTP request completed",
                                        "method", r.Method,
                                        "path", r.URL.Path,
                                        "status_code", wrapped.statusCode,
                                        "remote_addr", r.RemoteAddr)
                        }</span>
                })
        }
}

// responseWriter wraps http.ResponseWriter to capture the status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

// WriteHeader captures the status code and calls the underlying WriteHeader
func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Write calls the underlying Write method
func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return rw.ResponseWriter.Write(b)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package authorization

import (
        "context"
)

// QuickNoteConfigAdapter adapts Config and QuickNoteConfig to the QuickNoteConfig interface
type QuickNoteConfigAdapter struct {
        QuickNote       QuickNoteConfigProvider
        DefaultNotebook string
}

// QuickNoteConfigProvider defines the interface for getting quicknote configuration
type QuickNoteConfigProvider interface {
        GetNotebookName() string
        GetPageName() string
}

// NewQuickNoteConfigAdapter creates a new adapter
func NewQuickNoteConfigAdapter(quickNote QuickNoteConfigProvider, defaultNotebook string) *QuickNoteConfigAdapter <span class="cov0" title="0">{
        return &amp;QuickNoteConfigAdapter{
                QuickNote:       quickNote,
                DefaultNotebook: defaultNotebook,
        }
}</span>

// GetNotebookName returns the quicknote-specific notebook name
func (qca *QuickNoteConfigAdapter) GetNotebookName() string <span class="cov0" title="0">{
        if qca.QuickNote != nil </span><span class="cov0" title="0">{
                return qca.QuickNote.GetNotebookName()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetDefaultNotebook returns the default notebook name as fallback
func (qca *QuickNoteConfigAdapter) GetDefaultNotebook() string <span class="cov0" title="0">{
        return qca.DefaultNotebook
}</span>

// GetPageName returns the target page name
func (qca *QuickNoteConfigAdapter) GetPageName() string <span class="cov0" title="0">{
        if qca.QuickNote != nil </span><span class="cov0" title="0">{
                return qca.QuickNote.GetPageName()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// NotebookCacheAdapter adapts the main NotebookCache to the authorization interface
type NotebookCacheAdapter struct {
        Cache MainNotebookCache
}

// MainNotebookCache defines the interface for the main notebook cache
type MainNotebookCache interface {
        GetNotebook() (map[string]interface{}, bool)
        GetDisplayName() (string, bool)
        GetNotebookID() (string, bool)
        // Add method to get section name if available
        // This might need to be implemented in the main cache
}

// NewNotebookCacheAdapter creates a new cache adapter
func NewNotebookCacheAdapter(cache MainNotebookCache) *NotebookCacheAdapter <span class="cov0" title="0">{
        return &amp;NotebookCacheAdapter{
                Cache: cache,
        }
}</span>

// GetNotebook returns the current notebook
func (nca *NotebookCacheAdapter) GetNotebook() (map[string]interface{}, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                return nca.Cache.GetNotebook()
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

// GetDisplayName returns the notebook display name
func (nca *NotebookCacheAdapter) GetDisplayName() (string, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                return nca.Cache.GetDisplayName()
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

// GetNotebookID returns the notebook ID
func (nca *NotebookCacheAdapter) GetNotebookID() (string, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                return nca.Cache.GetNotebookID()
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

// GetSectionName returns the section name for a given section ID
func (nca *NotebookCacheAdapter) GetSectionName(sectionID string) (string, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                // Try to call GetSectionName if the cache supports it
                // We need to check if the cache has this method using type assertion
                if cacheWithSectionName, ok := nca.Cache.(interface {
                        GetSectionName(string) (string, bool)
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithSectionName.GetSectionName(sectionID)
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// GetSectionNameWithProgress returns the section name with progress notification support
func (nca *NotebookCacheAdapter) GetSectionNameWithProgress(ctx context.Context, sectionID string, mcpServer interface{}, progressToken string, graphClient interface{}) (string, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                // Try to call GetSectionNameWithProgress if the cache supports it
                // We need to check if the cache has this method using type assertion
                if cacheWithProgressMethod, ok := nca.Cache.(interface {
                        GetSectionNameWithProgress(context.Context, string, interface{}, string, interface{}) (string, bool)
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithProgressMethod.GetSectionNameWithProgress(ctx, sectionID, mcpServer, progressToken, graphClient)
                }</span>
                
                // Fallback to regular GetSectionName if progress method is not available
                <span class="cov0" title="0">if cacheWithSectionName, ok := nca.Cache.(interface {
                        GetSectionName(string) (string, bool)
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithSectionName.GetSectionName(sectionID)
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// GetPageName returns the page name for a given page ID
func (nca *NotebookCacheAdapter) GetPageName(pageID string) (string, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                // Try to call GetPageName if the cache supports it
                // We need to check if the cache has this method using type assertion
                if cacheWithPageName, ok := nca.Cache.(interface {
                        GetPageName(string) (string, bool)
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithPageName.GetPageName(pageID)
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// GetPageNameWithProgress returns the page name with progress notification support
func (nca *NotebookCacheAdapter) GetPageNameWithProgress(ctx context.Context, pageID string, mcpServer interface{}, progressToken string, graphClient interface{}) (string, bool) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                // Try to call GetPageNameWithProgress if the cache supports it
                // We need to check if the cache has this method using type assertion
                if cacheWithProgressMethod, ok := nca.Cache.(interface {
                        GetPageNameWithProgress(context.Context, string, interface{}, string, interface{}) (string, bool)
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithProgressMethod.GetPageNameWithProgress(ctx, pageID, mcpServer, progressToken, graphClient)
                }</span>
                
                // Fallback to regular GetPageName if progress method is not available
                <span class="cov0" title="0">if cacheWithPageName, ok := nca.Cache.(interface {
                        GetPageName(string) (string, bool)
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithPageName.GetPageName(pageID)
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// GetAPIReferences returns the API references for fallback resolution
func (nca *NotebookCacheAdapter) GetAPIReferences() (interface{}, interface{}) <span class="cov0" title="0">{
        if nca.Cache != nil </span><span class="cov0" title="0">{
                // Try to call GetAPIReferences if the cache supports it
                // We need to check if the cache has this method using type assertion
                if cacheWithAPIRefs, ok := nca.Cache.(interface {
                        GetAPIReferences() (interface{}, interface{})
                }); ok </span><span class="cov0" title="0">{
                        return cacheWithAPIRefs.GetAPIReferences()
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package authorization

import (
        "context"
        "fmt"
        "strings"

        "github.com/mark3labs/mcp-go/mcp"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// PermissionLevel defines the level of access allowed
type PermissionLevel string

const (
        PermissionNone  PermissionLevel = "none"  // Block all access
        PermissionRead  PermissionLevel = "read"  // Allow read-only operations
        PermissionWrite PermissionLevel = "write" // Allow read + write operations
        PermissionFull  PermissionLevel = "full"  // Allow all operations (same as write for most tools)
)


// ToolOperation represents whether a tool performs read or write operations
type ToolOperation string

const (
        OperationRead  ToolOperation = "read"
        OperationWrite ToolOperation = "write"
)

// AuthorizationConfig represents the simplified notebook-scoped authorization configuration
type AuthorizationConfig struct {
        Enabled                     bool                          `json:"enabled"`
        DefaultNotebookPermissions  PermissionLevel               `json:"default_notebook_permissions"`  // Default for any notebook
        NotebookPermissions         map[string]PermissionLevel    `json:"notebook_permissions"`          // Specific notebook permissions (exact match only)
        
        // Current selected notebook for operation scoping
        currentNotebook     string          `json:"-"`
        currentNotebookPerm PermissionLevel `json:"-"`
}


// ResourceContext contains information about the resource being accessed (simplified)
type ResourceContext struct {
        NotebookName string
        Operation    ToolOperation
}

// String returns a human-readable representation of the resource context
func (rc ResourceContext) String() string <span class="cov8" title="1">{
        parts := []string{}
        if rc.NotebookName != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("notebook=%s", rc.NotebookName))
        }</span>
        <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("operation=%s", rc.Operation))
        return strings.Join(parts, ", ")</span>
}

// ToolRegistry maps tool names to their categories and operations
// AuthToolNames defines which tools are always allowed (authentication tools + discovery tools)
var AuthToolNames = map[string]bool{
        "getAuthStatus":  true,
        "refreshToken":   true,
        "initiateAuth":   true,
        "clearAuth":      true,
        "listNotebooks":  true, // Always allow notebook discovery (results are filtered)
        "selectNotebook": true, // Always allow notebook selection (but selection itself is validated)
}

// NewAuthorizationConfig creates a new simplified authorization configuration
func NewAuthorizationConfig() *AuthorizationConfig <span class="cov8" title="1">{
        return &amp;AuthorizationConfig{
                Enabled:                     false,
                DefaultNotebookPermissions:  PermissionRead,
                NotebookPermissions:         make(map[string]PermissionLevel),
                currentNotebook:             "",
                currentNotebookPerm:         PermissionNone,
        }
}</span>

// ValidateConfig validates the authorization configuration (no pattern compilation needed)
func (ac *AuthorizationConfig) ValidateConfig() error <span class="cov8" title="1">{
        logging.AuthorizationLogger.Debug("Authorization configuration validated",
                "enabled", ac.Enabled,
                "notebook_permissions_count", len(ac.NotebookPermissions),
                "default_permissions", ac.DefaultNotebookPermissions)
        
        return nil
}</span>


// SetCurrentNotebook sets the currently selected notebook and validates permission
func (ac *AuthorizationConfig) SetCurrentNotebook(notebookName string) error <span class="cov8" title="1">{
        if !ac.Enabled </span><span class="cov8" title="1">{
                ac.currentNotebook = notebookName
                ac.currentNotebookPerm = PermissionWrite // Allow everything when disabled
                logging.AuthorizationLogger.Debug("Authorization disabled, allowing notebook selection", "notebook", notebookName)
                return nil
        }</span>
        
        <span class="cov8" title="1">permission := ac.GetNotebookPermission(notebookName)
        
        if permission == PermissionNone </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Info("Notebook selection denied",
                        "notebook", notebookName,
                        "permission", permission)
                return fmt.Errorf("access denied: cannot select notebook '%s' - permission is '%s'", notebookName, permission)
        }</span>
        
        <span class="cov8" title="1">ac.currentNotebook = notebookName
        ac.currentNotebookPerm = permission
        logging.AuthorizationLogger.Debug("Notebook selected",
                "notebook", notebookName,
                "permission", permission)
        return nil</span>
}

// GetCurrentNotebook returns the currently selected notebook name
func (ac *AuthorizationConfig) GetCurrentNotebook() string <span class="cov8" title="1">{
        return ac.currentNotebook
}</span>

// IsAuthorized checks if a tool call is authorized based on the simplified notebook-scoped configuration
func (ac *AuthorizationConfig) IsAuthorized(ctx context.Context, toolName string, req mcp.CallToolRequest, resourceContext ResourceContext) error <span class="cov8" title="1">{
        if !ac.Enabled </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Debug("Authorization disabled, allowing all operations", "tool", toolName)
                return nil
        }</span>
        
        <span class="cov8" title="1">logging.AuthorizationLogger.Debug("Checking authorization", 
                "tool", toolName,
                "resource_context", resourceContext.String(),
                "current_notebook", ac.currentNotebook)
        
        // 1. Auth tools are always allowed
        if AuthToolNames[toolName] </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Debug("Auth tool allowed", "tool", toolName)
                return nil
        }</span>
        
        // 2. For non-auth tools, ensure we have a selected notebook with permission
        <span class="cov8" title="1">if ac.currentNotebook == "" </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Info("No notebook selected for non-auth tool",
                        "tool", toolName)
                return fmt.Errorf("access denied: no notebook selected - use selectNotebook tool first")
        }</span>
        
        <span class="cov8" title="1">if ac.currentNotebookPerm == PermissionNone </span><span class="cov0" title="0">{
                logging.AuthorizationLogger.Info("Current notebook has no permission",
                        "tool", toolName,
                        "notebook", ac.currentNotebook,
                        "permission", ac.currentNotebookPerm)
                return fmt.Errorf("access denied: current notebook '%s' has no permission", ac.currentNotebook)
        }</span>
        
        // 3. SECURITY: All operations must be scoped to current notebook (if notebook context provided)
        <span class="cov8" title="1">if resourceContext.NotebookName != "" &amp;&amp; resourceContext.NotebookName != ac.currentNotebook </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Error("SECURITY VIOLATION: Cross-notebook access attempt",
                        "tool", toolName,
                        "requested_notebook", resourceContext.NotebookName,
                        "current_notebook", ac.currentNotebook,
                        "security_action", "BLOCKING_CROSS_NOTEBOOK_ACCESS")
                return fmt.Errorf("access denied: cannot access notebook '%s' when '%s' is selected", resourceContext.NotebookName, ac.currentNotebook)
        }</span>
        
        // 4. Check if current notebook permission allows the requested operation
        <span class="cov8" title="1">if !ac.permissionAllowsOperation(ac.currentNotebookPerm, resourceContext.Operation) </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Info("Operation not allowed by current notebook permission",
                        "tool", toolName,
                        "current_notebook", ac.currentNotebook,
                        "required_operation", resourceContext.Operation,
                        "notebook_permission", ac.currentNotebookPerm)
                return fmt.Errorf("access denied: operation '%s' requires '%s' permission but current notebook has '%s'", 
                        resourceContext.Operation, resourceContext.Operation, ac.currentNotebookPerm)
        }</span>
        
        <span class="cov8" title="1">logging.AuthorizationLogger.Debug("Authorization granted",
                "tool", toolName,
                "operation", resourceContext.Operation,
                "current_notebook", ac.currentNotebook,
                "notebook_permission", ac.currentNotebookPerm)
        
        return nil</span>
}




// permissionAllowsOperation checks if a permission level allows a specific operation
func (ac *AuthorizationConfig) permissionAllowsOperation(permission PermissionLevel, operation ToolOperation) bool <span class="cov8" title="1">{
        switch permission </span>{
        case PermissionNone:<span class="cov0" title="0">
                return false</span>
        case PermissionRead:<span class="cov8" title="1">
                return operation == OperationRead</span>
        case PermissionWrite, PermissionFull:<span class="cov0" title="0">
                return true</span> // Write permission allows both read and write
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// FilterNotebooks filters a list of notebooks based on authorization permissions
// Only notebooks with read, write, or full permissions are included
func (ac *AuthorizationConfig) FilterNotebooks(notebooks []map[string]interface{}) []map[string]interface{} <span class="cov8" title="1">{
        if !ac.Enabled </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Debug("Notebook filtering skipped - authorization disabled",
                        "notebook_count", len(notebooks))
                return notebooks // No filtering when authorization disabled
        }</span>

        <span class="cov8" title="1">logging.AuthorizationLogger.Debug("Starting notebook filtering",
                "notebook_count", len(notebooks),
                "default_permissions", ac.DefaultNotebookPermissions,
                "notebook_permissions_configured", len(ac.NotebookPermissions) &gt; 0)

        var filtered []map[string]interface{}
        var filteredOut []string

        for _, notebook := range notebooks </span><span class="cov8" title="1">{
                if displayName, ok := notebook["displayName"].(string); ok </span><span class="cov8" title="1">{
                        notebookID, _ := notebook["id"].(string)
                        
                        // Get permission using exact match or default
                        permission := ac.GetNotebookPermission(displayName)
                        
                        if permission != PermissionNone &amp;&amp; permission != "" </span><span class="cov8" title="1">{
                                filtered = append(filtered, notebook)
                                logging.AuthorizationLogger.Debug("Notebook allowed by filter",
                                        "notebook_name", displayName,
                                        "notebook_id", notebookID,
                                        "permission", permission)
                        }</span> else<span class="cov8" title="1"> {
                                filteredOut = append(filteredOut, displayName)
                                logging.AuthorizationLogger.Debug("Notebook blocked by filter",
                                        "notebook_name", displayName,
                                        "notebook_id", notebookID,
                                        "permission", permission,
                                        "why_blocked", "permission is 'none' or empty")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.AuthorizationLogger.Warn("Notebook missing displayName field, skipping",
                                "notebook", notebook)
                }</span>
        }

        // Log comprehensive filtering summary
        <span class="cov8" title="1">if len(filteredOut) &gt; 0 </span><span class="cov8" title="1">{
                logging.AuthorizationLogger.Info("Filtered out notebooks due to authorization",
                        "filtered_count", len(filteredOut),
                        "filtered_notebooks", filteredOut,
                        "remaining_count", len(filtered))
        }</span>

        <span class="cov8" title="1">logging.AuthorizationLogger.Debug("Notebook filtering completed",
                "original_count", len(notebooks),
                "filtered_count", len(filtered),
                "removed_count", len(filteredOut))

        return filtered</span>
}


// GetNotebookPermission gets the effective permission for a notebook using exact matching
func (ac *AuthorizationConfig) GetNotebookPermission(notebookName string) PermissionLevel <span class="cov8" title="1">{
        // Try exact match first
        if permission, exists := ac.NotebookPermissions[notebookName]; exists </span><span class="cov8" title="1">{
                return permission
        }</span>

        // Fall back to default
        <span class="cov8" title="1">return ac.DefaultNotebookPermissions</span>
}

// GetNotebookPermissionWithSource gets the permission and source information for a notebook
func (ac *AuthorizationConfig) GetNotebookPermissionWithSource(notebookName string) (PermissionLevel, string, string) <span class="cov0" title="0">{
        // Try exact match first
        if permission, exists := ac.NotebookPermissions[notebookName]; exists </span><span class="cov0" title="0">{
                return permission, notebookName, "exact"
        }</span>

        // Fall back to default
        <span class="cov0" title="0">return ac.DefaultNotebookPermissions, "", "default"</span>
}


</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package authorization

import (
        "context"

        "github.com/mark3labs/mcp-go/mcp"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// NotebookCache interface defines the methods needed from the notebook cache
type NotebookCache interface {
        GetNotebook() (map[string]interface{}, bool)
        GetDisplayName() (string, bool)
}

// ExtractResourceContext extracts simplified resource context from tool call
func ExtractResourceContext(ctx context.Context, toolName string, req mcp.CallToolRequest, cache NotebookCache) ResourceContext <span class="cov0" title="0">{
        resourceContext := ResourceContext{
                Operation: getToolOperation(toolName),
        }

        logging.AuthorizationLogger.Debug("Extracting simplified resource context",
                "tool", toolName,
                "operation", resourceContext.Operation)

        // Get current notebook name from cache if available
        if displayName, hasName := cache.GetDisplayName(); hasName </span><span class="cov0" title="0">{
                resourceContext.NotebookName = displayName
                logging.AuthorizationLogger.Debug("Got notebook from cache",
                        "notebook_name", resourceContext.NotebookName)
        }</span>

        <span class="cov0" title="0">logging.AuthorizationLogger.Debug("Resource context extracted",
                "tool", toolName,
                "notebook_name", resourceContext.NotebookName,
                "operation", resourceContext.Operation)

        return resourceContext</span>
}

// getToolOperation determines if a tool performs read or write operations
func getToolOperation(toolName string) ToolOperation <span class="cov0" title="0">{
        switch toolName </span>{
        // Read-only operations
        case "getAuthStatus", "listNotebooks", "listSections", "listPages", 
                 "getPageContent", "getPageMetadata", "searchPages":<span class="cov0" title="0">
                return OperationRead</span>
        
        // Write operations
        case "selectNotebook", "createSection", "updateSection", "deleteSection",
                 "createPage", "updatePageContent", "updatePageContentAdvanced", 
                 "deletePage", "quickNote":<span class="cov0" title="0">
                return OperationWrite</span>
        
        // Default to read for unknown tools (safe default)
        default:<span class="cov0" title="0">
                logging.AuthorizationLogger.Debug("Unknown tool, defaulting to read operation", "tool", toolName)
                return OperationRead</span>
        }
}</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package authorization

import (
        "context"
        "fmt"

        "github.com/mark3labs/mcp-go/mcp"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// ToolHandler represents the signature of an MCP tool handler function
type ToolHandler func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error)

// AuthorizedToolHandler wraps a tool handler with simplified authorization checks
func AuthorizedToolHandler(toolName string, handler ToolHandler, authConfig *AuthorizationConfig, cache NotebookCache, quickNoteConfig QuickNoteConfig) ToolHandler <span class="cov0" title="0">{
        return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov0" title="0">{
                // Skip authorization if not enabled
                if authConfig == nil || !authConfig.Enabled </span><span class="cov0" title="0">{
                        logging.AuthorizationLogger.Debug("Authorization wrapper bypassed",
                                "tool", toolName,
                                "reason", "authorization_disabled")
                        return handler(ctx, req)
                }</span>

                <span class="cov0" title="0">logging.AuthorizationLogger.Debug("Authorization wrapper invoked",
                        "tool", toolName,
                        "authorization_enabled", authConfig.Enabled)

                // Extract simplified resource context
                resourceContext := ExtractResourceContext(ctx, toolName, req, cache)

                // Special handling for quickNote tool - use quicknote notebook if specified
                if toolName == "quickNote" &amp;&amp; quickNoteConfig != nil </span><span class="cov0" title="0">{
                        targetNotebook := quickNoteConfig.GetNotebookName()
                        if targetNotebook == "" </span><span class="cov0" title="0">{
                                targetNotebook = quickNoteConfig.GetDefaultNotebook()
                        }</span>
                        
                        <span class="cov0" title="0">if targetNotebook != "" </span><span class="cov0" title="0">{
                                resourceContext.NotebookName = targetNotebook
                                logging.AuthorizationLogger.Debug("Using quickNote target notebook",
                                        "target_notebook", targetNotebook)
                        }</span>
                }

                // Perform authorization check
                <span class="cov0" title="0">err := authConfig.IsAuthorized(ctx, toolName, req, resourceContext)
                if err != nil </span><span class="cov0" title="0">{
                        logging.AuthorizationLogger.Info("Authorization check failed",
                                "tool", toolName,
                                "resource_context", resourceContext.String(),
                                "error", err.Error())
                        return mcp.NewToolResultError(fmt.Sprintf("Authorization failed: %v", err)), nil
                }</span>

                <span class="cov0" title="0">logging.AuthorizationLogger.Debug("Authorization check passed, executing tool",
                        "tool", toolName,
                        "resource_context", resourceContext.String())

                // Authorization passed, execute the original handler
                return handler(ctx, req)</span>
        }
}

// QuickNoteConfig interface defines the methods needed to get quickNote configuration
type QuickNoteConfig interface {
        GetNotebookName() string    // Returns quicknote-specific notebook name
        GetDefaultNotebook() string // Returns default notebook name as fallback
        GetPageName() string        // Returns target page name
}

// CreateAuthorizedTool creates an MCP tool with authorization wrapper
func CreateAuthorizedTool(toolName string, handler ToolHandler, authConfig *AuthorizationConfig, cache NotebookCache, quickNoteConfig QuickNoteConfig, toolOptions ...mcp.ToolOption) mcp.Tool <span class="cov0" title="0">{
        // Create the tool with the options
        tool := mcp.NewTool(toolName, toolOptions...)
        
        logging.AuthorizationLogger.Debug("Created authorized tool",
                "tool", toolName,
                "authorization_enabled", authConfig != nil &amp;&amp; authConfig.Enabled)
        
        return tool
}</span>

// AuthorizationInfo provides information about the simplified authorization system status
type AuthorizationInfo struct {
        Enabled                  bool   `json:"enabled"`
        DefaultNotebookMode      string `json:"default_notebook_mode"`
        NotebookRules           int    `json:"notebook_rules_configured"`
        CurrentNotebook         string `json:"current_notebook"`
        CurrentNotebookPerm     string `json:"current_notebook_permission"`
}

// GetAuthorizationInfo returns information about the current authorization configuration
func GetAuthorizationInfo(authConfig *AuthorizationConfig) AuthorizationInfo <span class="cov0" title="0">{
        if authConfig == nil </span><span class="cov0" title="0">{
                return AuthorizationInfo{
                        Enabled: false,
                }
        }</span>

        <span class="cov0" title="0">return AuthorizationInfo{
                Enabled:                  authConfig.Enabled,
                DefaultNotebookMode:      string(authConfig.DefaultNotebookPermissions),
                NotebookRules:           len(authConfig.NotebookPermissions),
                CurrentNotebook:         authConfig.GetCurrentNotebook(),
                CurrentNotebookPerm:     string(authConfig.currentNotebookPerm),
        }</span>
}

// ValidateAuthorizationConfig validates the simplified authorization configuration
func ValidateAuthorizationConfig(authConfig *AuthorizationConfig) error <span class="cov0" title="0">{
        if authConfig == nil </span><span class="cov0" title="0">{
                return nil // nil config is valid (authorization disabled)
        }</span>

        // Validate default notebook permissions
        <span class="cov0" title="0">switch authConfig.DefaultNotebookPermissions </span>{
        case PermissionNone, PermissionRead, PermissionWrite, PermissionFull:<span class="cov0" title="0"></span>
                // Valid
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid default_notebook_permissions: %s (must be one of: none, read, write, full)", authConfig.DefaultNotebookPermissions)</span>
        }
        
        // Validate notebook permissions
        <span class="cov0" title="0">for name, mode := range authConfig.NotebookPermissions </span><span class="cov0" title="0">{
                switch mode </span>{
                case PermissionNone, PermissionRead, PermissionWrite, PermissionFull:<span class="cov0" title="0"></span>
                        // Valid
                default:<span class="cov0" title="0">
                        return fmt.Errorf("invalid notebook permission for '%s': %s (must be one of: none, read, write, full)", name, mode)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// config.go - Configuration management for the OneNote MCP server.
//
// This file provides flexible configuration loading from multiple sources including
// environment variables, JSON configuration files, and command-line arguments.
// It centralizes all configuration management for the OneNote MCP server.
//
// Key Features:
// - Multi-source configuration loading (env vars, JSON files, defaults)
// - Environment variable support with automatic mapping
// - JSON configuration file support with validation
// - Configuration validation and error reporting
// - Flexible toolset configuration
// - Comprehensive logging of configuration values
//
// Configuration Sources (in order of precedence):
// 1. Environment variables (highest priority)
// 2. JSON configuration file (if ONENOTE_MCP_CONFIG is set)
// 3. Default values (lowest priority)
//
// Environment Variables:
// - ONENOTE_CLIENT_ID: Azure App Registration Client ID
// - ONENOTE_TENANT_ID: Azure Tenant ID (use "common" for multi-tenant)
// - ONENOTE_REDIRECT_URI: OAuth2 redirect URI for authentication
// - ONENOTE_DEFAULT_NOTEBOOK_NAME: Default notebook name (optional)
// - ONENOTE_TOOLSETS: Comma-separated list of enabled toolsets
// - ONENOTE_MCP_CONFIG: Path to JSON configuration file (optional)
// - LOG_LEVEL: General logging level (DEBUG, INFO, WARN, ERROR)
// - LOG_FORMAT: Log format ("text" or "json")
// - MCP_LOG_FILE: Optional log file path
// - CONTENT_LOG_LEVEL: Content logging verbosity (DEBUG, INFO, WARN, ERROR, OFF)
//
// JSON Configuration File Format:
// {
//   "client_id": "your-azure-app-client-id",
//   "tenant_id": "your-azure-tenant-id",
//   "redirect_uri": "http://localhost:8080/callback",
//   "notebook_name": "My Default Notebook",
//   "toolsets": ["notebooks", "sections", "pages", "content"],
//   "log_level": "DEBUG",
//   "log_format": "text",
//   "log_file": "mcp-server.log",
//   "content_log_level": "DEBUG"
// }
//
// Available Toolsets:
// - "notebooks": Notebook listing and management
// - "sections": Section operations within notebooks
// - "pages": Page CRUD operations
// - "content": Content extraction and manipulation
//
// Configuration Validation:
// - Required fields validation
// - URL format validation for redirect URI
// - Azure app registration validation
// - Toolset availability checking
//
// Error Handling:
// - Missing required configuration values
// - Invalid JSON configuration files
// - File permission issues
// - Environment variable parsing errors
//
// Usage Example:
//   cfg, err := config.Load()
//   if err != nil {
//       log.Fatalf("Failed to load config: %v", err)
//   }
//   fmt.Printf("Client ID: %s\n", cfg.ClientID)
//
// For detailed configuration options, see README.md and docs/setup.md

package config

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/gebl/onenote-mcp-server/internal/authorization"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// Config holds all configuration values for the OneNote MCP server.
type Config struct {
        ClientID     string   `json:"client_id"`     // Application (client) ID
        TenantID     string   `json:"tenant_id"`     // Directory (tenant) ID
        RedirectURI  string   `json:"redirect_uri"`  // Redirect URI for OAuth2 callback
        Toolsets     []string `json:"toolsets"`      // Enabled toolsets (e.g., notebooks, sections, pages)
        NotebookName string   `json:"notebook_name"` // Default notebook name (optional) - maps to ONENOTE_DEFAULT_NOTEBOOK_NAME

        // Quicknote configuration
        QuickNote *QuickNoteConfig `json:"quicknote"` // Quicknote settings for rapid note-taking

        // MCP Authentication configuration
        MCPAuth *MCPAuthConfig `json:"mcp_auth"` // MCP server authentication settings

        // Authorization configuration
        Authorization *authorization.AuthorizationConfig `json:"authorization"` // Tool and resource authorization settings

        // Server configuration
        Stateless *bool `json:"stateless"` // Enable stateless mode for HTTP server

        // Logging configuration
        LogLevel        string `json:"log_level"`         // General logging level: DEBUG, INFO, WARN, ERROR
        LogFormat       string `json:"log_format"`        // Log format: "text" or "json"
        LogFile         string `json:"log_file"`          // Optional log file path
        ContentLogLevel string `json:"content_log_level"` // Content logging verbosity: DEBUG, INFO, WARN, ERROR, OFF
}

// QuickNoteConfig holds configuration for the quicknote tool.
type QuickNoteConfig struct {
        NotebookName string `json:"notebook_name"` // Target notebook name for quicknotes
        PageName     string `json:"page_name"`     // Target page name for quicknotes
        DateFormat   string `json:"date_format"`   // Date format string for timestamps (Go time format)
}

// MCPAuthConfig holds MCP server authentication configuration.
type MCPAuthConfig struct {
        Enabled     bool   `json:"enabled"`      // Enable MCP authentication for HTTP/SSE modes
        BearerToken string `json:"bearer_token"` // Bearer token for authentication
}

// GetNotebookName returns the quicknote-specific notebook name
func (qc *QuickNoteConfig) GetNotebookName() string <span class="cov8" title="1">{
        if qc == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return qc.NotebookName</span>
}

// GetDefaultNotebook returns the default notebook name from the main config
// This method should be called from the main Config struct
func (c *Config) GetDefaultNotebook() string <span class="cov0" title="0">{
        return c.NotebookName
}</span>

// GetPageName returns the target page name for quicknote
func (qc *QuickNoteConfig) GetPageName() string <span class="cov0" title="0">{
        if qc == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return qc.PageName</span>
}

// Load reads configuration from environment variables and optionally from a JSON config file.
// Returns a pointer to a Config and an error, if any.
//
// IMPORTANT: This function assumes logging is initialized with DEBUG level to capture
// all configuration loading details. After config loading, logging will be reconfigured
// based on the loaded configuration values.
func Load() (*Config, error) <span class="cov8" title="1">{
        startTime := time.Now()
        logger := logging.ConfigLogger

        logger.Debug("Starting configuration loading")

        // Initialize stateless with default value (false)
        statelessDefault := false
        statelessPtr := &amp;statelessDefault
        if statelessEnv := os.Getenv("MCP_STATELESS"); statelessEnv == "true" </span><span class="cov0" title="0">{
                statelessTrue := true
                statelessPtr = &amp;statelessTrue
        }</span>

        <span class="cov8" title="1">cfg := &amp;Config{
                ClientID:     os.Getenv("ONENOTE_CLIENT_ID"),
                TenantID:     os.Getenv("ONENOTE_TENANT_ID"),
                RedirectURI:  os.Getenv("ONENOTE_REDIRECT_URI"),
                NotebookName: os.Getenv("ONENOTE_DEFAULT_NOTEBOOK_NAME"),

                // Quicknote configuration from environment variables
                QuickNote: &amp;QuickNoteConfig{
                        NotebookName: os.Getenv("QUICKNOTE_NOTEBOOK_NAME"),
                        PageName:     os.Getenv("QUICKNOTE_PAGE_NAME"),
                        DateFormat:   os.Getenv("QUICKNOTE_DATE_FORMAT"),
                },

                // MCP Authentication configuration from environment variables
                MCPAuth: &amp;MCPAuthConfig{
                        Enabled:     os.Getenv("MCP_AUTH_ENABLED") == "true",
                        BearerToken: os.Getenv("MCP_BEARER_TOKEN"),
                },

                // Authorization configuration - will be initialized after JSON loading
                Authorization: authorization.NewAuthorizationConfig(),

                // Server configuration from environment variables
                Stateless: statelessPtr,

                // Logging configuration from environment variables
                LogLevel:        os.Getenv("LOG_LEVEL"),
                LogFormat:       os.Getenv("LOG_FORMAT"),
                LogFile:         os.Getenv("MCP_LOG_FILE"),
                ContentLogLevel: os.Getenv("CONTENT_LOG_LEVEL"),
        }

        logger.Debug("Loaded from environment variables",
                "client_id", maskSensitiveData(cfg.ClientID),
                "tenant_id", cfg.TenantID,
                "redirect_uri", cfg.RedirectURI,
                "notebook_name", cfg.NotebookName,
                "quicknote_notebook", cfg.QuickNote.NotebookName,
                "quicknote_page", cfg.QuickNote.PageName,
                "quicknote_date_format", cfg.QuickNote.DateFormat,
                "mcp_auth_enabled", cfg.MCPAuth.Enabled,
                "mcp_bearer_token", maskSensitiveData(cfg.MCPAuth.BearerToken),
                "stateless", cfg.Stateless != nil &amp;&amp; *cfg.Stateless,
                "log_level", cfg.LogLevel,
                "log_format", cfg.LogFormat,
                "log_file", cfg.LogFile,
                "content_log_level", cfg.ContentLogLevel)

        // Log all environment variables that could affect configuration
        logger.Debug("Environment variables scan",
                "ONENOTE_CLIENT_ID", maskEnvironmentValue("ONENOTE_CLIENT_ID"),
                "ONENOTE_TENANT_ID", maskEnvironmentValue("ONENOTE_TENANT_ID"),
                "ONENOTE_REDIRECT_URI", maskEnvironmentValue("ONENOTE_REDIRECT_URI"),
                "ONENOTE_DEFAULT_NOTEBOOK_NAME", maskEnvironmentValue("ONENOTE_DEFAULT_NOTEBOOK_NAME"),
                "ONENOTE_TOOLSETS", maskEnvironmentValue("ONENOTE_TOOLSETS"),
                "ONENOTE_MCP_CONFIG", maskEnvironmentValue("ONENOTE_MCP_CONFIG"),
                "QUICKNOTE_NOTEBOOK_NAME", maskEnvironmentValue("QUICKNOTE_NOTEBOOK_NAME"),
                "QUICKNOTE_PAGE_NAME", maskEnvironmentValue("QUICKNOTE_PAGE_NAME"),
                "QUICKNOTE_DATE_FORMAT", maskEnvironmentValue("QUICKNOTE_DATE_FORMAT"),
                "MCP_AUTH_ENABLED", maskEnvironmentValue("MCP_AUTH_ENABLED"),
                "MCP_BEARER_TOKEN", maskEnvironmentValue("MCP_BEARER_TOKEN"),
                "MCP_STATELESS", maskEnvironmentValue("MCP_STATELESS"),
                "LOG_LEVEL", maskEnvironmentValue("LOG_LEVEL"),
                "LOG_FORMAT", maskEnvironmentValue("LOG_FORMAT"),
                "MCP_LOG_FILE", maskEnvironmentValue("MCP_LOG_FILE"),
                "CONTENT_LOG_LEVEL", maskEnvironmentValue("CONTENT_LOG_LEVEL"))

        // Toolsets from env (comma-separated string)
        var envHasToolsets bool
        if toolsets := os.Getenv("ONENOTE_TOOLSETS"); toolsets != "" </span><span class="cov8" title="1">{
                cfg.Toolsets = strings.Split(toolsets, ",")
                envHasToolsets = true
                logger.Debug("Loaded toolsets from environment", "toolsets", cfg.Toolsets)
        }</span> else<span class="cov8" title="1"> {
                logger.Debug("No toolsets specified in environment - using defaults")
                cfg.Toolsets = []string{"notebooks", "sections", "pages", "content"}
        }</span>


        // Optionally load from config file if ONENOTE_MCP_CONFIG is set
        <span class="cov8" title="1">if path := os.Getenv("ONENOTE_MCP_CONFIG"); path != "" </span><span class="cov8" title="1">{
                logger.Debug("Loading from config file", "path", path)

                // Save environment variable values to restore after JSON loading
                // (environment variables have higher precedence than JSON)
                envClientID := cfg.ClientID
                envTenantID := cfg.TenantID
                envRedirectURI := cfg.RedirectURI
                envNotebookName := cfg.NotebookName
                var envToolsets []string
                if envHasToolsets </span><span class="cov0" title="0">{
                        envToolsets = make([]string, len(cfg.Toolsets))
                        copy(envToolsets, cfg.Toolsets)
                }</span>
                <span class="cov8" title="1">envQuickNote := QuickNoteConfig{
                        NotebookName: cfg.QuickNote.NotebookName,
                        PageName:     cfg.QuickNote.PageName,
                        DateFormat:   cfg.QuickNote.DateFormat,
                }
                envMCPAuth := MCPAuthConfig{
                        Enabled:     cfg.MCPAuth.Enabled,
                        BearerToken: cfg.MCPAuth.BearerToken,
                }
                envStateless := cfg.Stateless
                envLogLevel := cfg.LogLevel
                envLogFormat := cfg.LogFormat
                envLogFile := cfg.LogFile
                envContentLogLevel := cfg.ContentLogLevel

                fileInfo, err := os.Stat(path)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("Failed to stat config file", "path", path, "error", err)
                        return nil, fmt.Errorf("config file not accessible: %v", err)
                }</span>
                <span class="cov8" title="1">logger.Debug("Config file info", "size", fileInfo.Size(), "mod_time", fileInfo.ModTime())

                f, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to open config file", "path", path, "error", err)
                        return nil, fmt.Errorf("failed to open config file: %v", err)
                }</span>
                <span class="cov8" title="1">defer f.Close()

                dec := json.NewDecoder(f)
                if err := dec.Decode(cfg); err != nil </span><span class="cov8" title="1">{
                        logger.Error("Failed to decode JSON from config file", "path", path, "error", err)
                        return nil, fmt.Errorf("failed to parse config file JSON: %v", err)
                }</span>

                // Restore environment variable values (they have higher precedence)
                <span class="cov8" title="1">if envClientID != "" </span><span class="cov8" title="1">{
                        cfg.ClientID = envClientID
                }</span>
                <span class="cov8" title="1">if envTenantID != "" </span><span class="cov0" title="0">{
                        cfg.TenantID = envTenantID
                }</span>
                <span class="cov8" title="1">if envRedirectURI != "" </span><span class="cov0" title="0">{
                        cfg.RedirectURI = envRedirectURI
                }</span>
                <span class="cov8" title="1">if envNotebookName != "" </span><span class="cov0" title="0">{
                        cfg.NotebookName = envNotebookName
                }</span>
                <span class="cov8" title="1">if len(envToolsets) &gt; 0 </span><span class="cov0" title="0">{
                        cfg.Toolsets = envToolsets
                }</span>
                <span class="cov8" title="1">if envQuickNote.NotebookName != "" </span><span class="cov0" title="0">{
                        cfg.QuickNote.NotebookName = envQuickNote.NotebookName
                }</span>
                <span class="cov8" title="1">if envQuickNote.PageName != "" </span><span class="cov0" title="0">{
                        cfg.QuickNote.PageName = envQuickNote.PageName
                }</span>
                <span class="cov8" title="1">if envQuickNote.DateFormat != "" </span><span class="cov0" title="0">{
                        cfg.QuickNote.DateFormat = envQuickNote.DateFormat
                }</span>
                <span class="cov8" title="1">if cfg.MCPAuth == nil </span><span class="cov0" title="0">{
                        cfg.MCPAuth = &amp;MCPAuthConfig{}
                }</span>
                <span class="cov8" title="1">if envMCPAuth.Enabled || envMCPAuth.BearerToken != "" </span><span class="cov0" title="0">{
                        cfg.MCPAuth.Enabled = envMCPAuth.Enabled
                        cfg.MCPAuth.BearerToken = envMCPAuth.BearerToken
                }</span>
                <span class="cov8" title="1">if envStateless != nil </span><span class="cov8" title="1">{
                        cfg.Stateless = envStateless
                }</span>
                <span class="cov8" title="1">if envLogLevel != "" </span><span class="cov8" title="1">{
                        cfg.LogLevel = envLogLevel
                }</span>
                <span class="cov8" title="1">if envLogFormat != "" </span><span class="cov0" title="0">{
                        cfg.LogFormat = envLogFormat
                }</span>
                <span class="cov8" title="1">if envLogFile != "" </span><span class="cov0" title="0">{
                        cfg.LogFile = envLogFile
                }</span>
                <span class="cov8" title="1">if envContentLogLevel != "" </span><span class="cov0" title="0">{
                        cfg.ContentLogLevel = envContentLogLevel
                }</span>

                // Ensure stateless has a default value if not set in JSON
                <span class="cov8" title="1">if cfg.Stateless == nil </span><span class="cov0" title="0">{
                        defaultStateless := false
                        cfg.Stateless = &amp;defaultStateless
                }</span>

                // Ensure QuickNote has a default value if not set in JSON
                <span class="cov8" title="1">if cfg.QuickNote == nil </span><span class="cov0" title="0">{
                        cfg.QuickNote = &amp;QuickNoteConfig{}
                }</span>

                // Set default date format if not provided
                <span class="cov8" title="1">if cfg.QuickNote.DateFormat == "" </span><span class="cov8" title="1">{
                        cfg.QuickNote.DateFormat = "January 2, 2006 - 3:04 PM"
                }</span>

                // Ensure Authorization has a default value if not set in JSON
                <span class="cov8" title="1">if cfg.Authorization == nil </span><span class="cov0" title="0">{
                        cfg.Authorization = authorization.NewAuthorizationConfig()
                }</span>

                // Ensure DefaultNotebookPermissions has a valid default if not set in JSON
                <span class="cov8" title="1">if cfg.Authorization.DefaultNotebookPermissions == "" </span><span class="cov0" title="0">{
                        cfg.Authorization.DefaultNotebookPermissions = authorization.PermissionRead
                }</span>

                // Set default toolsets if not specified in JSON
                <span class="cov8" title="1">if len(cfg.Toolsets) == 0 </span><span class="cov0" title="0">{
                        cfg.Toolsets = []string{"notebooks", "sections", "pages", "content"}
                }</span>

                <span class="cov8" title="1">logger.Debug("Successfully loaded from config file",
                        "client_id", maskSensitiveData(cfg.ClientID),
                        "tenant_id", cfg.TenantID,
                        "redirect_uri", cfg.RedirectURI,
                        "toolsets", cfg.Toolsets,
                        "notebook_name", cfg.NotebookName,
                        "quicknote_notebook", cfg.QuickNote.NotebookName,
                        "quicknote_page", cfg.QuickNote.PageName,
                        "quicknote_date_format", cfg.QuickNote.DateFormat,
                        "mcp_auth_enabled", cfg.MCPAuth.Enabled,
                        "mcp_bearer_token", maskSensitiveData(cfg.MCPAuth.BearerToken),
                        "stateless", cfg.Stateless != nil &amp;&amp; *cfg.Stateless,
                        "log_level", cfg.LogLevel,
                        "log_format", cfg.LogFormat,
                        "log_file", cfg.LogFile,
                        "content_log_level", cfg.ContentLogLevel)

                logger.Info("Configuration loaded from JSON file",
                        "config_file", path,
                        "file_size", fileInfo.Size(),
                        "contains_client_id", cfg.ClientID != "",
                        "contains_tenant_id", cfg.TenantID != "",
                        "contains_redirect_uri", cfg.RedirectURI != "",
                        "contains_notebook_name", cfg.NotebookName != "",
                        "toolsets_count", len(cfg.Toolsets),
                        "mcp_auth_configured", cfg.MCPAuth != nil &amp;&amp; cfg.MCPAuth.Enabled,
                        "logging_configured", cfg.LogLevel != "" || cfg.LogFormat != "" || cfg.LogFile != "" || cfg.ContentLogLevel != "")</span>
        } else<span class="cov8" title="1"> {
                logger.Debug("No config file specified (ONENOTE_MCP_CONFIG not set)")
                
                // Set default date format if not provided from environment
                if cfg.QuickNote.DateFormat == "" </span><span class="cov8" title="1">{
                        cfg.QuickNote.DateFormat = "January 2, 2006 - 3:04 PM"
                }</span>
        }

        // Apply environment variable overrides for authorization configuration
        <span class="cov8" title="1">if cfg.Authorization != nil </span><span class="cov8" title="1">{
                if authEnabled := os.Getenv("AUTHORIZATION_ENABLED"); authEnabled != "" </span><span class="cov8" title="1">{
                        cfg.Authorization.Enabled = authEnabled == "true"
                }</span>
                <span class="cov8" title="1">if defaultMode := os.Getenv("AUTHORIZATION_DEFAULT_MODE"); defaultMode != "" </span><span class="cov8" title="1">{
                        cfg.Authorization.DefaultNotebookPermissions = authorization.PermissionLevel(defaultMode)
                }</span>
                // Parse authorization permissions from environment variables if present
                <span class="cov8" title="1">if notebookPerms := os.Getenv("AUTHORIZATION_NOTEBOOK_PERMISSIONS"); notebookPerms != "" </span><span class="cov0" title="0">{
                        // Parse JSON format: {"pattern":"permission",...}
                        var perms map[string]string
                        if err := json.Unmarshal([]byte(notebookPerms), &amp;perms); err == nil </span><span class="cov0" title="0">{
                                for pattern, perm := range perms </span><span class="cov0" title="0">{
                                        cfg.Authorization.NotebookPermissions[pattern] = authorization.PermissionLevel(perm)
                                }</span>
                        }
                }
        }

        // Apply defaults for empty fields
        <span class="cov8" title="1">if cfg.LogLevel == "" </span><span class="cov8" title="1">{
                cfg.LogLevel = "INFO"
        }</span>
        <span class="cov8" title="1">if cfg.LogFormat == "" </span><span class="cov8" title="1">{
                cfg.LogFormat = "text"
        }</span>
        <span class="cov8" title="1">if cfg.ContentLogLevel == "" </span><span class="cov8" title="1">{
                cfg.ContentLogLevel = "INFO"
        }</span>

        // Validate configuration
        <span class="cov8" title="1">logger.Debug("Validating configuration")
        if err := validateConfig(cfg); err != nil </span><span class="cov8" title="1">{
                logger.Error("Configuration validation failed", "error", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Debug("Configuration validation passed")

        // Validate authorization configuration if present
        if cfg.Authorization != nil </span><span class="cov8" title="1">{
                logger.Debug("Validating authorization configuration")
                if err := cfg.Authorization.ValidateConfig(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Authorization configuration validation failed", "error", err)
                        return nil, fmt.Errorf("failed to validate authorization configuration: %v", err)
                }</span>
                <span class="cov8" title="1">logger.Debug("Authorization configuration validated successfully")</span>
        }

        <span class="cov8" title="1">elapsed := time.Since(startTime)

        // Comprehensive final configuration summary
        logger.Info("Configuration loaded successfully",
                "duration", elapsed,
                "client_id_configured", cfg.ClientID != "",
                "tenant_id_configured", cfg.TenantID != "",
                "redirect_uri_configured", cfg.RedirectURI != "",
                "notebook_name_configured", cfg.NotebookName != "",
                "toolsets_configured", len(cfg.Toolsets) &gt; 0,
                "mcp_auth_configured", cfg.MCPAuth != nil &amp;&amp; cfg.MCPAuth.Enabled,
                "logging_level_set", cfg.LogLevel != "",
                "config_source", getConfigSource())

        logger.Debug("Final configuration details",
                "client_id", maskSensitiveData(cfg.ClientID),
                "tenant_id", cfg.TenantID,
                "redirect_uri", cfg.RedirectURI,
                "notebook_name", cfg.NotebookName,
                "quicknote_notebook", cfg.QuickNote.NotebookName,
                "quicknote_page", cfg.QuickNote.PageName,
                "quicknote_date_format", cfg.QuickNote.DateFormat,
                "toolsets", cfg.Toolsets,
                "toolsets_count", len(cfg.Toolsets),
                "mcp_auth_enabled", cfg.MCPAuth.Enabled,
                "mcp_bearer_token", maskSensitiveData(cfg.MCPAuth.BearerToken),
                "stateless", cfg.Stateless != nil &amp;&amp; *cfg.Stateless,
                "log_level", cfg.LogLevel,
                "log_format", cfg.LogFormat,
                "log_file", cfg.LogFile,
                "content_log_level", cfg.ContentLogLevel)

        // Log effective configuration values (after all sources processed)
        logger.Debug("Effective configuration values",
                "client_id_length", len(cfg.ClientID),
                "tenant_id_set", cfg.TenantID != "",
                "redirect_uri_set", cfg.RedirectURI != "",
                "default_notebook_name", cfg.NotebookName,
                "enabled_toolsets", cfg.Toolsets,
                "mcp_auth_config", map[string]interface{}{
                        "enabled":      cfg.MCPAuth.Enabled,
                        "token_length": len(cfg.MCPAuth.BearerToken),
                },
                "logging_config", map[string]string{
                        "level":         cfg.LogLevel,
                        "format":        cfg.LogFormat,
                        "file":          cfg.LogFile,
                        "content_level": cfg.ContentLogLevel,
                })

        return cfg, nil</span>
}

// GetLogLevel returns the configured logging level.
func (c *Config) GetLogLevel() string <span class="cov0" title="0">{
        return c.LogLevel
}</span>

// GetLogFormat returns the configured log format (text or json).
func (c *Config) GetLogFormat() string <span class="cov0" title="0">{
        return c.LogFormat
}</span>

// GetLogFile returns the configured log file path.
func (c *Config) GetLogFile() string <span class="cov0" title="0">{
        return c.LogFile
}</span>

// GetContentLogLevel returns the configured content logging level.
func (c *Config) GetContentLogLevel() string <span class="cov0" title="0">{
        return c.ContentLogLevel
}</span>

// validateConfig performs validation on the loaded configuration
func validateConfig(cfg *Config) error <span class="cov8" title="1">{
        logger := logging.ConfigLogger

        logger.Debug("Starting configuration validation",
                "client_id_present", cfg.ClientID != "",
                "tenant_id_present", cfg.TenantID != "",
                "redirect_uri_present", cfg.RedirectURI != "",
                "toolsets_count", len(cfg.Toolsets))

        logger.Debug("Validating ClientID")
        if cfg.ClientID == "" </span><span class="cov8" title="1">{
                logger.Error("ClientID validation failed - required field missing")
                return fmt.Errorf("ONENOTE_CLIENT_ID is required")
        }</span>
        <span class="cov8" title="1">logger.Debug("ClientID validation passed", "client_id_length", len(cfg.ClientID))

        logger.Debug("Validating TenantID")
        if cfg.TenantID == "" </span><span class="cov8" title="1">{
                logger.Error("TenantID validation failed - required field missing")
                return fmt.Errorf("ONENOTE_TENANT_ID is required")
        }</span>
        <span class="cov8" title="1">logger.Debug("TenantID validation passed", "tenant_id", cfg.TenantID)

        logger.Debug("Validating RedirectURI")
        if cfg.RedirectURI == "" </span><span class="cov8" title="1">{
                logger.Error("RedirectURI validation failed - required field missing")
                return fmt.Errorf("ONENOTE_REDIRECT_URI is required")
        }</span>

        // Basic URL validation
        <span class="cov8" title="1">if !strings.HasPrefix(cfg.RedirectURI, "http://") &amp;&amp; !strings.HasPrefix(cfg.RedirectURI, "https://") </span><span class="cov0" title="0">{
                logger.Error("RedirectURI validation failed - invalid URL format", "redirect_uri", cfg.RedirectURI)
                return fmt.Errorf("ONENOTE_REDIRECT_URI must be a valid HTTP/HTTPS URL")
        }</span>
        <span class="cov8" title="1">logger.Debug("RedirectURI validation passed", "redirect_uri", cfg.RedirectURI)

        logger.Debug("Validating toolsets", "toolsets", cfg.Toolsets)
        if len(cfg.Toolsets) &gt; 0 </span><span class="cov8" title="1">{
                validToolsets := map[string]bool{
                        "notebooks": true,
                        "sections":  true,
                        "pages":     true,
                        "content":   true,
                }

                for i, toolset := range cfg.Toolsets </span><span class="cov8" title="1">{
                        cleanToolset := strings.TrimSpace(toolset)
                        if !validToolsets[cleanToolset] </span><span class="cov0" title="0">{
                                logger.Error("Toolset validation failed",
                                        "invalid_toolset", toolset,
                                        "index", i,
                                        "valid_options", []string{"notebooks", "sections", "pages", "content"})
                                return fmt.Errorf("invalid toolset: %s (valid options: notebooks, sections, pages, content)", toolset)
                        }</span>
                        <span class="cov8" title="1">logger.Debug("Toolset validated", "toolset", cleanToolset, "index", i)</span>
                }
                <span class="cov8" title="1">logger.Debug("All toolsets validation passed", "valid_toolsets", cfg.Toolsets)</span>
        } else<span class="cov0" title="0"> {
                logger.Debug("No toolsets specified - using default behavior")
        }</span>

        // Validate logging configuration values if present
        <span class="cov8" title="1">if cfg.LogLevel != "" </span><span class="cov8" title="1">{
                validLogLevels := []string{"DEBUG", "INFO", "WARN", "WARNING", "ERROR"}
                validLevel := false
                for _, level := range validLogLevels </span><span class="cov8" title="1">{
                        if strings.ToUpper(cfg.LogLevel) == level </span><span class="cov8" title="1">{
                                validLevel = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !validLevel </span><span class="cov0" title="0">{
                        logger.Warn("Invalid log level specified, will use default",
                                "specified_level", cfg.LogLevel,
                                "valid_levels", validLogLevels)
                }</span> else<span class="cov8" title="1"> {
                        logger.Debug("Log level validation passed", "log_level", cfg.LogLevel)
                }</span>
        }

        <span class="cov8" title="1">if cfg.ContentLogLevel != "" </span><span class="cov8" title="1">{
                validContentLevels := []string{"DEBUG", "INFO", "WARN", "WARNING", "ERROR", "OFF"}
                validLevel := false
                for _, level := range validContentLevels </span><span class="cov8" title="1">{
                        if strings.ToUpper(cfg.ContentLogLevel) == level </span><span class="cov8" title="1">{
                                validLevel = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !validLevel </span><span class="cov0" title="0">{
                        logger.Warn("Invalid content log level specified, will use default",
                                "specified_level", cfg.ContentLogLevel,
                                "valid_levels", validContentLevels)
                }</span> else<span class="cov8" title="1"> {
                        logger.Debug("Content log level validation passed", "content_log_level", cfg.ContentLogLevel)
                }</span>
        }

        // Validate authorization configuration if present
        <span class="cov8" title="1">if cfg.Authorization != nil </span><span class="cov8" title="1">{
                logger.Debug("Validating authorization configuration")
                if err := authorization.ValidateAuthorizationConfig(cfg.Authorization); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Authorization configuration validation failed", "error", err)
                        return fmt.Errorf("authorization configuration is invalid: %v", err)
                }</span>
                <span class="cov8" title="1">logger.Debug("Authorization configuration validation passed")</span>
        }

        <span class="cov8" title="1">logger.Debug("Configuration validation completed successfully")
        return nil</span>
}

// maskSensitiveData masks sensitive configuration values for logging
func maskSensitiveData(value string) string <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return "&lt;empty&gt;"
        }</span>
        <span class="cov8" title="1">if len(value) &lt;= 8 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov8" title="1">return value[:4] + "***" + value[len(value)-4:]</span>
}

// maskEnvironmentValue gets and masks an environment variable value for logging
func maskEnvironmentValue(envVar string) string <span class="cov8" title="1">{
        value := os.Getenv(envVar)
        if value == "" </span><span class="cov8" title="1">{
                return "&lt;not set&gt;"
        }</span>

        // Identify sensitive environment variables
        <span class="cov8" title="1">sensitiveVars := map[string]bool{
                "ONENOTE_CLIENT_ID":    true,
                "ONENOTE_TENANT_ID":    false, // Tenant IDs are not as sensitive
                "ONENOTE_REDIRECT_URI": false, // Redirect URIs are not sensitive
                "MCP_BEARER_TOKEN":     true,  // Bearer tokens are sensitive
        }

        if sensitive, exists := sensitiveVars[envVar]; exists &amp;&amp; sensitive </span><span class="cov8" title="1">{
                return maskSensitiveData(value)
        }</span>

        <span class="cov8" title="1">return value</span>
}

// getConfigSource determines the primary source of configuration
func getConfigSource() string <span class="cov8" title="1">{
        if os.Getenv("ONENOTE_MCP_CONFIG") != "" </span><span class="cov8" title="1">{
                return "json_file_with_env_overrides"
        }</span>
        <span class="cov8" title="1">return "environment_variables_only"</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// client.go - Core Microsoft Graph API client for OneNote operations.
//
// This file defines the Client struct and core infrastructure for interacting with OneNote
// via the Microsoft Graph API. It provides the foundation for OneNote operations including
// authentication, token management, and client initialization.
//
// Key Features:
// - Microsoft Graph SDK integration with custom authentication provider
// - Automatic token refresh with retry logic on authentication failures
// - Client struct definition and constructors
// - Token management and authentication provider implementation
//
// Usage Example:
//   graphClient := graph.NewClientWithTokenRefresh(accessToken, oauthConfig, tokenManager, tokenPath, config)
//
//   // Use the client for OneNote operations
//   notebooks, err := graphClient.ListNotebooks()
//   if err != nil {
//       logging.GraphLogger.Error("Failed to list notebooks", "error", err)
//   }

package graph

import (
        "context"
        "fmt"
        "path/filepath"

        abstractions "github.com/microsoft/kiota-abstractions-go"
        msgraphsdk "github.com/microsoftgraph/msgraph-sdk-go"
        msgraphsdkcore "github.com/microsoftgraph/msgraph-sdk-go-core"

        "github.com/gebl/onenote-mcp-server/internal/auth"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

const unknownPath = "unknown"

// Client handles Microsoft Graph API requests for OneNote.
// It provides methods to list, search, and manipulate notebooks, sections, pages, and page items.
type Client struct {
        GraphClient  *msgraphsdk.GraphServiceClient // Microsoft Graph SDK client
        AuthProvider *StaticTokenProvider           // Authentication provider for token updates
        AccessToken  string                         // OAuth2 access token
        OAuthConfig  *auth.OAuth2Config             // OAuth2 configuration for token refresh
        TokenManager *auth.TokenManager             // Token manager for refresh operations
        TokenPath    string                         // Path to save refreshed tokens
        Config       *Config                        // Configuration including default notebook name
}

// Config holds configuration values needed by the graph client
type Config struct {
        NotebookName string // Default notebook name from configuration
}

// NewClient creates a new Graph API client using the SDK's adapter pattern.
// accessToken: OAuth2 access token for Microsoft Graph API.
// Returns a pointer to a Client instance.
func NewClient(accessToken string) *Client <span class="cov8" title="1">{
        authProvider := &amp;StaticTokenProvider{AccessToken: accessToken}
        adapter, err := msgraphsdkcore.NewGraphRequestAdapterBase(authProvider, msgraphsdkcore.GraphClientOptions{
                GraphServiceVersion: "v1.0",
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to create GraphRequestAdapter: %v", err))</span>
        }
        <span class="cov8" title="1">client := msgraphsdk.NewGraphServiceClient(adapter)
        return &amp;Client{
                GraphClient: client,
                AccessToken: accessToken,
        }</span>
}

// NewClientWithTokenRefresh creates a new Graph API client with token refresh capabilities.
// accessToken: OAuth2 access token for Microsoft Graph API.
// oauthConfig: OAuth2 configuration for token refresh.
// tokenManager: Token manager for refresh operations.
// tokenPath: Path to save refreshed tokens.
// config: Configuration including default notebook name.
// Returns a pointer to a Client instance.
func NewClientWithTokenRefresh(accessToken string, oauthConfig *auth.OAuth2Config, tokenManager *auth.TokenManager, tokenPath string, config *Config) *Client <span class="cov8" title="1">{
        // Get absolute path for better debugging
        absTokenPath, err := filepath.Abs(tokenPath)
        if err != nil </span><span class="cov0" title="0">{
                logging.GraphLogger.Debug("Could not get absolute path for token file", "path", tokenPath, "error", err)
                absTokenPath = unknownPath
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("Creating Graph client with token refresh capability",
                "token_path", tokenPath,
                "abs_token_path", absTokenPath,
                "oauth_config_available", oauthConfig != nil,
                "token_manager_available", tokenManager != nil)

        authProvider := &amp;StaticTokenProvider{AccessToken: accessToken}
        
        logging.GraphLogger.Debug("Creating GraphRequestAdapter", 
                "auth_provider_nil", authProvider == nil,
                "access_token_empty", accessToken == "",
                "access_token_length", len(accessToken))
        
        adapter, err := msgraphsdkcore.NewGraphRequestAdapterBase(authProvider, msgraphsdkcore.GraphClientOptions{
                GraphServiceVersion: "v1.0",
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to create GraphRequestAdapter: %v", err))</span>
        }
        
        <span class="cov8" title="1">if adapter == nil </span><span class="cov0" title="0">{
                panic("GraphRequestAdapter is nil after creation")</span>
        }
        
        <span class="cov8" title="1">client := msgraphsdk.NewGraphServiceClient(adapter)
        if client == nil </span><span class="cov0" title="0">{
                panic("GraphServiceClient is nil after creation")</span>
        }
        
        <span class="cov8" title="1">logging.GraphLogger.Debug("Graph client created successfully", 
                "adapter_nil", adapter == nil,
                "client_nil", client == nil)
        return &amp;Client{
                GraphClient:  client,
                AuthProvider: authProvider,
                AccessToken:  accessToken,
                OAuthConfig:  oauthConfig,
                TokenManager: tokenManager,
                TokenPath:    tokenPath,
                Config:       config,
        }</span>
}

// StaticTokenProvider implements the AuthenticationProvider interface for a static token.
// Used with the Microsoft Graph Go SDK.
type StaticTokenProvider struct {
        AccessToken string
}

// AuthenticateRequest adds the Authorization header to the request.
func (s *StaticTokenProvider) AuthenticateRequest(ctx context.Context, request *abstractions.RequestInformation, additionalAuthenticationContext map[string]interface{}) error <span class="cov0" title="0">{
        if request == nil </span><span class="cov0" title="0">{
                logging.GraphLogger.Error("Request is nil in AuthenticateRequest")
                return fmt.Errorf("request cannot be nil")
        }</span>
        <span class="cov0" title="0">if request.Headers == nil </span><span class="cov0" title="0">{
                logging.GraphLogger.Error("Request headers is nil in AuthenticateRequest")
                return fmt.Errorf("request headers cannot be nil")
        }</span>
        <span class="cov0" title="0">if s.AccessToken == "" </span><span class="cov0" title="0">{
                logging.GraphLogger.Error("Access token is empty in AuthenticateRequest")
                return fmt.Errorf("access token cannot be empty")
        }</span>
        
        <span class="cov0" title="0">logging.GraphLogger.Debug("Adding authorization header", "token_length", len(s.AccessToken))
        request.Headers.Add("Authorization", "Bearer "+s.AccessToken)
        return nil</span>
}

// GetAuthorizationToken returns the static access token (for compatibility).
func (s *StaticTokenProvider) GetAuthorizationToken(ctx context.Context, scopes []string) (string, error) <span class="cov8" title="1">{
        return s.AccessToken, nil
}</span>

// UpdateAccessToken updates the access token in the StaticTokenProvider.
func (s *StaticTokenProvider) UpdateAccessToken(newToken string) <span class="cov8" title="1">{
        s.AccessToken = newToken
}</span>

// UpdateToken updates the access token in both the client and the auth provider.
func (c *Client) UpdateToken(newToken string) <span class="cov8" title="1">{
        c.AccessToken = newToken
        if c.AuthProvider != nil </span><span class="cov8" title="1">{
                c.AuthProvider.UpdateAccessToken(newToken)
        }</span>

        // If token is empty, clear the TokenManager as well
        <span class="cov8" title="1">if newToken == "" &amp;&amp; c.TokenManager != nil </span><span class="cov8" title="1">{
                logging.GraphLogger.Info("Clearing TokenManager due to empty access token")
                c.TokenManager.AccessToken = ""
                c.TokenManager.RefreshToken = ""
                c.TokenManager.Expiry = 0
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("Updated access token in Graph client", "empty", newToken == "")</span>
}

// GetDefaultNotebookID returns the ID of the default notebook specified in the config.
// If no default notebook is configured, it returns an error.
// NOTE: This method has been moved to the notebooks package to avoid circular dependencies.
// Use notebooks.GetDefaultNotebookID(client, config) instead.
func (c *Client) GetDefaultNotebookID() (string, error) <span class="cov8" title="1">{
        return "", fmt.Errorf("GetDefaultNotebookID has been moved to the notebooks package. Use notebooks.GetDefaultNotebookID(client, config) instead")
}</span>

// RefreshTokenIfNeeded checks if the token is expired and refreshes it if necessary.
func (c *Client) RefreshTokenIfNeeded() error <span class="cov8" title="1">{
        if c.TokenManager == nil || c.OAuthConfig == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("token manager or OAuth config not available")
        }</span>

        <span class="cov8" title="1">if !c.TokenManager.IsExpired() </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("Token is not expired, no refresh needed")
                return nil
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("Token is expired, refreshing")

        // Refresh the token
        newTokenManager, err := c.OAuthConfig.RefreshToken(context.Background(), c.TokenManager.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to refresh token: %v", err)
        }</span>

        // Update the token manager
        <span class="cov0" title="0">c.TokenManager.AccessToken = newTokenManager.AccessToken
        c.TokenManager.RefreshToken = newTokenManager.RefreshToken
        c.TokenManager.Expiry = newTokenManager.Expiry

        // Update the client's access token
        c.AccessToken = newTokenManager.AccessToken
        if c.AuthProvider != nil </span><span class="cov0" title="0">{
                c.AuthProvider.UpdateAccessToken(newTokenManager.AccessToken)
        }</span>

        // Save the new tokens
        <span class="cov0" title="0">if c.TokenPath != "" </span><span class="cov0" title="0">{
                // Get absolute path for better debugging
                absTokenPath, err := filepath.Abs(c.TokenPath)
                if err != nil </span><span class="cov0" title="0">{
                        logging.GraphLogger.Debug("Could not get absolute path for token file", "path", c.TokenPath, "error", err)
                        absTokenPath = unknownPath
                }</span>

                <span class="cov0" title="0">logging.GraphLogger.Debug("Saving refreshed tokens", "path", c.TokenPath, "abs_path", absTokenPath)
                if err := newTokenManager.SaveTokens(c.TokenPath); err != nil </span><span class="cov0" title="0">{
                        logging.GraphLogger.Warn("Failed to save refreshed tokens", "path", c.TokenPath, "abs_path", absTokenPath, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        logging.GraphLogger.Debug("Refreshed tokens saved successfully", "path", c.TokenPath, "abs_path", absTokenPath)
                }</span>
        } else<span class="cov0" title="0"> {
                logging.GraphLogger.Debug("No token path configured, skipping token save")
        }</span>

        <span class="cov0" title="0">logging.GraphLogger.Debug("Token refreshed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// http.go - HTTP utilities for Microsoft Graph API client.
//
// This file contains HTTP request and response handling utilities used across
// the Graph API client for making authenticated requests and processing responses.
//
// Key Features:
// - Authenticated HTTP request creation and execution
// - Response body reading and error handling
// - Content type extraction from responses
// - Token refresh integration for failed requests
//
// Usage Example:
//   resp, err := c.makeAuthenticatedRequest("GET", url, nil, nil)
//   if err != nil {
//       return nil, err
//   }
//   defer resp.Body.Close()
//
//   content, err := readResponseBody(resp, "operation")
//   if err != nil {
//       return nil, err
//   }

package graph

import (
        "fmt"
        "io"
        "net/http"

        "github.com/gebl/onenote-mcp-server/internal/auth"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// MakeAuthenticatedRequest creates and executes an authenticated HTTP request with token refresh support.
func (c *Client) MakeAuthenticatedRequest(method, url string, body io.Reader, headers map[string]string) (*http.Response, error) <span class="cov8" title="1">{
        logging.GraphLogger.Debug("Creating HTTP request", "method", method, "url", url)

        // Check if authentication has been cleared
        if c.AccessToken == "" || (c.TokenManager != nil &amp;&amp; c.TokenManager.AccessToken == "" &amp;&amp; c.TokenManager.RefreshToken == "") </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("No valid authentication tokens available")
                return nil, fmt.Errorf("authentication required: tokens have been cleared, use initiateAuth to re-authenticate")
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("Failed to create HTTP request", "error", err)
                return nil, err
        }</span>

        // Set custom headers if provided
        <span class="cov8" title="1">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("HTTP request created successfully")

        // Use the authenticated request method that handles token refresh
        logging.GraphLogger.Debug("Making authenticated request to Graph API")
        resp, err := auth.MakeAuthenticatedRequestWithCallback(req, c.AccessToken, c.OAuthConfig, c.TokenManager, c.TokenPath, c.UpdateToken)
        if err != nil </span><span class="cov0" title="0">{
                logging.GraphLogger.Debug("Authenticated request failed", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("Response received", "status", resp.StatusCode, "headers", resp.Header)
        return resp, nil</span>
}

// HandleHTTPResponse handles common HTTP response processing and error checking.
func (c *Client) HandleHTTPResponse(resp *http.Response, operation string) error <span class="cov8" title="1">{
        if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 201 &amp;&amp; resp.StatusCode != 204 </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                logging.GraphLogger.Debug("Error response body", "body", string(body))
                return fmt.Errorf("%s failed: HTTP %d - %s", operation, resp.StatusCode, string(body))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReadResponseBody reads the entire response body and returns it as bytes.
func (c *Client) ReadResponseBody(resp *http.Response, operation string) ([]byte, error) <span class="cov8" title="1">{
        content, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("Failed to read response body", "error", err)
                return nil, fmt.Errorf("failed to read %s response body: %v", operation, err)
        }</span>
        <span class="cov8" title="1">logging.GraphLogger.Debug("Successfully read response body", "bytes", len(content))
        return content, nil</span>
}

// GetContentTypeFromResponse extracts content type from HTTP response headers with fallback.
func (c *Client) GetContentTypeFromResponse(resp *http.Response) string <span class="cov8" title="1">{
        contentType := "application/octet-stream" // Default content type

        if resp.Header.Get("Content-Type") != "" </span><span class="cov8" title="1">{
                contentType = resp.Header.Get("Content-Type")
                logging.GraphLogger.Debug("Content type from HTTP headers", "content_type", contentType)
        }</span> else<span class="cov8" title="1"> {
                logging.GraphLogger.Debug("No Content-Type header found, using default", "content_type", contentType)
        }</span>

        <span class="cov8" title="1">return contentType</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// utils.go - Utility functions for Microsoft Graph API client.
//
// This file contains utility functions for ID sanitization, filename generation,
// and other common operations used across the Graph API client.
//
// Key Features:
// - OneNote ID validation and sanitization
// - Filename generation based on content type
// - Security-focused input validation
//
// Usage Example:
//   sanitizedID, err := sanitizeOneNoteID(id, "sectionID")
//   if err != nil {
//       return nil, err
//   }
//
//   filename := generateFilename(pageItemID, contentType)

package graph

import (
        "encoding/json"
        "fmt"
        "strings"

        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// SanitizeOneNoteID validates and sanitizes OneNote IDs to prevent injection attacks.
// OneNote IDs typically contain alphanumeric characters, hyphens, and exclamation marks.
// Example format: "0-4D24C77F19546939!40109"
func (c *Client) SanitizeOneNoteID(id, idType string) (string, error) <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("Empty ID provided", "id_type", idType)
                return "", fmt.Errorf("%s cannot be empty", idType)
        }</span>

        // Remove whitespace
        <span class="cov8" title="1">sanitizedID := strings.TrimSpace(id)

        // Validate that the ID contains only allowed characters
        allowedChars := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-!"
        for _, char := range sanitizedID </span><span class="cov8" title="1">{
                if !strings.ContainsRune(allowedChars, char) </span><span class="cov8" title="1">{
                        logging.GraphLogger.Debug("Invalid character in ID", "id_type", idType, "char", string(char))
                        return "", fmt.Errorf("%s contains invalid characters", idType)
                }</span>
        }

        // Additional validation: ensure it's not too long
        <span class="cov8" title="1">if len(sanitizedID) &gt; 100 </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("ID too long", "id_type", idType, "length", len(sanitizedID))
                return "", fmt.Errorf("%s is too long", idType)
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("Sanitized ID", "id_type", idType, "sanitized_id", sanitizedID)
        return sanitizedID, nil</span>
}

// GenerateFilename creates a filename based on page item ID and content type.
func (c *Client) GenerateFilename(pageItemID, contentType string) string <span class="cov8" title="1">{
        var filename string
        if strings.HasPrefix(contentType, "image/") </span><span class="cov8" title="1">{
                // Map content types to file extensions
                switch contentType </span>{
                case "image/jpeg":<span class="cov8" title="1">
                        filename = pageItemID + ".jpg"</span>
                case "image/png":<span class="cov8" title="1">
                        filename = pageItemID + ".png"</span>
                case "image/gif":<span class="cov8" title="1">
                        filename = pageItemID + ".gif"</span>
                case "image/webp":<span class="cov8" title="1">
                        filename = pageItemID + ".webp"</span>
                default:<span class="cov8" title="1">
                        filename = pageItemID + ".bin"</span>
                }
        } else<span class="cov8" title="1"> {
                filename = pageItemID + ".bin"
        }</span>

        <span class="cov8" title="1">logging.GraphLogger.Debug("Generated filename", "filename", filename)
        return filename</span>
}

// GetOnenoteOperation retrieves the status of an asynchronous OneNote operation.
// operationID: ID of the operation to check.
// Returns the operation status and metadata, and an error, if any.
func (c *Client) GetOnenoteOperation(operationID string) (map[string]interface{}, error) <span class="cov8" title="1">{
        logging.GraphLogger.Info("Getting OneNote operation status", "operation_id", operationID)

        // Validate and sanitize the operation ID
        sanitizedOperationID, err := c.SanitizeOneNoteID(operationID, "operationID")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Construct the URL for getting operation status
        <span class="cov8" title="1">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/operations/%s", sanitizedOperationID)
        logging.GraphLogger.Debug("Operation status URL", "url", url)

        // Make authenticated request using shared HTTP utilities for automatic resource cleanup
        content, err := httputils.SafeRequestWithBody(
                c.MakeAuthenticatedRequest,
                c.HandleHTTPResponse,
                c.ReadResponseBody,
                "GET", url, nil, nil,
                "GetOnenoteOperation",
        )
        if err != nil </span><span class="cov8" title="1">{
                logging.GraphLogger.Debug("Authenticated request failed", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.GraphLogger.Debug("Response body", "body", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.GraphLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse operation status response: %v", err)
        }</span>

        <span class="cov0" title="0">logging.GraphLogger.Info("Successfully retrieved operation status", "operation_id", operationID)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// helpers.go - Shared HTTP utilities for automatic resource cleanup and safe request handling.
//
// This module provides a centralized location for HTTP request utilities that eliminate
// manual defer resp.Body.Close() patterns throughout the codebase. By consolidating
// HTTP handling logic into reusable utilities, we achieve consistent error handling,
// automatic resource cleanup, and reduced code duplication.
//
// Architectural Benefits:
// - Clean separation of concerns with shared infrastructure
// - Both internal/graph and business logic layers can use the same utilities
// - Eliminates dependency cycles (graph doesn't depend on higher-level utils)
// - Ensures consistent HTTP handling patterns across all modules
//
// Key Features:
// - Automatic response body cleanup with guaranteed resource management
// - Error-safe request handling with proper cleanup on failures
// - Consistent HTTP error handling and response validation
// - Simplified API for common HTTP patterns (body reading, custom handlers)
// - Support for multiple request patterns and conditional logic
//
// Usage across modules:
// - internal/graph: Core HTTP client operations and utilities
// - internal/auth: OAuth token exchange and refresh operations
// - internal/pages: Page content operations and multipart requests
// - internal/sections: Section and section group management
//
// This eliminates 26+ instances of manual defer resp.Body.Close() patterns
// and ensures proper resource cleanup even in complex error scenarios.

package http

import (
        "fmt"
        "io"
        "net/http"
)

// HTTPRequestFunc represents a function that makes HTTP requests
type HTTPRequestFunc func(method, url string, body io.Reader, headers map[string]string) (*http.Response, error)

// HTTPResponseHandler represents a function that handles HTTP responses
type HTTPResponseHandler func(resp *http.Response, operation string) error

// HTTPBodyReader represents a function that reads response bodies
type HTTPBodyReader func(resp *http.Response, operation string) ([]byte, error)

// SafeHTTPClient wraps HTTP operations with automatic resource cleanup
type SafeHTTPClient struct {
        makeRequest   HTTPRequestFunc
        handleResponse HTTPResponseHandler
        readBody      HTTPBodyReader
}

// NewSafeHTTPClient creates a new SafeHTTPClient with the provided functions
func NewSafeHTTPClient(
        makeRequest HTTPRequestFunc,
        handleResponse HTTPResponseHandler,
        readBody HTTPBodyReader,
) *SafeHTTPClient <span class="cov8" title="1">{
        return &amp;SafeHTTPClient{
                makeRequest:   makeRequest,
                handleResponse: handleResponse,
                readBody:      readBody,
        }
}</span>

// SafeHTTPResponse wraps a response with automatic cleanup
type SafeHTTPResponse struct {
        resp   *http.Response
        closed bool
}

// StatusCode returns the HTTP status code
func (sr *SafeHTTPResponse) StatusCode() int <span class="cov8" title="1">{
        if sr.resp == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return sr.resp.StatusCode</span>
}

// Header returns the response headers
func (sr *SafeHTTPResponse) Header() http.Header <span class="cov8" title="1">{
        if sr.resp == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return sr.resp.Header</span>
}

// Body returns the response body (caller is responsible for closing)
func (sr *SafeHTTPResponse) Body() io.ReadCloser <span class="cov8" title="1">{
        if sr.resp == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return sr.resp.Body</span>
}

// Close ensures the response body is closed
func (sr *SafeHTTPResponse) Close() error <span class="cov8" title="1">{
        if !sr.closed &amp;&amp; sr.resp != nil &amp;&amp; sr.resp.Body != nil </span><span class="cov8" title="1">{
                sr.closed = true
                return sr.resp.Body.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ExecuteRequest makes an HTTP request with automatic cleanup
func (c *SafeHTTPClient) ExecuteRequest(
        method, url string,
        body io.Reader,
        headers map[string]string,
        operation string,
) (*SafeHTTPResponse, error) <span class="cov8" title="1">{
        resp, err := c.makeRequest(method, url, body, headers)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">safeResp := &amp;SafeHTTPResponse{resp: resp}

        // Handle HTTP response validation
        if c.handleResponse != nil </span><span class="cov8" title="1">{
                if err := c.handleResponse(resp, operation); err != nil </span><span class="cov8" title="1">{
                        safeResp.Close() // Ensure cleanup on error
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return safeResp, nil</span>
}

// ExecuteAndReadBody makes a request and reads the body, with automatic cleanup
func (c *SafeHTTPClient) ExecuteAndReadBody(
        method, url string,
        body io.Reader,
        headers map[string]string,
        operation string,
) ([]byte, error) <span class="cov8" title="1">{
        resp, err := c.makeRequest(method, url, body, headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close() // Safe to use defer here since it's encapsulated

        // Handle HTTP response validation
        if c.handleResponse != nil </span><span class="cov8" title="1">{
                if err := c.handleResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Read response body
        <span class="cov8" title="1">if c.readBody != nil </span><span class="cov8" title="1">{
                return c.readBody(resp, operation)
        }</span>

        // Fallback to direct body reading
        <span class="cov8" title="1">return io.ReadAll(resp.Body)</span>
}

// ExecuteMultipleRequests executes multiple HTTP requests and ensures all are cleaned up
func (c *SafeHTTPClient) ExecuteMultipleRequests(
        requests []HTTPRequestSpec,
        operation string,
) ([]*SafeHTTPResponse, error) <span class="cov8" title="1">{
        var responses []*SafeHTTPResponse
        var cleanupResponses = func() </span><span class="cov8" title="1">{
                for _, resp := range responses </span><span class="cov8" title="1">{
                        if resp != nil </span><span class="cov8" title="1">{
                                resp.Close()
                        }</span>
                }
        }

        <span class="cov8" title="1">for i, req := range requests </span><span class="cov8" title="1">{
                resp, err := c.ExecuteRequest(req.Method, req.URL, req.Body, req.Headers, 
                        fmt.Sprintf("%s_request_%d", operation, i))
                if err != nil </span><span class="cov8" title="1">{
                        cleanupResponses() // Clean up all previous responses
                        return nil, err
                }</span>
                <span class="cov8" title="1">responses = append(responses, resp)</span>
        }

        <span class="cov8" title="1">return responses, nil</span>
}

// HTTPRequestSpec defines a single HTTP request specification
type HTTPRequestSpec struct {
        Method  string
        URL     string
        Body    io.Reader
        Headers map[string]string
}

// WithAutoCleanup executes a function with a response and ensures cleanup
func WithAutoCleanup(resp *http.Response, fn func(*http.Response) error) error <span class="cov8" title="1">{
        if resp == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("nil response provided")
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        return fn(resp)</span>
}

// SafeRequest executes an HTTP request with automatic cleanup and error handling
func SafeRequest(
        makeRequest HTTPRequestFunc,
        handleResponse HTTPResponseHandler,
        method, url string,
        body io.Reader,
        headers map[string]string,
        operation string,
) error <span class="cov8" title="1">{
        resp, err := makeRequest(method, url, body, headers)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if handleResponse != nil </span><span class="cov8" title="1">{
                return handleResponse(resp, operation)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SafeRequestWithBody executes a request and returns the response body with automatic cleanup
func SafeRequestWithBody(
        makeRequest HTTPRequestFunc,
        handleResponse HTTPResponseHandler,
        readBody HTTPBodyReader,
        method, url string,
        body io.Reader,
        headers map[string]string,
        operation string,
) ([]byte, error) <span class="cov8" title="1">{
        resp, err := makeRequest(method, url, body, headers)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if handleResponse != nil </span><span class="cov8" title="1">{
                if err := handleResponse(resp, operation); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if readBody != nil </span><span class="cov8" title="1">{
                return readBody(resp, operation)
        }</span>

        <span class="cov8" title="1">return io.ReadAll(resp.Body)</span>
}

// SafeRequestWithCustomHandler executes a request with a custom response handler and automatic cleanup
func SafeRequestWithCustomHandler(
        makeRequest HTTPRequestFunc,
        handler func(*http.Response) error,
        method, url string,
        body io.Reader,
        headers map[string]string,
) error <span class="cov8" title="1">{
        resp, err := makeRequest(method, url, body, headers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        return handler(resp)</span>
}

// ConditionalRequest makes a request with conditional logic and automatic cleanup
func ConditionalRequest(
        makeRequest HTTPRequestFunc,
        condition func(*http.Response) bool,
        onSuccess func(*http.Response) error,
        onFailure func(*http.Response) error,
        method, url string,
        body io.Reader,
        headers map[string]string,
) error <span class="cov8" title="1">{
        resp, err := makeRequest(method, url, body, headers)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if condition(resp) </span><span class="cov8" title="1">{
                if onSuccess != nil </span><span class="cov8" title="1">{
                        return onSuccess(resp)
                }</span>
        } else<span class="cov8" title="1"> {
                if onFailure != nil </span><span class="cov8" title="1">{
                        return onFailure(resp)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// TryMultipleEndpoints tries multiple HTTP endpoints until one succeeds, with automatic cleanup
func TryMultipleEndpoints(
        makeRequest HTTPRequestFunc,
        handleResponse HTTPResponseHandler,
        readBody HTTPBodyReader,
        endpoints []HTTPRequestSpec,
        operation string,
) ([]byte, error) <span class="cov8" title="1">{
        var lastErr error

        for i, endpoint := range endpoints </span><span class="cov8" title="1">{
                resp, err := makeRequest(endpoint.Method, endpoint.URL, endpoint.Body, endpoint.Headers)
                if err != nil </span><span class="cov8" title="1">{
                        lastErr = err
                        continue</span>
                }

                // Use the WithAutoCleanup helper to ensure proper cleanup
                <span class="cov8" title="1">var bodyData []byte
                err = WithAutoCleanup(resp, func(r *http.Response) error </span><span class="cov8" title="1">{
                        if handleResponse != nil </span><span class="cov8" title="1">{
                                if err := handleResponse(r, fmt.Sprintf("%s_endpoint_%d", operation, i)); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">if readBody != nil </span><span class="cov0" title="0">{
                                data, err := readBody(r, operation)
                                bodyData = data
                                return err
                        }</span>

                        <span class="cov8" title="1">data, err := io.ReadAll(r.Body)
                        bodyData = data
                        return err</span>
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        lastErr = err
                        continue</span>
                }

                <span class="cov8" title="1">return bodyData, nil</span>
        }

        <span class="cov8" title="1">if lastErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("all endpoints failed, last error: %v", lastErr)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("no endpoints provided")</span>
}</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// logging.go - Centralized logging configuration for the OneNote MCP server.
//
// This package provides a structured logging solution using Go's slog package
// with configurable log levels, structured output, and component-based loggers.
//
// Key Features:
// - Structured logging with key-value pairs
// - Configurable log levels (DEBUG, INFO, WARN, ERROR)
// - Component-based loggers with automatic prefixing
// - Environment-based configuration
// - Performance optimized with lazy evaluation
// - Support for both text and JSON output formats
//
// Usage:
//   logger := logging.GetLogger("auth")
//   logger.Info("Authentication started", "user_id", userID)
//   logger.Debug("Token details", "expires_in", tokenExpiry)
//   logger.Error("Authentication failed", "error", err)
//
// Configuration:
// - LOG_LEVEL: Set to DEBUG, INFO, WARN, or ERROR (default: INFO)
// - LOG_FORMAT: Set to "json" for JSON output, "text" for human-readable (default: text)
// - MCP_LOG_FILE: Optional file path for log output
// - CONTENT_LOG_LEVEL: Set verbosity for content logging - DEBUG, INFO, WARN, ERROR, or OFF (default: DEBUG during development)

package logging

import (
        "context"
        "io"
        "log/slog"
        "os"
        "strings"
)

var (
        defaultLogger   *slog.Logger
        logLevel        slog.Level = slog.LevelDebug // Start with maximum verbosity until config is loaded
        contentLogLevel slog.Level = slog.LevelDebug // Default to DEBUG during development
)

// Initialize sets up the global logger configuration based on environment variables
// This is used for early initialization before config loading
// IMPORTANT: Defaults to DEBUG level to capture all config loading details
func Initialize() <span class="cov8" title="1">{
        InitializeFromEnv()
}</span>

// InitializeFromEnv sets up logging from environment variables only
// Used during early startup before config object is available
// IMPORTANT: Defaults to DEBUG level to capture all config loading details
func InitializeFromEnv() <span class="cov8" title="1">{
        // Determine log level from environment
        levelStr := strings.ToUpper(os.Getenv("LOG_LEVEL"))
        switch levelStr </span>{
        case "DEBUG":<span class="cov8" title="1">
                logLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov8" title="1">
                logLevel = slog.LevelInfo</span>
        case "WARN", "WARNING":<span class="cov8" title="1">
                logLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov8" title="1">
                logLevel = slog.LevelError</span>
        default:<span class="cov8" title="1">
                // Default to DEBUG during early initialization to capture config loading details
                logLevel = slog.LevelDebug</span>
        }

        // Determine content logging level from environment
        <span class="cov8" title="1">contentLevelStr := strings.ToUpper(os.Getenv("CONTENT_LOG_LEVEL"))
        switch contentLevelStr </span>{
        case "DEBUG":<span class="cov8" title="1">
                contentLogLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov8" title="1">
                contentLogLevel = slog.LevelInfo</span>
        case "WARN", "WARNING":<span class="cov8" title="1">
                contentLogLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov8" title="1">
                contentLogLevel = slog.LevelError</span>
        case "OFF":<span class="cov8" title="1">
                contentLogLevel = slog.Level(1000)</span> // Very high level to effectively disable
        default:<span class="cov8" title="1">
                contentLogLevel = slog.LevelDebug</span> // Default to DEBUG during development
        }

        // Determine output destination
        <span class="cov8" title="1">var output io.Writer = os.Stderr
        if logFile := os.Getenv("MCP_LOG_FILE"); logFile != "" </span><span class="cov8" title="1">{
                file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov8" title="1">{
                        // Fallback to stderr and log the error
                        slog.Error("Failed to open log file, using stderr", "file", logFile, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        output = file
                }</span>
        }

        // Determine log format
        <span class="cov8" title="1">var handler slog.Handler
        format := strings.ToLower(os.Getenv("LOG_FORMAT"))
        if format == "json" </span><span class="cov8" title="1">{
                handler = slog.NewJSONHandler(output, &amp;slog.HandlerOptions{
                        Level: logLevel,
                })
        }</span> else<span class="cov8" title="1"> {
                handler = slog.NewTextHandler(output, &amp;slog.HandlerOptions{
                        Level: logLevel,
                })
        }</span>

        <span class="cov8" title="1">defaultLogger = slog.New(handler)
        slog.SetDefault(defaultLogger)</span>
}

// LoggingConfig interface defines the structure for logging configuration
type LoggingConfig interface {
        GetLogLevel() string
        GetLogFormat() string
        GetLogFile() string
        GetContentLogLevel() string
}

// InitializeFromConfig reinitializes logging based on configuration object
// This is called after config loading to apply any settings from config files
// Note: This may reduce verbosity from the initial DEBUG level used during config loading
func InitializeFromConfig(cfg LoggingConfig) <span class="cov8" title="1">{
        // Log the transition from initial config loading verbosity to final config
        if defaultLogger != nil </span><span class="cov8" title="1">{
                defaultLogger.Debug("Transitioning from config loading verbosity to final logging configuration")
        }</span>

        // Use config values, falling back to environment variables if config values are empty
        <span class="cov8" title="1">logLevelStr := cfg.GetLogLevel()
        if logLevelStr == "" </span><span class="cov8" title="1">{
                logLevelStr = os.Getenv("LOG_LEVEL")
        }</span>

        <span class="cov8" title="1">logFormatStr := cfg.GetLogFormat()
        if logFormatStr == "" </span><span class="cov8" title="1">{
                logFormatStr = os.Getenv("LOG_FORMAT")
        }</span>

        <span class="cov8" title="1">logFileStr := cfg.GetLogFile()
        if logFileStr == "" </span><span class="cov8" title="1">{
                logFileStr = os.Getenv("MCP_LOG_FILE")
        }</span>

        <span class="cov8" title="1">contentLogLevelStr := cfg.GetContentLogLevel()
        if contentLogLevelStr == "" </span><span class="cov8" title="1">{
                contentLogLevelStr = os.Getenv("CONTENT_LOG_LEVEL")
        }</span>

        // Parse log level
        <span class="cov8" title="1">switch strings.ToUpper(logLevelStr) </span>{
        case "DEBUG":<span class="cov8" title="1">
                logLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "WARN", "WARNING":<span class="cov8" title="1">
                logLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov8" title="1">
                // After config loading, default to INFO level (less verbose than initial DEBUG)
                logLevel = slog.LevelInfo</span>
        }

        // Parse content log level
        <span class="cov8" title="1">switch strings.ToUpper(contentLogLevelStr) </span>{
        case "DEBUG":<span class="cov8" title="1">
                contentLogLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov8" title="1">
                contentLogLevel = slog.LevelInfo</span>
        case "WARN", "WARNING":<span class="cov0" title="0">
                contentLogLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov8" title="1">
                contentLogLevel = slog.LevelError</span>
        case "OFF":<span class="cov0" title="0">
                contentLogLevel = slog.Level(1000)</span> // Very high level to effectively disable
        default:<span class="cov8" title="1">
                contentLogLevel = slog.LevelDebug</span> // Default to DEBUG during development
        }

        // Determine output destination
        <span class="cov8" title="1">var output io.Writer = os.Stderr
        if logFileStr != "" </span><span class="cov0" title="0">{
                file, err := os.OpenFile(logFileStr, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to stderr and log the error
                        if defaultLogger != nil </span><span class="cov0" title="0">{
                                defaultLogger.Error("Failed to open log file, using stderr", "file", logFileStr, "error", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        output = file
                }</span>
        }

        // Determine log format
        <span class="cov8" title="1">var handler slog.Handler
        if strings.ToLower(logFormatStr) == "json" </span><span class="cov0" title="0">{
                handler = slog.NewJSONHandler(output, &amp;slog.HandlerOptions{
                        Level: logLevel,
                })
        }</span> else<span class="cov8" title="1"> {
                handler = slog.NewTextHandler(output, &amp;slog.HandlerOptions{
                        Level: logLevel,
                })
        }</span>

        <span class="cov8" title="1">defaultLogger = slog.New(handler)
        slog.SetDefault(defaultLogger)

        // Log the final logging configuration
        defaultLogger.Debug("Logging reconfigured from config",
                "final_log_level", logLevel.String(),
                "final_content_log_level", contentLogLevel.String(),
                "log_format", strings.ToLower(logFormatStr),
                "log_file", logFileStr,
                "config_source", "configuration_object")</span>
}

// GetLogger returns a component-specific logger with the given component name
// The component name will be included in all log entries for easier filtering
func GetLogger(component string) *slog.Logger <span class="cov8" title="1">{
        if defaultLogger == nil </span><span class="cov8" title="1">{
                Initialize()
        }</span>
        <span class="cov8" title="1">return defaultLogger.With("component", component)</span>
}

// GetLevel returns the current log level
func GetLevel() slog.Level <span class="cov8" title="1">{
        return logLevel
}</span>

// IsDebugEnabled returns true if debug logging is enabled
func IsDebugEnabled() bool <span class="cov8" title="1">{
        return logLevel &lt;= slog.LevelDebug
}</span>

// IsContentLoggingEnabled returns true if content logging is enabled at the specified level
func IsContentLoggingEnabled(level slog.Level) bool <span class="cov8" title="1">{
        return contentLogLevel &lt;= level
}</span>

// GetContentLogLevel returns the current content log level
func GetContentLogLevel() slog.Level <span class="cov8" title="1">{
        return contentLogLevel
}</span>

// SetLevel sets the log level programmatically (useful for testing)
func SetLevel(level slog.Level) <span class="cov8" title="1">{
        logLevel = level
        Initialize() // Reinitialize with new level
}</span>

// SetContentLogLevel sets the content log level programmatically
func SetContentLogLevel(level slog.Level) <span class="cov8" title="1">{
        contentLogLevel = level
}</span>

// LogContent conditionally logs content based on the content logging configuration
// This is a convenience function to avoid checking content logging level in every location
func LogContent(logger *slog.Logger, level slog.Level, msg string, args ...any) <span class="cov8" title="1">{
        if IsContentLoggingEnabled(level) </span><span class="cov8" title="1">{
                logger.Log(context.Background(), level, msg, args...)
        }</span>
}

// Component-specific logger instances for commonly used components
var (
        AuthLogger          = GetLogger("auth")
        AuthorizationLogger = GetLogger("authorization")
        ConfigLogger        = GetLogger("config")
        GraphLogger         = GetLogger("graph")
        NotebookLogger      = GetLogger("notebook")
        PageLogger          = GetLogger("page")
        SectionLogger       = GetLogger("section")
        ToolsLogger         = GetLogger("tools")
        UtilsLogger         = GetLogger("utils")
        MainLogger          = GetLogger("main")
)
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// notebooks.go - Notebook operations for the Microsoft Graph API client.
//
// This file contains all notebook-related operations including listing notebooks,
// searching within notebooks, and other notebook management functions.
//
// Key Features:
// - List all OneNote notebooks for the authenticated user with pagination
// - Search pages within notebooks with recursive traversal
// - Comprehensive notebook structure exploration
// - Automatic pagination handling for large notebook collections
//
// Operations Supported:
// - ListNotebooks: List all notebooks with automatic pagination
// - SearchPages: Search pages by title within a specific notebook
// - searchPagesRecursively: Internal function for recursive search
// - extractNotebookList: Helper function to extract notebook data
//
// Usage Example:
//   notebooks, err := graphClient.ListNotebooks()
//   if err != nil {
//       logging.NotebookLogger.Error("Failed to list notebooks", "error", err)
//   }
//
//   results, err := graphClient.SearchPages("meeting", notebookID)
//   if err != nil {
//       logging.NotebookLogger.Error("Failed to search pages", "error", err)
//   }

package notebooks

import (
        "context"
        "fmt"
        "strings"

        abstractions "github.com/microsoft/kiota-abstractions-go"
        msgraphmodels "github.com/microsoftgraph/msgraph-sdk-go/models"

        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/pages"
        "github.com/gebl/onenote-mcp-server/internal/sections"
)

// NotebookClient provides notebook operations for the Graph API client
type NotebookClient struct {
        *graph.Client
}

// NewNotebookClient creates a new notebook client
func NewNotebookClient(client *graph.Client) *NotebookClient <span class="cov8" title="1">{
        return &amp;NotebookClient{Client: client}
}</span>

// ListNotebooks lists all OneNote notebooks for the authenticated user.
// Returns an array of notebook objects with ID and display name.
// This function handles pagination using the SDK's nextLink mechanism.
func (c *NotebookClient) ListNotebooks() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Info("Listing notebooks using Microsoft Graph SDK with paging")

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        result, err := c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
        logging.NotebookLogger.Debug("SDK result", "result", result)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Auth error detected in SDK call, attempting token refresh")
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Token refresh failed", "error", refreshErr)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">result, err = c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var notebooks []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                notebooks = append(notebooks, extractNotebookList(result)...)
        }</span>
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        for nextLink != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Fetching next page of notebooks", "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateNotebookCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch next page of notebooks: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.NotebookCollectionResponseable)
                notebooks = append(notebooks, extractNotebookList(pageResp)...)
                nextLink = pageResp.GetOdataNextLink()</span>
        }
        <span class="cov0" title="0">logging.NotebookLogger.Debug("Parsed notebooks", "notebooks", notebooks)
        logging.NotebookLogger.Info("Found notebooks", "count", len(notebooks))

        // Ensure we always return a slice, even if empty
        if notebooks == nil </span><span class="cov0" title="0">{
                notebooks = []map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">return notebooks, nil</span>
}

// ListNotebooksDetailed lists all OneNote notebooks for the authenticated user with full metadata.
// Returns an array of notebook objects with comprehensive details including timestamps, links, ownership, and metadata.
// This function handles pagination using the SDK's nextLink mechanism.
func (c *NotebookClient) ListNotebooksDetailed() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Info("Listing notebooks with detailed information using Microsoft Graph SDK with paging")

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        
        // Add debugging to understand why we're getting ArgumentNull error
        logging.NotebookLogger.Debug("About to call Graph SDK", 
                "graph_client_nil", c.GraphClient == nil,
                "access_token_empty", c.AccessToken == "",
                "access_token_length", len(c.AccessToken))
        
        if c.GraphClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphClient is nil")
        }</span>
        
        <span class="cov0" title="0">result, err := c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
        logging.NotebookLogger.Debug("SDK result for detailed notebooks", "result", result)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Auth error detected in SDK call, attempting token refresh")
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Token refresh failed", "error", refreshErr)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">result, err = c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var notebooks []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                notebooks = append(notebooks, extractDetailedNotebookList(result)...)
        }</span>
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        for nextLink != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Fetching next page of detailed notebooks", "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateNotebookCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch next page of detailed notebooks: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.NotebookCollectionResponseable)
                notebooks = append(notebooks, extractDetailedNotebookList(pageResp)...)
                nextLink = pageResp.GetOdataNextLink()</span>
        }
        <span class="cov0" title="0">logging.NotebookLogger.Debug("Parsed detailed notebooks", "notebooks", notebooks)
        logging.NotebookLogger.Info("Found detailed notebooks", "count", len(notebooks))

        // Ensure we always return a slice, even if empty
        if notebooks == nil </span><span class="cov0" title="0">{
                notebooks = []map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">return notebooks, nil</span>
}

// GetDetailedNotebookByName retrieves comprehensive notebook information by display name.
// Returns all available attributes including timestamps, links, ownership, and metadata.
func (c *NotebookClient) GetDetailedNotebookByName(notebookName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Info("Getting detailed notebook information by name", "notebook_name", notebookName)

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        result, err := c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Auth error detected in SDK call, attempting token refresh")
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Token refresh failed", "error", refreshErr)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">result, err = c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        // Process all pages of results to find the notebook by name
        <span class="cov0" title="0">var allNotebooks []msgraphmodels.Notebookable
        if result != nil </span><span class="cov0" title="0">{
                allNotebooks = append(allNotebooks, result.GetValue()...)
        }</span>

        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        for nextLink != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Fetching next page of notebooks for detailed search", "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateNotebookCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch next page of notebooks: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.NotebookCollectionResponseable)
                allNotebooks = append(allNotebooks, pageResp.GetValue()...)
                nextLink = pageResp.GetOdataNextLink()</span>
        }

        // Search for the notebook by name (case-insensitive)
        <span class="cov0" title="0">for _, nb := range allNotebooks </span><span class="cov0" title="0">{
                if nb.GetDisplayName() != nil &amp;&amp; strings.EqualFold(*nb.GetDisplayName(), notebookName) </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Found notebook by name", "notebook_name", notebookName, "id", *nb.GetId())

                        // Extract detailed information for this notebook
                        detailedInfo := extractDetailedNotebookInfo(nb)

                        logging.NotebookLogger.Info("Retrieved detailed notebook information", "notebook_name", notebookName, "attributes_count", len(detailedInfo))
                        return detailedInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("notebook with name '%s' not found", notebookName)</span>
}

// extractNotebookList extracts notebook info from a NotebookCollectionResponseable
func extractNotebookList(result msgraphmodels.NotebookCollectionResponseable) []map[string]interface{} <span class="cov0" title="0">{
        var notebooks []map[string]interface{}
        for _, nb := range result.GetValue() </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                if nb.GetId() != nil </span><span class="cov0" title="0">{
                        m["notebookId"] = *nb.GetId()
                }</span>
                <span class="cov0" title="0">if nb.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        m["displayName"] = *nb.GetDisplayName()
                }</span>
                <span class="cov0" title="0">notebooks = append(notebooks, m)</span>
        }
        <span class="cov0" title="0">return notebooks</span>
}

// extractDetailedNotebookList extracts comprehensive notebook info with all available attributes
func extractDetailedNotebookList(result msgraphmodels.NotebookCollectionResponseable) []map[string]interface{} <span class="cov0" title="0">{
        var notebooks []map[string]interface{}
        for _, nb := range result.GetValue() </span><span class="cov0" title="0">{
                m := extractDetailedNotebookInfo(nb)
                notebooks = append(notebooks, m)
        }</span>
        <span class="cov0" title="0">return notebooks</span>
}

// extractDetailedNotebookInfo extracts all available attributes from a single notebook
func extractDetailedNotebookInfo(nb msgraphmodels.Notebookable) map[string]interface{} <span class="cov0" title="0">{
        m := map[string]interface{}{}

        // Basic properties
        if nb.GetId() != nil </span><span class="cov0" title="0">{
                m["id"] = *nb.GetId()
                m["notebookId"] = *nb.GetId() // Keep backward compatibility
        }</span>
        <span class="cov0" title="0">if nb.GetDisplayName() != nil </span><span class="cov0" title="0">{
                m["displayName"] = *nb.GetDisplayName()
        }</span>

        // Timestamps
        <span class="cov0" title="0">if nb.GetCreatedDateTime() != nil </span><span class="cov0" title="0">{
                m["createdDateTime"] = nb.GetCreatedDateTime().Format("2006-01-02T15:04:05Z")
        }</span>
        <span class="cov0" title="0">if nb.GetLastModifiedDateTime() != nil </span><span class="cov0" title="0">{
                m["lastModifiedDateTime"] = nb.GetLastModifiedDateTime().Format("2006-01-02T15:04:05Z")
        }</span>

        // Metadata properties
        <span class="cov0" title="0">if nb.GetIsDefault() != nil </span><span class="cov0" title="0">{
                m["isDefault"] = *nb.GetIsDefault()
        }</span>
        <span class="cov0" title="0">if nb.GetIsShared() != nil </span><span class="cov0" title="0">{
                m["isShared"] = *nb.GetIsShared()
        }</span>
        <span class="cov0" title="0">if nb.GetUserRole() != nil </span><span class="cov0" title="0">{
                m["userRole"] = nb.GetUserRole().String()
        }</span>

        // Note: Links and API endpoints are excluded from the response

        // Identity information
        <span class="cov0" title="0">if createdBy := nb.GetCreatedBy(); createdBy != nil </span><span class="cov0" title="0">{
                createdByMap := extractIdentitySet(createdBy)
                if len(createdByMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["createdBy"] = createdByMap
                }</span>
        }
        <span class="cov0" title="0">if lastModifiedBy := nb.GetLastModifiedBy(); lastModifiedBy != nil </span><span class="cov0" title="0">{
                lastModifiedByMap := extractIdentitySet(lastModifiedBy)
                if len(lastModifiedByMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["lastModifiedBy"] = lastModifiedByMap
                }</span>
        }

        <span class="cov0" title="0">return m</span>
}

// extractIdentitySet extracts identity information from an IdentitySet
func extractIdentitySet(identitySet msgraphmodels.IdentitySetable) map[string]interface{} <span class="cov0" title="0">{
        m := map[string]interface{}{}

        if user := identitySet.GetUser(); user != nil </span><span class="cov0" title="0">{
                userMap := map[string]interface{}{}
                if user.GetId() != nil </span><span class="cov0" title="0">{
                        userMap["id"] = *user.GetId()
                }</span>
                <span class="cov0" title="0">if user.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        userMap["displayName"] = *user.GetDisplayName()
                }</span>
                <span class="cov0" title="0">if len(userMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["user"] = userMap
                }</span>
        }

        <span class="cov0" title="0">if application := identitySet.GetApplication(); application != nil </span><span class="cov0" title="0">{
                appMap := map[string]interface{}{}
                if application.GetId() != nil </span><span class="cov0" title="0">{
                        appMap["id"] = *application.GetId()
                }</span>
                <span class="cov0" title="0">if application.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        appMap["displayName"] = *application.GetDisplayName()
                }</span>
                <span class="cov0" title="0">if len(appMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["application"] = appMap
                }</span>
        }

        <span class="cov0" title="0">if device := identitySet.GetDevice(); device != nil </span><span class="cov0" title="0">{
                deviceMap := map[string]interface{}{}
                if device.GetId() != nil </span><span class="cov0" title="0">{
                        deviceMap["id"] = *device.GetId()
                }</span>
                <span class="cov0" title="0">if device.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        deviceMap["displayName"] = *device.GetDisplayName()
                }</span>
                <span class="cov0" title="0">if len(deviceMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["device"] = deviceMap
                }</span>
        }

        <span class="cov0" title="0">return m</span>
}

// SearchPages searches for pages by title within a specific notebook.
// This function recursively searches through all sections and section groups.
// Returns an array of matching pages with section context information.
//
// Parameters:
// - query: the search string to match in page titles (case-insensitive)
// - notebookID: the ID of the notebook to search within
//
// Returns:
// - pageId: unique identifier for the page
// - pageTitle: title of the page
// - sectionId: ID of the section containing the page
// - sectionName: name of the section containing the page
// - sectionPath: full hierarchy path (e.g., "Notebook/Section Group/Section")
func (c *NotebookClient) SearchPages(query string, notebookID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Debug("Starting SearchPages", "query", query, "notebook_id", notebookID)
        logging.NotebookLogger.Info("Searching pages", "query", query, "notebook_id", notebookID)

        // Check token status
        if c.TokenManager != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token manager available, checking token expiration")
                if c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                        if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                                logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                                return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                        }</span>
                        <span class="cov0" title="0">logging.NotebookLogger.Debug("Token refresh completed successfully")</span>
                } else<span class="cov0" title="0"> {
                        logging.NotebookLogger.Debug("Token is still valid, no refresh needed")
                }</span>
        } else<span class="cov0" title="0"> {
                logging.NotebookLogger.Debug("No token manager available, using static token")
        }</span>

        // Sanitize the notebook ID
        <span class="cov0" title="0">sanitizedNotebookID, err := c.Client.SanitizeOneNoteID(notebookID, "notebookID")
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Invalid notebook ID", "error", err)
                return nil, err
        }</span>

        // First, get all sections in the notebook
        <span class="cov0" title="0">logging.NotebookLogger.Debug("Fetching sections for notebook", "notebook_id", sanitizedNotebookID)
        sections, err := c.ListSections(sanitizedNotebookID)
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to fetch sections", "error", err)
                return nil, fmt.Errorf("failed to fetch sections for notebook %s: %v", notebookID, err)
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Found sections in notebook", "count", len(sections))

        // Recursively search all sections and section groups
        var allPages []map[string]interface{}

        // Start recursive search from the notebook
        notebookPages, err := c.searchPagesRecursively(sanitizedNotebookID, query, "notebook", "")
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to search notebook recursively", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">allPages = append(allPages, notebookPages...)
        logging.NotebookLogger.Debug("Found total pages in notebook search", "count", len(allPages))

        logging.NotebookLogger.Info("Found pages matching query", "count", len(allPages), "query", query, "notebook_id", notebookID)

        return allPages, nil</span>
}

// searchPagesRecursively searches for pages recursively through sections and section groups.
// This function traverses the entire container hierarchy, searching all sections and
// recursively exploring section groups to find pages that match the query.
//
// Parameters:
// - containerID: the ID of the container (notebook or section group) to search
// - query: the search string to match in page titles (case-insensitive)
// - containerType: human-readable type for logging ("notebook" or "section group")
// - parentPath: the hierarchy path leading to this container
//
// Returns a slice of page metadata maps with section context and an error, if any.
func (c *NotebookClient) searchPagesRecursively(containerID, query, containerType, parentPath string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Debug("Searching recursively", "container_type", containerType, "container_id", containerID, "path", parentPath)

        var allPages []map[string]interface{}

        // Get sections in this container
        sections, err := c.ListSections(containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to get sections", "container_type", containerType, "container_id", containerID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Found sections", "count", len(sections), "container_type", containerType, "container_id", containerID)

        // Search pages in each section
        for i, section := range sections </span><span class="cov0" title="0">{
                sectionID, ok := section["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Section has no valid ID, skipping", "index", i+1)
                        continue</span>
                }

                <span class="cov0" title="0">sectionName, _ := section["displayName"].(string)
                sectionPath := parentPath + "/" + sectionName
                logging.NotebookLogger.Debug("Searching section", "name", sectionName, "id", sectionID, "path", sectionPath)

                // Get all pages in this section
                sectionPages, errPages := c.ListPages(sectionID)
                if errPages != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to get pages in section", "section_id", sectionID, "error", errPages)
                        continue</span>
                }

                <span class="cov0" title="0">logging.NotebookLogger.Debug("Found pages in section", "count", len(sectionPages), "section_name", sectionName)

                // Filter pages by title
                queryLower := strings.ToLower(query)
                for _, page := range sectionPages </span><span class="cov0" title="0">{
                        if title, ok := page["title"].(string); ok </span><span class="cov0" title="0">{
                                titleLower := strings.ToLower(title)
                                if strings.Contains(titleLower, queryLower) </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Page matches query", "title", title, "section", sectionName)
                                        // Add context information
                                        page["sectionName"] = sectionName
                                        page["sectionId"] = sectionID
                                        page["sectionPath"] = sectionPath
                                        allPages = append(allPages, page)
                                }</span>
                        }
                }
        }

        // Get section groups in this container
        <span class="cov0" title="0">sectionGroups, err := c.ListSectionGroups(containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to get section groups", "container_type", containerType, "container_id", containerID, "error", err)
                // Don't return error, just continue without section groups
        }</span> else<span class="cov0" title="0"> {
                logging.NotebookLogger.Debug("Found section groups", "count", len(sectionGroups), "container_type", containerType, "container_id", containerID)

                // Recursively search each section group
                for i, sectionGroup := range sectionGroups </span><span class="cov0" title="0">{
                        sectionGroupID, ok := sectionGroup["id"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                logging.NotebookLogger.Debug("Section group has no valid ID, skipping", "index", i+1)
                                continue</span>
                        }

                        <span class="cov0" title="0">sectionGroupName, _ := sectionGroup["displayName"].(string)
                        sectionGroupPath := parentPath + "/" + sectionGroupName
                        logging.NotebookLogger.Debug("Recursively searching section group",
                                "section_group_name", sectionGroupName, "section_group_id", sectionGroupID, "section_group_path", sectionGroupPath)

                        // Recursively search this section group
                        sectionGroupPages, err := c.searchPagesRecursively(sectionGroupID, query, "section group", sectionGroupPath)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.NotebookLogger.Debug("Failed to search section group", "section_group_id", sectionGroupID, "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">logging.NotebookLogger.Debug("Found matching pages in section group", "count", len(sectionGroupPages), "section_group_name", sectionGroupName)
                        allPages = append(allPages, sectionGroupPages...)</span>
                }
        }

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Recursive search completed",
                "container_type", containerType, "container_id", containerID, "pages_count", len(allPages))
        return allPages, nil</span>
}

func (c *NotebookClient) ListSections(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Delegate to the sections client
        sectionClient := sections.NewSectionClient(c.Client)
        return sectionClient.ListSections(containerID)
}</span>

func (c *NotebookClient) ListSectionGroups(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Delegate to the sections client
        sectionClient := sections.NewSectionClient(c.Client)
        return sectionClient.ListSectionGroups(containerID)
}</span>

func (c *NotebookClient) ListPages(sectionID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Delegate to the pages client
        pageClient := pages.NewPageClient(c.Client)
        return pageClient.ListPages(sectionID)
}</span>

// GetDefaultNotebookID returns the ID of the default notebook specified in the config.
// If no default notebook is configured, it returns an error.
func GetDefaultNotebookID(client *graph.Client, config *graph.Config) (string, error) <span class="cov8" title="1">{
        if config == nil || config.NotebookName == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no default notebook name configured")
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Looking up default notebook", "name", config.NotebookName)

        // Create a notebook client to list notebooks
        notebookClient := NewNotebookClient(client)

        // List all notebooks to find the one with the matching name
        notebooks, err := notebookClient.ListNotebooks()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list notebooks: %v", err)
        }</span>

        // Search for the notebook with the matching name
        <span class="cov0" title="0">for _, notebook := range notebooks </span><span class="cov0" title="0">{
                if displayName, exists := notebook["displayName"].(string); exists </span><span class="cov0" title="0">{
                        if displayName == config.NotebookName </span><span class="cov0" title="0">{
                                if id, exists := notebook["notebookId"].(string); exists </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Found default notebook", "name", displayName, "id", id)
                                        return id, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("default notebook '%s' not found", config.NotebookName)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// pages.go - Page operations for the Microsoft Graph API client.
//
// This file contains all page-related operations including listing pages,
// creating, updating, deleting, copying, and moving pages, as well as
// handling page items (images, files) and content management.
//
// Key Features:
// - Complete page CRUD operations (Create, Read, Update, Delete)
// - Page content management with HTML support
// - Page item handling (images, files, objects)
// - Advanced content updates with commands
// - Asynchronous page operations (copy, move)
// - Image optimization and metadata extraction
// - HTML parsing and content extraction
//
// Operations Supported:
// - ListPages: List all pages in a section with pagination
// - GetPageContent: Retrieve page HTML content
// - CreatePage: Create new pages with HTML content
// - UpdatePageContent: Update page content with advanced commands
// - UpdatePageContentSimple: Simple content replacement
// - DeletePage: Delete pages by ID
// - CopyPage: Copy pages between sections with async operations
// - MovePage: Move pages between sections
// - GetPageItem: Get complete page item data with binary content
// - ListPageItems: List embedded items in a page
//
// Usage Example:
//   pageClient := pages.NewPageClient(graphClient)
//   pages, err := pageClient.ListPages(sectionID)
//   if err != nil {
//       logging.PageLogger.Error("Failed to list pages", "error", err)
//   }
//
//   result, err := pageClient.CreatePage(sectionID, "My Page", "&lt;html&gt;&lt;body&gt;Content&lt;/body&gt;&lt;/html&gt;")
//   if err != nil {
//       logging.PageLogger.Error("Failed to create page", "error", err)
//   }

package pages

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "math/rand"
        "mime/multipart"
        "net/http"
        "net/textproto"
        "regexp"
        "strings"
        "time"

        "golang.org/x/net/html"

        abstractions "github.com/microsoft/kiota-abstractions-go"
        msgraphmodels "github.com/microsoftgraph/msgraph-sdk-go/models"

        "github.com/gebl/onenote-mcp-server/internal/graph"
        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

const (
        imgTag    = "img"
        objectTag = "object"
)

// PageClient provides page-specific operations
type PageClient struct {
        *graph.Client
}

// NewPageClient creates a new PageClient
func NewPageClient(client *graph.Client) *PageClient <span class="cov8" title="1">{
        return &amp;PageClient{Client: client}
}</span>

// ResolvePageNotebook resolves which notebook contains a specific page ID
// This method implements the authorization.PageNotebookResolver interface
func (pc *PageClient) ResolvePageNotebook(ctx context.Context, pageID string) (notebookID string, notebookName string, sectionID string, sectionName string, err error) <span class="cov0" title="0">{
        logging.PageLogger.Debug("Resolving notebook ownership for page",
                "page_id", pageID)

        // Use Graph API to get page metadata including parent section and notebook
        // Note: Using $expand instead of $select because Graph API v1.0 may not return parent objects with $select
        url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s?$expand=parentSection,parentNotebook", pageID)
        
        response, err := pc.Client.MakeAuthenticatedRequest("GET", url, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to resolve page notebook via Graph API",
                        "page_id", pageID,
                        "error", err.Error())
                return "", "", "", "", fmt.Errorf("failed to resolve page notebook: %w", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        if response.StatusCode != 200 </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Graph API returned error when resolving page notebook",
                        "page_id", pageID,
                        "status_code", response.StatusCode)
                return "", "", "", "", fmt.Errorf("Graph API error %d when resolving page notebook", response.StatusCode)
        }</span>

        <span class="cov0" title="0">var pageInfo struct {
                ID             string `json:"id"`
                Title          string `json:"title"`
                ParentSection  *struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"parentSection"`
                ParentNotebook *struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"parentNotebook"`
        }

        // Read response body to log it for debugging
        content, err := pc.ReadResponseBody(response, "ResolvePageNotebook")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to read response body for page notebook resolution",
                        "page_id", pageID,
                        "error", err.Error())
                return "", "", "", "", fmt.Errorf("failed to read page notebook response body: %w", err)
        }</span>
        
        // Log the actual JSON response for debugging
        <span class="cov0" title="0">logging.PageLogger.Debug("Page notebook resolution response", "page_id", pageID, "response_body", string(content))
        
        if err := json.Unmarshal(content, &amp;pageInfo); err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to decode page notebook resolution response",
                        "page_id", pageID,
                        "error", err.Error())
                return "", "", "", "", fmt.Errorf("failed to decode page notebook response: %w", err)
        }</span>

        // Log the parsed information for debugging
        <span class="cov0" title="0">logging.PageLogger.Debug("Parsed page info from JSON", 
                "page_id", pageID,
                "parsed_page_id", pageInfo.ID,
                "parsed_title", pageInfo.Title,
                "parent_notebook_nil", pageInfo.ParentNotebook == nil,
                "parent_section_nil", pageInfo.ParentSection == nil)

        // Extract the information
        if pageInfo.ParentNotebook != nil </span><span class="cov0" title="0">{
                notebookID = pageInfo.ParentNotebook.ID
                notebookName = pageInfo.ParentNotebook.DisplayName
                logging.PageLogger.Debug("Extracted notebook info", "page_id", pageID, "notebook_id", notebookID, "notebook_name", notebookName)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("ParentNotebook is nil in response", "page_id", pageID)
        }</span>
        
        <span class="cov0" title="0">if pageInfo.ParentSection != nil </span><span class="cov0" title="0">{
                sectionID = pageInfo.ParentSection.ID
                sectionName = pageInfo.ParentSection.DisplayName
                logging.PageLogger.Debug("Extracted section info", "page_id", pageID, "section_id", sectionID, "section_name", sectionName)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("ParentSection is nil in response", "page_id", pageID)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Info("Successfully resolved page notebook ownership",
                "page_id", pageID,
                "notebook_id", notebookID,
                "notebook_name", notebookName,
                "section_id", sectionID,
                "section_name", sectionName)

        return notebookID, notebookName, sectionID, sectionName, nil</span>
}

// PageItemData represents the complete data for a OneNote page item (e.g., image) including metadata and content.
type PageItemData struct {
        ContentType string            `json:"contentType"` // MIME type of the page item
        Filename    string            `json:"filename"`    // Suggested filename for the page item
        Size        int64             `json:"size"`        // Size of the page item in bytes
        Content     []byte            `json:"content"`     // Raw binary content of the page item
        TagName     string            `json:"tagName"`     // HTML tag name (img, object, etc.)
        Attributes  map[string]string `json:"attributes"`  // All HTML attributes from the tag
        OriginalURL string            `json:"originalUrl"` // Original URL from the HTML tag
}

// UpdateCommand represents a single update operation for OneNote page content.
// Based on Microsoft Graph OneNote API documentation.
type UpdateCommand struct {
        Target   string `json:"target"`             // Element to update (data-id, generated id, body, title)
        Action   string `json:"action"`             // Action to perform (append, insert, prepend, replace)
        Position string `json:"position,omitempty"` // Position for insert/append (before, after) - omitted for append action
        Content  string `json:"content"`            // HTML content to add/replace
}

// MarshalJSON implements custom JSON marshaling to exclude position field for append actions
func (uc UpdateCommand) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type UpdateCommandAlias UpdateCommand // Create alias to avoid infinite recursion

        // For append action, create a copy without the position field
        if uc.Action == "append" </span><span class="cov8" title="1">{
                alias := UpdateCommandAlias{
                        Target:  uc.Target,
                        Action:  uc.Action,
                        Content: uc.Content,
                        // Position field is omitted
                }
                return json.Marshal(alias)
        }</span>

        // For other actions, marshal normally
        <span class="cov8" title="1">return json.Marshal(UpdateCommandAlias(uc))</span>
}

// PageItemInfo represents a parsed page item with attributes and extracted ID
type PageItemInfo struct {
        TagName     string            `json:"tagName"`     // "img" or "object"
        PageItemID  string            `json:"pageItemId"`  // Extracted from src/data URL
        Attributes  map[string]string `json:"attributes"`  // All attributes from the tag
        OriginalURL string            `json:"originalUrl"` // Original src/data URL
}

// ListPages fetches all pages in a section by sectionID using the Microsoft Graph SDK.
// Returns a slice of page metadata maps and an error, if any.
// This function handles pagination using the SDK's nextLink mechanism.
func (c *PageClient) ListPages(sectionID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting ListPages operation", "section_id", sectionID)

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before ListPages", "section_id", sectionID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during ListPages", "section_id", sectionID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for ListPages", "section_id", sectionID)</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        logging.PageLogger.Debug("Making Graph API call to list pages", "section_id", sectionID)
        result, err := c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Initial Graph API call failed", "section_id", sectionID, "error", err)
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Authentication error detected, attempting token refresh", "section_id", sectionID)
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Token refresh failed after auth error", "section_id", sectionID, "refresh_error", refreshErr, "original_error", err)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed, retrying Graph API call", "section_id", sectionID)
                                result, err = c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Graph API call failed after token refresh", "section_id", sectionID, "error", err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Graph API call succeeded after token refresh", "section_id", sectionID)</span>
                        } else<span class="cov0" title="0"> {
                                logging.PageLogger.Error("Authentication error but no token manager available", "section_id", sectionID, "error", err)
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.PageLogger.Error("Graph API call failed with non-auth error", "section_id", sectionID, "error", err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var pages []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                pages = append(pages, extractOnenotePageList(result)...)
                logging.PageLogger.Debug("Initial page batch retrieved", "section_id", sectionID, "page_count", len(pages))
        }</span>
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        paginationCount := 0
        for nextLink != nil </span><span class="cov0" title="0">{
                paginationCount++
                logging.PageLogger.Debug("Processing pagination", "section_id", sectionID, "pagination_count", paginationCount, "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateOnenotePageCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Pagination request failed", "section_id", sectionID, "pagination_count", paginationCount, "error", err)
                        return nil, fmt.Errorf("failed to fetch next page of pages: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.OnenotePageCollectionResponseable)
                batchPages := extractOnenotePageList(pageResp)
                pages = append(pages, batchPages...)
                logging.PageLogger.Debug("Pagination batch retrieved", "section_id", sectionID, "pagination_count", paginationCount, "batch_size", len(batchPages), "total_pages", len(pages))
                nextLink = pageResp.GetOdataNextLink()</span>
        }
        <span class="cov0" title="0">logging.PageLogger.Info("ListPages completed successfully", "section_id", sectionID, "total_pages", len(pages), "pagination_requests", paginationCount)
        return pages, nil</span>
}

// ListPagesWithProgress fetches all pages in a section with progress updates for long-running operations.
// Provides granular progress notifications during pagination to prevent client timeouts.
func (c *PageClient) ListPagesWithProgress(sectionID string, progressCallback func(progress int, message string)) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting ListPagesWithProgress operation", "section_id", sectionID)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(0, "Initializing page listing...")
        }</span>

        <span class="cov0" title="0">if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before ListPagesWithProgress", "section_id", sectionID)
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(5, "Refreshing authentication token...")
                }</span>
                <span class="cov0" title="0">if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during ListPagesWithProgress", "section_id", sectionID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for ListPagesWithProgress", "section_id", sectionID)</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(10, "Making initial API request...")
        }</span>
        
        <span class="cov0" title="0">logging.PageLogger.Debug("Making Graph API call to list pages with progress", "section_id", sectionID)
        result, err := c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Initial Graph API call failed", "section_id", sectionID, "error", err)
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Authentication error detected, attempting token refresh", "section_id", sectionID)
                        if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(15, "Authentication error, refreshing token...")
                        }</span>
                        <span class="cov0" title="0">if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Token refresh failed after auth error", "section_id", sectionID, "refresh_error", refreshErr, "original_error", err)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                        progressCallback(20, "Token refreshed, retrying API request...")
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed, retrying Graph API call", "section_id", sectionID)
                                result, err = c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Graph API call failed after token refresh", "section_id", sectionID, "error", err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Graph API call succeeded after token refresh", "section_id", sectionID)</span>
                        } else<span class="cov0" title="0"> {
                                logging.PageLogger.Error("Authentication error but no token manager available", "section_id", sectionID, "error", err)
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.PageLogger.Error("Graph API call failed with non-auth error", "section_id", sectionID, "error", err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var pages []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                pages = append(pages, extractOnenotePageList(result)...)
                logging.PageLogger.Debug("Initial page batch retrieved", "section_id", sectionID, "page_count", len(pages))
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(30, fmt.Sprintf("Retrieved initial batch: %d pages", len(pages)))
                }</span>
        }
        
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        paginationCount := 0
        totalExpectedProgress := 70 // Reserve 30% for pagination, 70% total for completion
        
        // Estimate pagination progress - we don't know total pages yet, so we'll increment gradually
        for nextLink != nil </span><span class="cov0" title="0">{
                paginationCount++
                // Progressive pagination progress: 30% + (paginationCount * 10%) up to 70%
                currentProgress := 30 + (paginationCount * 10)
                if currentProgress &gt; totalExpectedProgress </span><span class="cov0" title="0">{
                        currentProgress = totalExpectedProgress
                }</span>
                
                <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(currentProgress, fmt.Sprintf("Loading page batch %d...", paginationCount+1))
                }</span>
                
                <span class="cov0" title="0">logging.PageLogger.Debug("Processing pagination with progress", "section_id", sectionID, "pagination_count", paginationCount, "progress", currentProgress)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateOnenotePageCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Pagination request failed", "section_id", sectionID, "pagination_count", paginationCount, "error", err)
                        return nil, fmt.Errorf("failed to fetch next page of pages: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.OnenotePageCollectionResponseable)
                batchPages := extractOnenotePageList(pageResp)
                pages = append(pages, batchPages...)
                logging.PageLogger.Debug("Pagination batch retrieved with progress", "section_id", sectionID, "pagination_count", paginationCount, "batch_size", len(batchPages), "total_pages", len(pages))
                
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(currentProgress+5, fmt.Sprintf("Processed batch %d: %d total pages", paginationCount+1, len(pages)))
                }</span>
                
                <span class="cov0" title="0">nextLink = pageResp.GetOdataNextLink()</span>
        }
        
        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(100, fmt.Sprintf("Completed: %d pages loaded", len(pages)))
        }</span>
        
        <span class="cov0" title="0">logging.PageLogger.Info("ListPagesWithProgress completed successfully", "section_id", sectionID, "total_pages", len(pages), "pagination_requests", paginationCount)
        return pages, nil</span>
}

// extractOnenotePageList extracts page info from a OnenotePageCollectionResponseable
func extractOnenotePageList(result msgraphmodels.OnenotePageCollectionResponseable) []map[string]interface{} <span class="cov0" title="0">{
        var pages []map[string]interface{}
        for _, page := range result.GetValue() </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                if page.GetId() != nil </span><span class="cov0" title="0">{
                        m["pageId"] = *page.GetId()
                }</span>
                <span class="cov0" title="0">if page.GetTitle() != nil </span><span class="cov0" title="0">{
                        m["title"] = *page.GetTitle()
                }</span>
                <span class="cov0" title="0">pages = append(pages, m)</span>
        }
        <span class="cov0" title="0">return pages</span>
}

// GetPageContent fetches the HTML content of a page by pageID using the Microsoft Graph SDK.
// pageID: ID of the page to fetch content for.
// forUpdate: Optional boolean that when true includes includeIDs=true parameter for update operations.
// Returns the HTML content as a string and an error, if any.
func (c *PageClient) GetPageContent(pageID string, forUpdate ...bool) (string, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting GetPageContent operation", "page_id", pageID, "for_update", len(forUpdate) &gt; 0 &amp;&amp; forUpdate[0])

        // Check if token is expired and refresh if needed
        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before GetPageContent", "page_id", pageID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during GetPageContent", "page_id", pageID, "error", err)
                        return "", fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for GetPageContent", "page_id", pageID)</span>
        }

        // Check if forUpdate parameter is provided and true
        <span class="cov0" title="0">includeIDs := false
        if len(forUpdate) &gt; 0 &amp;&amp; forUpdate[0] </span><span class="cov0" title="0">{
                includeIDs = true
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("GetPageContent parameters determined", "page_id", pageID, "include_ids", includeIDs)

        ctx := context.Background()

        // Use direct HTTP call to support includeIDs parameter
        if includeIDs </span><span class="cov0" title="0">{
                // Use direct HTTP call with includeIDs parameter
                url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true", pageID)
                logging.PageLogger.Debug("Using direct HTTP call with includeIDs", "page_id", pageID, "url", url)

                content, err := httputils.SafeRequestWithBody(
                        c.MakeAuthenticatedRequest,
                        c.HandleHTTPResponse,
                        c.ReadResponseBody,
                        "GET", url, nil, nil,
                        "GetPageContent",
                )
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Direct HTTP request failed for GetPageContent", "page_id", pageID, "url", url, "error", err)
                        return "", err
                }</span>

                <span class="cov0" title="0">logging.PageLogger.Info("GetPageContent completed successfully via HTTP", "page_id", pageID, "content_length", len(content), "include_ids", true)
                return string(content), nil</span>
        }
        // Use SDK for normal content retrieval
        <span class="cov0" title="0">logging.PageLogger.Debug("Using Graph SDK for normal content retrieval", "page_id", pageID)
        content, err := c.GraphClient.Me().Onenote().Pages().ByOnenotePageId(pageID).Content().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("SDK content retrieval failed", "page_id", pageID, "error", err)
                // Check if this is an auth error and try token refresh
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Authentication error detected in SDK call, attempting token refresh", "page_id", pageID)
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Token refresh failed after SDK auth error", "page_id", pageID, "refresh_error", refreshErr, "original_error", err)
                                        return "", fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed, retrying SDK call", "page_id", pageID)
                                // Retry the operation with fresh token
                                content, err = c.GraphClient.Me().Onenote().Pages().ByOnenotePageId(pageID).Content().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("SDK call failed after token refresh", "page_id", pageID, "error", err)
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("SDK call succeeded after token refresh", "page_id", pageID)</span>
                        } else<span class="cov0" title="0"> {
                                logging.PageLogger.Error("Authentication error but no token manager available", "page_id", pageID, "error", err)
                                return "", err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.PageLogger.Error("SDK call failed with non-auth error", "page_id", pageID, "error", err)
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">logging.PageLogger.Info("GetPageContent completed successfully via SDK", "page_id", pageID, "content_length", len(content), "include_ids", false)
        return string(content), nil</span>
}

// CreatePage creates a new page in a section.
// sectionID: ID of the section to create the page in.
// title: Title of the new page.
// content: HTML content for the page.
// Returns the created page metadata and an error, if any.
func (c *PageClient) CreatePage(sectionID, title, content string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting CreatePage operation", "section_id", sectionID, "title", title, "content_length", len(content))
        // Log the original content at configurable verbosity level
        logging.LogContent(logging.PageLogger, slog.LevelDebug, "CreatePage original content", "section_id", sectionID, "title", title, "original_content", content)
        url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages", sectionID)

        // Ensure the HTML content includes a &lt;title&gt; tag
        finalContent := content
        if !strings.Contains(strings.ToLower(content), "&lt;title&gt;") </span><span class="cov0" title="0">{
                finalContent = "&lt;html&gt;&lt;head&gt;&lt;title&gt;" + htmlEscape(title) + "&lt;/title&gt;&lt;/head&gt;&lt;body&gt;" + content + "&lt;/body&gt;&lt;/html&gt;"
                logging.PageLogger.Debug("Added HTML wrapper with title tag", "section_id", sectionID, "title", title, "final_content_length", len(finalContent))
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("Content already contains title tag", "section_id", sectionID, "title", title, "content_length", len(finalContent))
        }</span>

        // Log the actual content at configurable verbosity level
        <span class="cov0" title="0">logging.LogContent(logging.PageLogger, slog.LevelDebug, "CreatePage final content", "section_id", sectionID, "title", title, "final_content", finalContent)

        // Make authenticated request
        headers := map[string]string{"Content-Type": "application/xhtml+xml"}
        logging.PageLogger.Debug("Making authenticated request to create page", "section_id", sectionID, "url", url, "content_type", headers["Content-Type"])
        var result map[string]interface{}
        err := httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        // Handle HTTP response
                        if err := c.HandleHTTPResponse(resp, "CreatePage"); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("HTTP response handling failed for CreatePage", "section_id", sectionID, "title", title, "status", resp.StatusCode, "error", err)
                                return err
                        }</span>

                        <span class="cov0" title="0">if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to decode response for CreatePage", "section_id", sectionID, "title", title, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                "POST", url, strings.NewReader(finalContent), headers,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated request failed for CreatePage", "section_id", sectionID, "title", title, "error", err)
                return nil, err
        }</span>

        // Log successful creation with page ID if available
        <span class="cov0" title="0">pageID, hasID := result["id"].(string)
        if hasID </span><span class="cov0" title="0">{
                logging.PageLogger.Info("CreatePage completed successfully", "section_id", sectionID, "title", title, "page_id", pageID, "content_length", len(content))
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Info("CreatePage completed successfully but no page ID in response", "section_id", sectionID, "title", title, "content_length", len(content))
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// htmlEscape escapes special HTML characters in a string for safe insertion in &lt;title&gt;.
func htmlEscape(s string) string <span class="cov8" title="1">{
        replacer := strings.NewReplacer(
                "&amp;", "&amp;amp;",
                "&lt;", "&amp;lt;",
                "&gt;", "&amp;gt;",
                "\"", "&amp;quot;",
                "'", "&amp;#39;",
        )
        return replacer.Replace(s)
}</span>

// validateTableUpdates checks if any commands are attempting to update individual table elements
// and returns an error with guidance if table elements are targeted individually.
// isTableElement determines if a target references a table element that cannot be updated individually
func isTableElement(target string) bool <span class="cov8" title="1">{
        target = strings.ToLower(target)
        
        // Direct element targeting (e.g., td:, th:, tr:)
        if strings.HasPrefix(target, "td:") ||
                strings.HasPrefix(target, "th:") ||
                strings.HasPrefix(target, "tr:") ||
                strings.HasPrefix(target, "tbody:") ||
                strings.HasPrefix(target, "thead:") ||
                strings.HasPrefix(target, "tfoot:") </span><span class="cov8" title="1">{
                return true
        }</span>
        
        // Data-id based targeting (e.g., data-id:cell-123, data-id:tr-456)
        <span class="cov8" title="1">if strings.HasPrefix(target, "data-id:") </span><span class="cov8" title="1">{
                idValue := strings.TrimPrefix(target, "data-id:")
                
                // Common table element ID patterns used in OneNote
                tablePatterns := []string{
                        "cell-", "td-", "th-",          // Table cells
                        "row-", "tr-",                  // Table rows  
                        "tbody-", "thead-", "tfoot-",   // Table sections
                        "col-", "colgroup-",            // Table columns
                }
                
                for _, pattern := range tablePatterns </span><span class="cov8" title="1">{
                        if strings.Contains(idValue, pattern) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return false</span>
}

func validateTableUpdates(commands []UpdateCommand) error <span class="cov8" title="1">{
        var tableElementTargets []string

        for _, cmd := range commands </span><span class="cov8" title="1">{
                if isTableElement(cmd.Target) </span><span class="cov8" title="1">{
                        tableElementTargets = append(tableElementTargets, cmd.Target)
                }</span>
        }

        <span class="cov8" title="1">if len(tableElementTargets) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf(`TABLE UPDATE RESTRICTION: You are attempting to update individual table elements (%v). 

OneNote requires that tables be updated as complete units, not individual cells or rows. 

SOLUTION: Instead of updating individual table elements, you must:
1. Target the entire table element (table:data-id) 
2. Replace the complete table HTML with your updated content
3. Include all table structure (table, tr, td/th elements) in your replacement

Example of CORRECT approach:
- Target: "table:{table-data-id}" 
- Action: "replace"
- Content: "&lt;table&gt;...complete table HTML...&lt;/table&gt;"

Example of INCORRECT approach (what you're doing):
- Target: "td:{cell-data-id}" or "data-id:cell-123"
- Action: "replace" 
- Content: "&lt;td&gt;new content&lt;/td&gt;"

This restriction ensures table integrity and prevents layout corruption in OneNote`, tableElementTargets)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdatePageContent updates the HTML content of a page using Microsoft Graph OneNote API.
// commands: Array of update commands defining the changes to make.
// Returns an error if the update fails.
func (c *PageClient) UpdatePageContent(pageID string, commands []UpdateCommand) error <span class="cov0" title="0">{

        // Sanitize and validate the pageID to prevent injection attacks
        sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content", sanitizedPageID)

        if len(commands) == 0 </span><span class="cov0" title="0">{
                logging.PageLogger.Error("No update commands provided", "page_id", pageID)
                return fmt.Errorf("no update commands provided")
        }</span>

        // Log command details for debugging including actual content at verbose level
        <span class="cov0" title="0">for i, cmd := range commands </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Update command details", "page_id", pageID, "command_index", i, "target", cmd.Target, "action", cmd.Action, "position", cmd.Position, "content_length", len(cmd.Content))
                // Log the actual command content at configurable verbosity level
                logging.LogContent(logging.PageLogger, slog.LevelDebug, "Update command content", "page_id", pageID, "command_index", i, "target", cmd.Target, "action", cmd.Action, "content", cmd.Content)
        }</span>

        // Validate table updates to prevent individual table element modifications
        <span class="cov0" title="0">logging.PageLogger.Debug("Validating table update restrictions", "page_id", pageID)
        if errValidate := validateTableUpdates(commands); errValidate != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Table update validation failed", "page_id", pageID, "error", errValidate)
                return errValidate
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Table update validation passed", "page_id", pageID)

        // --- NEW LOGIC: Scan for &lt;img&gt; or &lt;object&gt; tags with Graph API URLs ---
        type resourcePart struct {
                ContentID   string
                Content     []byte
                ContentType string
                Filename    string
        }
        resourceParts := []resourcePart{}
        resourceCounter := 1

        rewriteHTML := func(htmlIn string) (string, error) </span><span class="cov0" title="0">{
                doc, errParse := html.Parse(strings.NewReader(htmlIn))
                if errParse != nil </span><span class="cov0" title="0">{
                        return htmlIn, nil // fallback: return original if parse fails
                }</span>
                <span class="cov0" title="0">var changed bool
                var traverse func(*html.Node)
                traverse = func(n *html.Node) </span><span class="cov0" title="0">{
                        if n.Type == html.ElementNode &amp;&amp; (n.Data == imgTag || n.Data == objectTag) </span><span class="cov0" title="0">{
                                var urlAttr string
                                if n.Data == imgTag </span><span class="cov0" title="0">{
                                        urlAttr = "src"
                                }</span> else<span class="cov0" title="0"> if n.Data == objectTag </span><span class="cov0" title="0">{
                                        urlAttr = "data"
                                }</span>
                                <span class="cov0" title="0">for _, attr := range n.Attr </span><span class="cov0" title="0">{
                                        if attr.Key == urlAttr &amp;&amp; strings.HasPrefix(attr.Val, "https://graph.microsoft.com/") </span><span class="cov0" title="0">{
                                                // Extract resource ID
                                                pageItemID := extractPageItemID(attr.Val)
                                                if pageItemID != "" </span><span class="cov0" title="0">{
                                                        // Download the resource
                                                        item, itemErr := c.GetPageItem(pageID, pageItemID)
                                                        if itemErr != nil </span><span class="cov0" title="0">{
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">contentID := fmt.Sprintf("part%d", resourceCounter)
                                                        resourceCounter++
                                                        resourceParts = append(resourceParts, resourcePart{
                                                                ContentID:   contentID,
                                                                Content:     item.Content,
                                                                ContentType: item.ContentType,
                                                                Filename:    item.Filename,
                                                        })
                                                        // Remove all attributes and only include the src/data attribute
                                                        n.Attr = []html.Attribute{{Key: urlAttr, Val: "name:" + contentID}}
                                                        changed = true
                                                        break</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                                traverse(c)
                        }</span>
                }
                <span class="cov0" title="0">traverse(doc)
                if !changed </span><span class="cov0" title="0">{
                        return htmlIn, nil
                }</span>
                <span class="cov0" title="0">var buf bytes.Buffer
                html.Render(&amp;buf, doc)
                return buf.String(), nil</span>
        }

        // Rewrite HTML in all commands and collect resource parts
        <span class="cov0" title="0">logging.PageLogger.Debug("Rewriting HTML in commands to handle embedded resources", "page_id", pageID)
        for i := range commands </span><span class="cov0" title="0">{
                if commands[i].Content != "" </span><span class="cov0" title="0">{
                        originalLength := len(commands[i].Content)
                        rewritten, _ := rewriteHTML(commands[i].Content)
                        commands[i].Content = rewritten
                        logging.PageLogger.Debug("Rewrote command HTML content", "page_id", pageID, "command_index", i, "original_length", originalLength, "rewritten_length", len(rewritten))
                }</span>
        }
        <span class="cov0" title="0">logging.PageLogger.Debug("HTML rewriting completed", "page_id", pageID, "resource_parts_found", len(resourceParts))

        commandsJSON, err := json.Marshal(commands)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to marshal commands to JSON", "page_id", pageID, "error", err)
                return fmt.Errorf("failed to marshal commands: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Commands marshaled to JSON", "page_id", pageID, "json_length", len(commandsJSON))
        // Log the actual JSON commands at configurable verbosity level
        logging.LogContent(logging.PageLogger, slog.LevelDebug, "Commands JSON content", "page_id", pageID, "commands_json", string(commandsJSON))

        // Create multipart form data
        logging.PageLogger.Debug("Creating multipart form data", "page_id", pageID, "resource_parts", len(resourceParts))
        var buf bytes.Buffer
        writer := multipart.NewWriter(&amp;buf)

        // Add the commands part
        commandsPart, err := writer.CreateFormFile("commands", "commands.json")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to create commands part", "page_id", pageID, "error", err)
                return fmt.Errorf("failed to create commands part: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = commandsPart.Write(commandsJSON)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to write commands to form file", "page_id", pageID, "error", err)
                return fmt.Errorf("failed to write commands to form file: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Commands part added to multipart form", "page_id", pageID)

        // Add resource parts
        for i, part := range resourceParts </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Adding resource part to multipart form", "page_id", pageID, "part_index", i, "content_id", part.ContentID, "filename", part.Filename, "content_type", part.ContentType, "size", len(part.Content))
                partHeader := make(textproto.MIMEHeader)
                partHeader.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"; filename=\"%s\"", part.ContentID, part.Filename))
                partHeader.Set("Content-Type", part.ContentType)
                resourceWriter, errPart := writer.CreatePart(partHeader)
                if errPart != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Failed to create resource part, skipping", "page_id", pageID, "content_id", part.ContentID, "error", errPart)
                        continue</span>
                }
                <span class="cov0" title="0">_, err = resourceWriter.Write(part.Content)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Failed to write resource content, skipping", "page_id", pageID, "content_id", part.ContentID, "error", err)
                        continue</span>
                }
        }

        // Close the writer
        <span class="cov0" title="0">writer.Close()

        // Get the final multipart content type
        contentType := writer.FormDataContentType()

        // Make authenticated request with multipart content type
        headers := map[string]string{"Content-Type": contentType}
        logging.PageLogger.Debug("Making authenticated PATCH request", "page_id", pageID, "url", url, "content_type", contentType, "body_size", buf.Len())

        err = httputils.SafeRequest(
                c.MakeAuthenticatedRequest,
                c.HandleHTTPResponse,
                "PATCH", url, &amp;buf, headers,
                "UpdatePageContent",
        )
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated PATCH request failed for UpdatePageContent", "page_id", pageID, "error", err)
                return err
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Info("UpdatePageContent completed successfully", "page_id", pageID, "command_count", len(commands), "resource_parts", len(resourceParts))
        return nil</span>
}

// UpdatePageContentSimple provides backward compatibility for simple content replacement.
// This function replaces the entire body content of a page.
// For more complex updates, use UpdatePageContent with UpdateCommand array.
func (c *PageClient) UpdatePageContentSimple(pageID, content string) error <span class="cov0" title="0">{
        commands := []UpdateCommand{
                {
                        Target:  "body",
                        Action:  "replace",
                        Content: content,
                },
        }

        return c.UpdatePageContent(pageID, commands)
}</span>

// DeletePage deletes a page by pageID using the Microsoft Graph SDK.
// Returns an error if the deletion fails.
func (c *PageClient) DeletePage(pageID string) error <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting DeletePage operation", "page_id", pageID)
        ctx := context.Background()
        err := c.GraphClient.Me().Onenote().Pages().ByOnenotePageId(pageID).Delete(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("DeletePage failed", "page_id", pageID, "error", err)
                return fmt.Errorf("[pages] DeletePage failed: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Info("DeletePage completed successfully", "page_id", pageID)
        return nil</span>
}

// CopyPage copies a page from one section to another using direct HTTP API calls.
// pageID: ID of the page to copy.
// targetSectionID: ID of the target section to copy the page to.
// Returns the copied page metadata and an error, if any.
func (c *PageClient) CopyPage(pageID string, targetSectionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting CopyPage operation", "page_id", pageID, "target_section_id", targetSectionID)

        // Validate and sanitize inputs
        sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page ID sanitization failed", "page_id", pageID, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">sanitizedTargetSectionID, err := c.SanitizeOneNoteID(targetSectionID, "targetSectionID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Target section ID sanitization failed", "target_section_id", targetSectionID, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Input sanitization completed", "sanitized_page_id", sanitizedPageID, "sanitized_target_section_id", sanitizedTargetSectionID)

        // Construct the URL for copying a page to a section
        url := fmt.Sprintf("https://graph.microsoft.com/beta/me/onenote/pages/%s/copyToSection", sanitizedPageID)
        logging.PageLogger.Debug("Copy URL constructed", "page_id", pageID, "url", url)

        // Create the request body for copying to section
        requestBody := map[string]interface{}{
                "id": sanitizedTargetSectionID,
        }

        // Marshal the request body to JSON
        jsonBody, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to marshal request body", "page_id", pageID, "error", err)
                return nil, fmt.Errorf("failed to marshal request body: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Request body marshaled", "page_id", pageID, "body_length", len(jsonBody))

        // Make authenticated request with custom handler
        headers := map[string]string{"Content-Type": "application/json"}
        logging.PageLogger.Debug("Making authenticated request to copy page", "page_id", pageID, "target_section_id", targetSectionID)
        
        var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        // Check for 202 status code (Accepted - asynchronous operation)
                        logging.PageLogger.Debug("Copy request response received", "page_id", pageID, "status_code", resp.StatusCode)
                        if resp.StatusCode != 202 </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Copy operation failed with unexpected status", "page_id", pageID, "expected_status", 202, "actual_status", resp.StatusCode)
                                return fmt.Errorf("copy operation failed: expected status 202, got %d", resp.StatusCode)
                        }</span>

                        // Read response body
                        <span class="cov0" title="0">content, err := c.ReadResponseBody(resp, "CopyPage")
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to read response body for CopyPage", "page_id", pageID, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logging.PageLogger.Debug("Copy response body read", "page_id", pageID, "content_length", len(content))

                        // Parse the response JSON
                        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to parse copy response", "page_id", pageID, "error", err)
                                return fmt.Errorf("failed to parse copy response: %v", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                "POST", url, bytes.NewBuffer(jsonBody), headers,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated request failed for CopyPage", "page_id", pageID, "target_section_id", targetSectionID, "error", err)
                return nil, err
        }</span>

        // Extract status and id from the response
        <span class="cov0" title="0">status, statusExists := result["status"].(string)
        if !statusExists </span><span class="cov0" title="0">{
                logging.PageLogger.Error("No status field found in copy response", "page_id", pageID)
                return nil, fmt.Errorf("no status field found in copy response")
        }</span>

        <span class="cov0" title="0">operationID, idExists := result["id"].(string)
        if !idExists </span><span class="cov0" title="0">{
                logging.PageLogger.Error("No operation ID found in copy response", "page_id", pageID)
                return nil, fmt.Errorf("no id field found in copy response")
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Async copy operation initiated", "page_id", pageID, "operation_id", operationID, "initial_status", status)

        // Poll for operation completion
        maxAttempts := 30
        logging.PageLogger.Debug("Starting operation polling", "page_id", pageID, "operation_id", operationID, "max_attempts", maxAttempts)
        for attempt := 1; attempt &lt;= maxAttempts; attempt++ </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Polling operation status", "page_id", pageID, "operation_id", operationID, "attempt", attempt)

                // Get operation status
                operationResult, err := c.GetOnenoteOperation(operationID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Failed to get operation status", "page_id", pageID, "operation_id", operationID, "attempt", attempt, "error", err)
                        return nil, fmt.Errorf("failed to get operation status: %v", err)
                }</span>

                // Check operation status
                <span class="cov0" title="0">operationStatus, statusExists := operationResult["status"].(string)
                if !statusExists </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("No status field in operation result", "page_id", pageID, "operation_id", operationID, "attempt", attempt)
                        return nil, fmt.Errorf("no status field in operation result")
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Operation status retrieved", "page_id", pageID, "operation_id", operationID, "attempt", attempt, "status", operationStatus)

                // Check if operation is completed
                if operationStatus == "Completed" </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Copy operation completed", "page_id", pageID, "operation_id", operationID, "attempt", attempt)

                        // Extract page ID from resourceLocation
                        newPageID, err := c.extractPageIDFromResourceLocation(operationResult)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to extract new page ID from operation result", "original_page_id", pageID, "operation_id", operationID, "error", err)
                                return nil, fmt.Errorf("failed to extract page ID from operation result: %v", err)
                        }</span>

                        <span class="cov0" title="0">logging.PageLogger.Info("CopyPage completed successfully", "original_page_id", pageID, "new_page_id", newPageID, "target_section_id", targetSectionID, "operation_id", operationID, "attempts", attempt)
                        return map[string]interface{}{
                                "id":          newPageID,
                                "operationId": operationID,
                                "status":      "Completed",
                        }, nil</span>
                }

                // Check if operation failed
                <span class="cov0" title="0">if operationStatus == "Failed" </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Copy operation failed", "page_id", pageID, "operation_id", operationID, "attempt", attempt)
                        return nil, fmt.Errorf("copy operation failed")
                }</span>

                // Handle special "Running" status (returned when 503 error is encountered)
                <span class="cov0" title="0">if operationStatus == "Running" </span><span class="cov0" title="0">{
                        // Check if we got additional information about the 503 response
                        if note, hasNote := operationResult["note"].(string); hasNote </span><span class="cov0" title="0">{
                                logging.PageLogger.Info("Copy operation still in progress (503 response)",
                                        "page_id", pageID,
                                        "operation_id", operationID,
                                        "attempt", attempt,
                                        "note", note)
                        }</span> else<span class="cov0" title="0"> {
                                logging.PageLogger.Debug("Copy operation still running", "page_id", pageID, "operation_id", operationID, "attempt", attempt)
                        }</span>
                }

                // If not completed, wait before next attempt
                <span class="cov0" title="0">if attempt &lt; maxAttempts </span><span class="cov0" title="0">{
                        // Random delay between 1-3 seconds
                        delay := time.Duration(1+rand.Intn(2+attempt)) * time.Second

                        // Log differently based on whether we got a 503 or just normal progress
                        if operationStatus == "Running" </span><span class="cov0" title="0">{
                                logging.PageLogger.Info("Continuing to wait for copy operation completion after 503 response",
                                        "page_id", pageID,
                                        "operation_id", operationID,
                                        "attempt", attempt,
                                        "delay", delay,
                                        "status", operationStatus)
                        }</span> else<span class="cov0" title="0"> {
                                logging.PageLogger.Debug("Waiting before next polling attempt",
                                        "page_id", pageID,
                                        "operation_id", operationID,
                                        "attempt", attempt,
                                        "delay", delay,
                                        "status", operationStatus)
                        }</span>

                        <span class="cov0" title="0">time.Sleep(delay)</span>
                }
        }

        <span class="cov0" title="0">logging.PageLogger.Error("Copy operation timed out", "page_id", pageID, "operation_id", operationID, "max_attempts", maxAttempts)
        return nil, fmt.Errorf("copy operation did not complete within %d attempts", maxAttempts)</span>
}

// GetOnenoteOperation retrieves the status of an asynchronous OneNote operation.
// operationID: ID of the operation to check.
// Returns the operation status and metadata, and an error, if any.
func (c *PageClient) GetOnenoteOperation(operationID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Debug("Starting GetOnenoteOperation", "operation_id", operationID)

        // Validate and sanitize the operation ID
        sanitizedOperationID, err := c.SanitizeOneNoteID(operationID, "operationID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Operation ID sanitization failed", "operation_id", operationID, "error", err)
                return nil, err
        }</span>

        // Construct the URL for getting operation status
        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/operations/%s", sanitizedOperationID)
        logging.PageLogger.Debug("Operation status URL constructed", "operation_id", operationID, "url", url)

        // Make authenticated request with custom handler
        var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        // Handle HTTP response - special handling for 503 Service Unavailable
                        if resp.StatusCode == 503 </span><span class="cov0" title="0">{
                                // 503 indicates the operation is still in progress, not an error condition
                                logging.PageLogger.Warn("Operation status check returned 503 Service Unavailable - operation still in progress",
                                        "operation_id", operationID,
                                        "status_code", resp.StatusCode,
                                        "note", "This is expected during long-running copy operations")

                                // Return a result indicating the operation is still running
                                result = map[string]interface{}{
                                        "status": "Running",
                                        "id":     operationID,
                                        "note":   "Operation is still in progress (503 response received)",
                                }
                                return nil
                        }</span>

                        // Handle other HTTP responses normally
                        <span class="cov0" title="0">if errHandle := c.HandleHTTPResponse(resp, "GetOnenoteOperation"); errHandle != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("HTTP response handling failed for GetOnenoteOperation", "operation_id", operationID, "status", resp.StatusCode, "error", errHandle)
                                return errHandle
                        }</span>

                        // Read response body
                        <span class="cov0" title="0">content, err := c.ReadResponseBody(resp, "GetOnenoteOperation")
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to read response body for GetOnenoteOperation", "operation_id", operationID, "error", err)
                                return err
                        }</span>

                        // Parse the response JSON
                        <span class="cov0" title="0">if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to parse operation status response", "operation_id", operationID, "error", err)
                                return fmt.Errorf("failed to parse operation status response: %v", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                "GET", url, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated request failed for GetOnenoteOperation", "operation_id", operationID, "error", err)
                return nil, err
        }</span>

        // Log the operation status if available
        <span class="cov0" title="0">if status, hasStatus := result["status"].(string); hasStatus </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("GetOnenoteOperation completed", "operation_id", operationID, "status", status)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("GetOnenoteOperation completed but no status in response", "operation_id", operationID)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// extractPageIDFromResourceLocation extracts the page ID from a resourceLocation URL in JSON response.
// jsonData: JSON data that contains a resourceLocation field with a page URL.
// Returns the page ID extracted from the URL and an error, if any.
func (c *PageClient) extractPageIDFromResourceLocation(jsonData map[string]interface{}) (string, error) <span class="cov8" title="1">{
        logging.PageLogger.Debug("Starting extractPageIDFromResourceLocation")

        // Check if resourceLocation exists in the JSON
        resourceLocation, exists := jsonData["resourceLocation"]
        if !exists </span><span class="cov8" title="1">{
                logging.PageLogger.Debug("No resourceLocation field found in JSON data")
                return "", fmt.Errorf("resourceLocation field not found in JSON data")
        }</span>

        // Convert to string
        <span class="cov8" title="1">url, ok := resourceLocation.(string)
        if !ok </span><span class="cov8" title="1">{
                logging.PageLogger.Debug("ResourceLocation is not a string", "type", fmt.Sprintf("%T", resourceLocation))
                return "", fmt.Errorf("resourceLocation is not a string")
        }</span>
        <span class="cov8" title="1">logging.PageLogger.Debug("Found resourceLocation URL", "url", url)

        // Extract page ID from the URL using regex
        // Pattern matches URLs like: https://graph.microsoft.com/beta/users/.../onenote/pages/{pageId}
        pageIDRegex := regexp.MustCompile(`/onenote/pages/([A-Za-z0-9\-!]+)`)
        matches := pageIDRegex.FindStringSubmatch(url)

        if len(matches) &lt; 2 </span><span class="cov8" title="1">{
                logging.PageLogger.Debug("Could not extract page ID from URL", "url", url)
                return "", fmt.Errorf("could not extract page ID from URL: %s", url)
        }</span>

        <span class="cov8" title="1">pageID := matches[1]
        logging.PageLogger.Debug("Extracted page ID from URL", "url", url, "page_id", pageID)

        // Validate the extracted page ID
        if _, err := c.SanitizeOneNoteID(pageID, "extracted page ID"); err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Extracted page ID failed validation", "page_id", pageID, "error", err)
                return "", fmt.Errorf("extracted page ID failed validation: %v", err)
        }</span>

        <span class="cov8" title="1">logging.PageLogger.Debug("Successfully extracted and validated page ID", "page_id", pageID)
        return pageID, nil</span>
}

// MovePage moves a page from one section to another by copying it to the target section and deleting the original.
// pageID: ID of the page to move.
// targetSectionID: ID of the target section to move the page to.
// Returns the moved page metadata and an error, if any.
func (c *PageClient) MovePage(pageID string, targetSectionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting MovePage operation", "page_id", pageID, "target_section_id", targetSectionID)

        // First, copy the page to the target section
        logging.PageLogger.Debug("Copying page for move operation", "page_id", pageID, "target_section_id", targetSectionID)
        copiedPage, err := c.CopyPage(pageID, targetSectionID)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Copy operation failed during move", "page_id", pageID, "target_section_id", targetSectionID, "error", err)
                return nil, fmt.Errorf("failed to copy page for move operation: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Info("Page copied successfully, proceeding with deletion", "original_page_id", pageID, "new_page_id", copiedPage["id"], "target_section_id", targetSectionID)

        // Then, delete the original page
        logging.PageLogger.Debug("Deleting original page after successful copy", "page_id", pageID)
        err = c.DeletePage(pageID)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Warn("Failed to delete original page after copy, but move operation succeeded", "original_page_id", pageID, "new_page_id", copiedPage["id"], "delete_error", err)
                // Note: We don't return an error here because the copy was successful
                // The user now has the page in the target section, even though the original wasn't deleted
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("Original page deleted successfully", "page_id", pageID)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Info("MovePage completed successfully", "original_page_id", pageID, "new_page_id", copiedPage["id"], "target_section_id", targetSectionID)
        return copiedPage, nil</span>
}

// GetPageItem retrieves complete data for a OneNote page item (image, file, etc.) by its ID.
// This enhanced version matches the original sophisticated implementation with:
// - HTML metadata extraction using ListPageItems (avoids duplicate parsing)
// - Content type detection from HTML data-src-type attribute (primary) and HTTP headers (fallback)
// - Automatic image scaling for large images (can be disabled with fullSize parameter)
// - Rich metadata extraction from HTML attributes
// pageID: ID of the page containing the item.
// pageItemID: Resource ID of the page item to retrieve.
// fullSize: Optional parameter to skip image scaling (defaults to false = scale images)
// Returns PageItemData with metadata and binary content, and an error if retrieval fails.
func (c *PageClient) GetPageItem(pageID, pageItemID string, fullSize ...bool) (*PageItemData, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting GetPageItem operation", "page_id", pageID, "page_item_id", pageItemID, "full_size", len(fullSize) &gt; 0 &amp;&amp; fullSize[0])

        // Check if token is expired and refresh if needed
        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before GetPageItem", "page_id", pageID, "page_item_id", pageItemID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during GetPageItem", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for GetPageItem", "page_id", pageID, "page_item_id", pageItemID)</span>
        }

        // Validate and sanitize inputs
        <span class="cov0" title="0">sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page ID sanitization failed", "page_id", pageID, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">sanitizedPageItemID, err := c.SanitizeOneNoteID(pageItemID, "pageItemID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page item ID sanitization failed", "page_item_id", pageItemID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Getting page item using sophisticated approach", "page_id", sanitizedPageID, "page_item_id", sanitizedPageItemID)

        // First, get the page items list to extract HTML metadata (original approach)
        logging.PageLogger.Debug("Getting page items list to extract HTML metadata")
        pageItemsList, err := c.ListPageItems(sanitizedPageID)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to get page items list", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                return nil, fmt.Errorf("failed to get page items list: %v", err)
        }</span>

        // Find the specific page item in the list to get its HTML metadata
        <span class="cov0" title="0">var htmlMetadata *PageItemInfo
        for _, itemMap := range pageItemsList </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Checking item in list", "item_map", itemMap)
                if itemID, exists := itemMap["pageItemId"].(string); exists &amp;&amp; itemID == sanitizedPageItemID </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Found matching page item", "page_item_id", itemID)

                        // Safely extract tagName
                        tagName := ""
                        if tagNameVal, exists := itemMap["tagName"]; exists </span><span class="cov0" title="0">{
                                if tagNameStr, ok := tagNameVal.(string); ok </span><span class="cov0" title="0">{
                                        tagName = tagNameStr
                                }</span>
                        }

                        // Initialize attributes map and add data-attachment if present
                        <span class="cov0" title="0">attributes := make(map[string]string)
                        if dataAttachmentVal, exists := itemMap["data-attachment"]; exists </span><span class="cov0" title="0">{
                                if dataAttachmentStr, ok := dataAttachmentVal.(string); ok </span><span class="cov0" title="0">{
                                        attributes["data-attachment"] = dataAttachmentStr
                                        logging.PageLogger.Debug("Found data-attachment attribute", "value", dataAttachmentStr)
                                }</span>
                        }

                        // Extract mimeType if available - check both data-src-type and type attributes
                        <span class="cov0" title="0">var mimeTypeFromHTML string
                        if mimeTypeVal, exists := itemMap["mimeType"]; exists </span><span class="cov0" title="0">{
                                if mimeTypeStr, ok := mimeTypeVal.(string); ok </span><span class="cov0" title="0">{
                                        mimeTypeFromHTML = mimeTypeStr
                                        // Store the MIME type in appropriate attribute based on tag type
                                        if tagName == "object" </span><span class="cov0" title="0">{
                                                attributes["type"] = mimeTypeStr
                                        }</span> else<span class="cov0" title="0"> {
                                                attributes["data-src-type"] = mimeTypeStr
                                        }</span>
                                        <span class="cov0" title="0">logging.PageLogger.Debug("Found mimeType from HTML", "value", mimeTypeStr, "tag_name", tagName)</span>
                                }
                        }

                        <span class="cov0" title="0">htmlMetadata = &amp;PageItemInfo{
                                TagName:     tagName,
                                PageItemID:  itemID,
                                Attributes:  attributes,
                                OriginalURL: "", // No longer available in simplified structure
                        }

                        logging.PageLogger.Debug("Found HTML metadata for page item", "tag_name", htmlMetadata.TagName, "attributes", htmlMetadata.Attributes, "page_item_id", htmlMetadata.PageItemID, "mime_type_from_html", mimeTypeFromHTML)
                        break</span>
                }
        }

        // Construct the resource URL for downloading content
        <span class="cov0" title="0">resourceURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/resources/%s/$value", sanitizedPageItemID)
        logging.PageLogger.Debug("Downloading item content", "page_id", pageID, "page_item_id", pageItemID, "url", resourceURL)

        // Make authenticated request to download the resource
        var content []byte
        var resp *http.Response
        err = httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(response *http.Response) error </span><span class="cov0" title="0">{
                        resp = response // Capture response for header access
                        
                        // Handle HTTP response
                        if errHandle := c.HandleHTTPResponse(response, "GetPageItem"); errHandle != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("HTTP response handling failed for GetPageItem", "page_id", pageID, "page_item_id", pageItemID, "status", response.StatusCode, "error", errHandle)
                                return errHandle
                        }</span>

                        // Read the binary content
                        <span class="cov0" title="0">responseContent, readErr := c.ReadResponseBody(response, "GetPageItem")
                        if readErr != nil </span><span class="cov0" title="0">{
                                return readErr
                        }</span>
                        <span class="cov0" title="0">content = responseContent
                        return nil</span>
                },
                "GET", resourceURL, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to download page item content", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                return nil, fmt.Errorf("failed to download page item: %v", err)
        }</span>

        // Create the page item data with content
        <span class="cov0" title="0">pageItemData := &amp;PageItemData{
                Size:    int64(len(content)),
                Content: content,
        }

        // Add HTML metadata if found (original sophisticated approach)
        if htmlMetadata != nil </span><span class="cov0" title="0">{
                pageItemData.TagName = htmlMetadata.TagName
                pageItemData.Attributes = htmlMetadata.Attributes
                pageItemData.OriginalURL = htmlMetadata.OriginalURL

                logging.PageLogger.Debug("HTML metadata found", "tag_name", htmlMetadata.TagName, "attributes", htmlMetadata.Attributes, "data_src_type", htmlMetadata.Attributes["data-src-type"], "type", htmlMetadata.Attributes["type"])

                // Extract content type from HTML attributes - PRIMARY method
                var contentTypeFromHTML string
                // For object tags, check the type attribute first (HTML standard)
                if htmlMetadata.TagName == "object" </span><span class="cov0" title="0">{
                        if contentType, exists := htmlMetadata.Attributes["type"]; exists &amp;&amp; contentType != "" </span><span class="cov0" title="0">{
                                contentTypeFromHTML = contentType
                                logging.PageLogger.Debug("Content type from HTML type attribute (object tag)", "content_type", contentType)
                        }</span>
                }
                // If not found, check data-src-type (existing behavior)
                <span class="cov0" title="0">if contentTypeFromHTML == "" </span><span class="cov0" title="0">{
                        if contentType, exists := htmlMetadata.Attributes["data-src-type"]; exists &amp;&amp; contentType != "" </span><span class="cov0" title="0">{
                                contentTypeFromHTML = contentType
                                logging.PageLogger.Debug("Content type from HTML data-src-type attribute", "content_type", contentType)
                        }</span>
                }

                <span class="cov0" title="0">if contentTypeFromHTML != "" </span><span class="cov0" title="0">{
                        pageItemData.ContentType = contentTypeFromHTML
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to HTTP content type if HTML attribute not found
                        contentType := c.getContentTypeFromResponse(resp)
                        pageItemData.ContentType = contentType
                        logging.PageLogger.Debug("Content type from HTTP headers (fallback)", "content_type", contentType)
                }</span>

                // Generate filename based on content type (enhanced version)
                <span class="cov0" title="0">pageItemData.Filename = c.generateFilenameFromContentType(pageItemID, pageItemData.ContentType)

                // Scale image if it's large and an image type (unless fullSize is requested)
                shouldScale := len(fullSize) == 0 || !fullSize[0] // Scale by default, skip if fullSize=true
                if shouldScale &amp;&amp; strings.HasPrefix(pageItemData.ContentType, "image/") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Attempting to scale image", "content_type", pageItemData.ContentType, "original_size", len(content))
                        scaledContent, scaled, err := utils.ScaleImageIfNeeded(pageItemData.Content, pageItemData.ContentType, 1024, 768)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Debug("Failed to scale image", "error", err)
                        }</span> else<span class="cov0" title="0"> if scaled </span><span class="cov0" title="0">{
                                pageItemData.Content = scaledContent
                                pageItemData.Size = int64(len(scaledContent))
                                logging.PageLogger.Debug("Image was scaled down", "original_size", len(content), "scaled_size", len(scaledContent))
                        }</span> else<span class="cov0" title="0"> {
                                logging.PageLogger.Debug("Image size within limits, no scaling needed")
                        }</span>
                } else<span class="cov0" title="0"> if len(fullSize) &gt; 0 &amp;&amp; fullSize[0] </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Skipping image scaling due to fullSize parameter")
                }</span>

                <span class="cov0" title="0">logging.PageLogger.Debug("Added HTML metadata", "tag_name", pageItemData.TagName, "original_url", pageItemData.OriginalURL, "content_type", pageItemData.ContentType, "filename", pageItemData.Filename, "size_bytes", pageItemData.Size, "attributes", pageItemData.Attributes)</span>
        } else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("No HTML metadata found for page item", "page_item_id", sanitizedPageItemID)
                // Fallback to HTTP content type and generated filename
                contentType := c.getContentTypeFromResponse(resp)
                pageItemData.ContentType = contentType
                pageItemData.Filename = c.generateFilenameFromContentType(pageItemID, contentType)
                logging.PageLogger.Debug("Using fallback content type and filename", "content_type", contentType, "filename", pageItemData.Filename)
        }</span>

        // Determine if scaling was applied for logging
        <span class="cov0" title="0">scalingApplied := (len(fullSize) == 0 || !fullSize[0]) &amp;&amp; strings.HasPrefix(pageItemData.ContentType, "image/")
        logging.PageLogger.Info("GetPageItem completed successfully", "page_id", pageID, "page_item_id", pageItemID, "filename", pageItemData.Filename, "content_type", pageItemData.ContentType, "size_bytes", pageItemData.Size, "tag_name", pageItemData.TagName, "scaling_applied", scalingApplied)
        return pageItemData, nil</span>
}

// ListPageItems lists all embedded items (images, files) in a OneNote page.
// This enhanced version uses the original sophisticated HTML parsing approach.
// pageID: ID of the page to list items for.
// Returns a slice of page item metadata and an error if listing fails.
func (c *PageClient) ListPageItems(pageID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting ListPageItems operation", "page_id", pageID)

        // Check if token is expired and refresh if needed
        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before ListPageItems", "page_id", pageID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during ListPageItems", "page_id", pageID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for ListPageItems", "page_id", pageID)</span>
        }

        // Validate and sanitize page ID
        <span class="cov0" title="0">sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page ID sanitization failed", "page_id", pageID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Getting page content to extract page items", "page_id", sanitizedPageID)

        // Get the page content first (original approach - don't need IDs for listing)
        pageContent, err := c.GetPageContent(sanitizedPageID, false)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to get page content", "page_id", pageID, "error", err)
                return nil, fmt.Errorf("failed to get page content: %v", err)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Retrieved page content", "content_length", len(pageContent))

        // Parse the HTML content using the original sophisticated approach
        pageItems, err := c.parseHTMLForPageItemsOriginal(pageContent)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to parse page items from HTML", "page_id", pageID, "error", err)
                return nil, fmt.Errorf("failed to parse page items: %v", err)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Found page items in HTML content", "items_count", len(pageItems))

        // Convert PageItemInfo structs to simplified JSON array with requested fields
        var result []map[string]interface{}
        for _, item := range pageItems </span><span class="cov0" title="0">{
                itemMap := map[string]interface{}{
                        "pageItemId": item.PageItemID,
                        "tagName":    item.TagName,
                }

                // Determine type based on tagName and attributes
                var itemType string
                switch item.TagName </span>{
                case "img":<span class="cov0" title="0">
                        itemType = "image"</span>
                case "object":<span class="cov0" title="0">
                        if dataType, exists := item.Attributes["data-attachment"]; exists </span><span class="cov0" title="0">{
                                if dataType == "true" </span><span class="cov0" title="0">{
                                        itemType = "attachment"
                                }</span> else<span class="cov0" title="0"> {
                                        itemType = "object"
                                }</span>
                        } else<span class="cov0" title="0"> {
                                itemType = "object"
                        }</span>
                default:<span class="cov0" title="0">
                        itemType = item.TagName</span>
                }
                <span class="cov0" title="0">itemMap["type"] = itemType

                // Add data-attachment if it exists in attributes
                if dataAttachment, exists := item.Attributes["data-attachment"]; exists </span><span class="cov0" title="0">{
                        itemMap["data-attachment"] = dataAttachment
                }</span>

                // Add MIME type from attributes (check multiple sources)
                <span class="cov0" title="0">var mimeType string
                // First check for data-src-type (existing behavior)
                if dataSrcType, exists := item.Attributes["data-src-type"]; exists &amp;&amp; dataSrcType != "" </span><span class="cov0" title="0">{
                        mimeType = dataSrcType
                }</span>
                // For object tags, also check the type attribute (HTML standard)
                <span class="cov0" title="0">if mimeType == "" &amp;&amp; item.TagName == "object" </span><span class="cov0" title="0">{
                        if typeAttr, exists := item.Attributes["type"]; exists &amp;&amp; typeAttr != "" </span><span class="cov0" title="0">{
                                mimeType = typeAttr
                        }</span>
                }
                // Set mimeType if we found one
                <span class="cov0" title="0">if mimeType != "" </span><span class="cov0" title="0">{
                        itemMap["mimeType"] = mimeType
                }</span>

                <span class="cov0" title="0">result = append(result, itemMap)
                logging.PageLogger.Debug("Page item found", "tag_name", item.TagName, "page_item_id", item.PageItemID, "type", itemType, "data_attachment", item.Attributes["data-attachment"], "mime_type", mimeType)</span>
        }

        <span class="cov0" title="0">logging.PageLogger.Info("ListPageItems completed successfully", "page_id", pageID, "items_count", len(result))
        return result, nil</span>
}

// getExtensionFromContentType returns a file extension based on MIME type.
// contentType: The MIME type.
// Returns the appropriate file extension.
func getExtensionFromContentType(contentType string) string <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(contentType, "image/jpeg"):<span class="cov0" title="0">
                return ".jpg"</span>
        case strings.HasPrefix(contentType, "image/png"):<span class="cov0" title="0">
                return ".png"</span>
        case strings.HasPrefix(contentType, "image/gif"):<span class="cov0" title="0">
                return ".gif"</span>
        case strings.HasPrefix(contentType, "image/bmp"):<span class="cov0" title="0">
                return ".bmp"</span>
        case strings.HasPrefix(contentType, "image/webp"):<span class="cov0" title="0">
                return ".webp"</span>
        case strings.HasPrefix(contentType, "image/svg"):<span class="cov0" title="0">
                return ".svg"</span>
        case strings.HasPrefix(contentType, "application/pdf"):<span class="cov0" title="0">
                return ".pdf"</span>
        case strings.HasPrefix(contentType, "text/plain"):<span class="cov0" title="0">
                return ".txt"</span>
        case strings.HasPrefix(contentType, "text/html"):<span class="cov0" title="0">
                return ".html"</span>
        case strings.HasPrefix(contentType, "application/json"):<span class="cov0" title="0">
                return ".json"</span>
        case strings.HasPrefix(contentType, "application/xml"):<span class="cov0" title="0">
                return ".xml"</span>
        case strings.HasPrefix(contentType, "application/zip"):<span class="cov0" title="0">
                return ".zip"</span>
        case strings.HasPrefix(contentType, "application/vnd.openxmlformats-officedocument"):<span class="cov0" title="0">
                if strings.Contains(contentType, "wordprocessingml") </span><span class="cov0" title="0">{
                        return ".docx"
                }</span> else<span class="cov0" title="0"> if strings.Contains(contentType, "spreadsheetml") </span><span class="cov0" title="0">{
                        return ".xlsx"
                }</span> else<span class="cov0" title="0"> if strings.Contains(contentType, "presentationml") </span><span class="cov0" title="0">{
                        return ".pptx"
                }</span>
                <span class="cov0" title="0">return ".office"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// getContentTypeFromResponse extracts content type from HTTP response headers with fallback.
func (c *PageClient) getContentTypeFromResponse(resp *http.Response) string <span class="cov0" title="0">{
        contentType := "application/octet-stream" // Default content type

        if resp.Header.Get("Content-Type") != "" </span><span class="cov0" title="0">{
                contentType = resp.Header.Get("Content-Type")
                logging.PageLogger.Debug("Content type from HTTP headers", "content_type", contentType)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("No Content-Type header found, using default", "content_type", contentType)
        }</span>

        <span class="cov0" title="0">return contentType</span>
}

// generateFilenameFromContentType creates a filename based on page item ID and content type.
// This version provides more comprehensive MIME type mapping than the original.
func (c *PageClient) generateFilenameFromContentType(pageItemID, contentType string) string <span class="cov0" title="0">{
        var filename string

        // Use the existing utility function for better extension mapping
        ext := getExtensionFromContentType(contentType)
        if ext != "" </span><span class="cov0" title="0">{
                filename = pageItemID + ext
        }</span> else<span class="cov0" title="0"> {
                filename = pageItemID + ".bin"
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Generated filename from content type", "page_item_id", pageItemID, "content_type", contentType, "filename", filename)
        return filename</span>
}

// parseHTMLForPageItemsOriginal parses HTML content using the original sophisticated approach.
// This replaces the current regex-based parsing with proper HTML parser traversal.
func (c *PageClient) parseHTMLForPageItemsOriginal(htmlContent string) ([]*PageItemInfo, error) <span class="cov0" title="0">{
        var pageItems []*PageItemInfo

        logging.PageLogger.Debug("Starting HTML parsing with proper HTML parser", "content_length", len(htmlContent))

        // Parse HTML using the standard library HTML parser
        doc, err := html.Parse(strings.NewReader(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to parse HTML", "error", err)
                return pageItems, fmt.Errorf("failed to parse HTML: %v", err)
        }</span>

        // Recursively traverse the HTML tree to find img and object elements
        <span class="cov0" title="0">var traverse func(*html.Node)
        traverse = func(n *html.Node) </span><span class="cov0" title="0">{
                if n.Type == html.ElementNode </span><span class="cov0" title="0">{
                        if n.Data == "img" || n.Data == "object" </span><span class="cov0" title="0">{
                                // Extract all attributes
                                attributes := make(map[string]string)
                                for _, attr := range n.Attr </span><span class="cov0" title="0">{
                                        attributes[attr.Key] = attr.Val
                                        logging.PageLogger.Debug("Found HTML attribute", "element", n.Data, "key", attr.Key, "value", attr.Val)
                                }</span>

                                // Determine the URL attribute based on element type
                                <span class="cov0" title="0">var urlAttr string
                                var originalURL string

                                if n.Data == "img" </span><span class="cov0" title="0">{
                                        urlAttr = "src"
                                }</span> else<span class="cov0" title="0"> if n.Data == "object" </span><span class="cov0" title="0">{
                                        urlAttr = "data"
                                }</span>

                                <span class="cov0" title="0">if url, exists := attributes[urlAttr]; exists &amp;&amp; url != "" </span><span class="cov0" title="0">{
                                        originalURL = url
                                        pageItemID := extractPageItemID(url)
                                        if pageItemID != "" </span><span class="cov0" title="0">{
                                                logging.PageLogger.Debug("Extracted page item from HTML", "element", n.Data, "page_item_id", pageItemID, "url", url)

                                                pageItems = append(pageItems, &amp;PageItemInfo{
                                                        TagName:     n.Data,
                                                        PageItemID:  pageItemID,
                                                        Attributes:  attributes,
                                                        OriginalURL: originalURL,
                                                })
                                        }</span>
                                }
                        }
                }

                // Recursively process child nodes
                <span class="cov0" title="0">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                        traverse(c)
                }</span>
        }

        // Start traversal from the root
        <span class="cov0" title="0">traverse(doc)

        logging.PageLogger.Debug("HTML parsing completed", "items_found", len(pageItems))
        return pageItems, nil</span>
}

// extractPageItemID extracts the page item ID from OneNote resource URLs
func extractPageItemID(url string) string <span class="cov8" title="1">{
        // Pattern for OneNote resource URLs supports both:
        // - Legacy: https://www.onenote.com/api/v1.0/me/notes/resources/{id}/$value
        // - Microsoft Graph: https://graph.microsoft.com/v1.0/users(...)/onenote/resources/{id}/$value
        // OneNote IDs can contain alphanumeric chars, hyphens, and exclamation marks like: 0-896fbac8f72d01b02c5950345e65f588!1-4D24C77F19546939!39705
        re := regexp.MustCompile(`/resources/([A-Za-z0-9\-!]+)/\$value`)
        matches := re.FindStringSubmatch(url)
        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return matches[1]
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package resources

import (
        "fmt"
)

// toolDescriptions contains all tool descriptions as Go string constants
var toolDescriptions = map[string]string{
        "getAuthStatus": "Check authentication status including token expiry and refresh availability. Shows if you're logged in to OneNote.",

        "refreshToken": "Refresh the current authentication token to extend session without full re-authentication.",

        "initiateAuth": "Start OAuth authentication flow. Returns a URL to visit in your browser to authenticate with Microsoft. Server waits for callback on localhost:8080.\n\nInitial Setup workflow: 1. Start server 2. Check status with getAuthStatus 3. Authenticate with initiateAuth 4. Visit provided URL in browser 5. Server automatically receives callback and updates tokens. Always explain next steps to user.",

        "clearAuth": "Logout by clearing all stored authentication tokens. Requires re-authentication for future OneNote operations.",

        "listNotebooks": "List all OneNote notebooks accessible to the authenticated user. Returns notebook ID, name, and default status flags as a JSON array.\n\nAlways start here when users ask \"Show me my notebooks\" or \"What notebooks do I have?\". Use for ID discovery since users think in names but API requires IDs - this tool translates names to IDs. Pattern: listNotebooks()  find notebook by name matching  use ID for subsequent operations. Always tell user what was found: \"I found your 'Work' notebook (ID: xxx). It contains 5 sections...\"\n\nRESPONSE FORMAT: Returns JSON array with objects containing:\n- id: Notebook ID for API operations\n- name: Display name of the notebook\n- isAPIDefault: Boolean indicating if this is OneNote's default notebook according to Microsoft Graph API\n- isConfigDefault: Boolean indicating if this matches your server's configured default notebook name (ONENOTE_DEFAULT_NOTEBOOK_NAME)\n\nCRITICAL: This is the ONLY way to translate notebook names to IDs. All other tools require actual IDs, NOT names. Use this tool first to get the ID for any notebook name.",

        "createSection": "Create a new section in a notebook or section group.\n\nUser says \"Create a new section called X\"  Step 1: Use getNotebookSections first to see the structure  Step 2: Get container ID (use the notebook ID or section group ID as containerID)  Step 3: createSection(containerID, cleanName). Always validate names for illegal characters and suggest alternatives.\n\n**HIERARCHY:** Sections can only be created inside notebooks or section groups, NOT inside other sections.\n**NAME RESTRICTIONS:** Cannot contain: ? * \\ / : &lt; &gt; | &amp; # ' ' % ~\nUse alternatives: &amp;  \"and\", /  \"-\", :  \"-\", etc.",

        "createSectionGroup": "Create a new section group in a notebook or another section group.\n\nSection groups can contain sections and other section groups, providing hierarchical organization. User says \"Create a folder/group called X\"  Step 1: Use getNotebookSections first to see the structure  Step 2: Get container ID (use the notebook ID or section group ID as containerID)  Step 3: createSectionGroup(containerID, cleanName).\n\n**HIERARCHY:** Section groups can be created inside notebooks or other section groups, NOT inside sections.\n**NAME RESTRICTIONS:** Cannot contain: ? * \\ / : &lt; &gt; | &amp; # ' ' % ~\nUse alternatives: &amp;  \"and\", /  \"-\", :  \"-\", etc.",

        "getSelectedNotebook": "Get the currently selected notebook's metadata from the server's memory cache.\n\nReturns the full notebook object with all metadata including ID, displayName, sections, etc. This is the \"active\" notebook that other tools will operate on by default.\n\nIf no notebook is selected, returns an error message instructing the user to use selectNotebook first.\n\nThe notebook is initially set to the configured default notebook on server startup, or the first available notebook if no default is configured.",

        "selectNotebook": "Select a notebook by name or ID to set as the active notebook in the server's memory cache.\n\nThe selected notebook becomes the \"active\" notebook that other tools operate on by default. This notebook choice persists for the entire server session.\n\nParameters:\n- identifier (required): Either the notebook name (e.g., \"My Work Notebook\") or notebook ID\n\nAfter selection, the notebook's full metadata is cached in memory for fast retrieval by getSelectedNotebook and other tools.\n\nUse listNotebooks first to see available notebooks if you're unsure of the exact name or need the ID.",

        "getNotebookSections": "Shows your notebook's organizational structure - sections and section groups in a tree format. Use this first to understand your notebook layout and get IDs for other operations.\n\nDisplays sections and section groups nested like folders containing subfolders and files. For example, if you have a 'Tasks' section group with sub-sections for 'Work', 'Personal', and 'Projects', this tool will show that hierarchy.\n\n**How to use:** First use this tool to see your notebook's structure, then use listPages on a specific section to view the pages within that section.\n\nFeatures:\n- Returns nested tree structure with all sections and section groups\n- Handles pagination automatically to retrieve all results\n- Caches results in memory for fast subsequent access (5-minute cache)\n- Provides IDs needed for other operations like listPages and createSection\n\nResponse includes notebook root object with displayName, id, and children array containing sections and section groups with full metadata.\n\nIf no notebook is currently selected, returns an error instructing to use selectNotebook first.",

        "clearCache": "Clear all cached data including notebook sections and pages cache.\n\nThis tool clears all cached data to force fresh retrieval from the Microsoft Graph API on the next request. This is useful when:\n- You suspect the cache contains stale data\n- You've made changes outside of this MCP server that aren't reflected in cached data\n- You want to ensure you're getting the most up-to-date information\n- Troubleshooting cache-related issues\n\nThe cache includes:\n- Sections tree structure from the selected notebook\n- Pages metadata for all sections that have been accessed\n- Does NOT clear the currently selected notebook (use selectNotebook to change that)\n\nAfter clearing the cache, subsequent calls to getNotebookSections and listPages will fetch fresh data from the API and rebuild the cache.",

        "listPages": " CRITICAL: sectionID must be an actual ID (e.g. '0-abc123...'), never a section name. Use getNotebookSections to find section IDs.\n\nLists all pages in a specific section. You must use the exact Section ID (e.g., `0-...`) from tools like `getNotebookSections` or `selectNotebook`, not the section name. This is because section names are not unique and can change.\n\nReturns page ID, title, creation date, and metadata for each page.\n\nUser says \"Show me pages in X section\"  Step 1: Find section ID (search workflow)  Step 2: listPages(sectionID). For \"Get me the latest page from X section\"  listPages(sectionID)  sort by lastModifiedDateTime  getPageContent(mostRecentPageId). Always use discovery pattern - never assume IDs are known.",

        "getPageContent": "Get OneNote page content in multiple formats: HTML, Markdown, or plain text. **FLEXIBLE OUTPUT:** Choose the format that best suits your needs.\n\n**FORMAT OPTIONS:**\n- **HTML (default)**: OneNote's native HTML format with full formatting, images, and structure\n- **Markdown**: Automatically converted from HTML to clean Markdown format\n- **Text**: Plain text version with minimal formatting for easy reading\n\n**PARAMETERS:**\n- pageID (required): Page ID to fetch content for\n- format (optional): 'HTML' (default), 'Markdown', or 'Text'\n- forUpdate (optional): Set to 'true' for HTML format only - adds data-id attributes for updatePageContentAdvanced\n\n**IMPORTANT RESTRICTIONS:**\n- forUpdate parameter ONLY works with HTML format (required for page updates)\n- Markdown and Text formats cannot be used with forUpdate=true\n- Only HTML format includes data-id attributes needed for updatePageContentAdvanced\n\n**USAGE EXAMPLES:**\n- Read content: getPageContent(pageID, format='Markdown')\n- Prepare for updates: getPageContent(pageID, forUpdate=true, format='HTML')\n- Get plain text: getPageContent(pageID, format='Text')\n\n**RESPONSE FORMAT:** Returns JSON with content, format, length information, and conversion details.",

        "createPage": "Create a new page in a section with content in ANY format. ** DO NOT CONVERT CONTENT - PASS AS-IS:** The tool automatically handles ALL format conversion internally.\n\n**CRITICAL:** Always pass content exactly as provided by the user WITHOUT any conversion. The tool accepts:\n- Raw Markdown (e.g., \"# Header\\n- Item 1\")\n- Plain text (e.g., \"This is my note\")\n- HTML (e.g., \"&lt;h1&gt;Header&lt;/h1&gt;&lt;p&gt;Content&lt;/p&gt;\")\n\n**WORKFLOW:** User says \"Create a page called X with content Y\"  createPage(sectionID, title, Y) using the EXACT content Y without modification.\n\n**TITLE RESTRICTIONS:** Cannot contain: ? * \\ / : &lt; &gt; | &amp; # ' ' % ~\nUse alternatives: &amp;  \"and\", /  \"-\", :  \"-\", etc.\n\n**DO NOT:**\n- Convert Markdown to HTML yourself\n- Wrap plain text in HTML tags\n- Modify the user's content format in any way\n- Add HTML structure unless the user specifically provided HTML\n\n**DO:**\n- Pass content exactly as the user provided it\n- Let the tool handle ALL format detection and conversion\n- Trust the tool's automatic processing\n\n**RESPONSE:** Returns success status, page ID, detected format, and conversion details showing what the tool did automatically.",

        "updatePageContentAdvanced": "Update specific elements in a OneNote page using command-based targeting. ** DO NOT CONVERT CONTENT - PASS AS-IS:** Each command's content is automatically handled by the tool.\n\n**CRITICAL:** Always pass content in commands exactly as provided WITHOUT any conversion. Each command's content field accepts:\n- Raw Markdown (e.g., \"# Header\\n- Item 1\")\n- Plain text (e.g., \"Simple text paragraph\")\n- HTML (e.g., \"&lt;strong&gt;Bold HTML&lt;/strong&gt;\")\n\n**WORKFLOW:** Step 1: getPageContent(pageID, forUpdate=true) to get current content with data-id attributes  Step 2: Identify target elements and their data-id values  Step 3: updatePageContentAdvanced with commands array using EXACT content without modification.\n\n**TARGETING OPTIONS:**\n- data-id: \"data-id:element-123\" (most precise, get from getPageContent with forUpdate=true)\n- title: \"title\" (targets page title)\n- element selectors: \"h1\", \"p:first\", \"table\" (CSS-like selectors)\n\n**COMMANDS:**\n- append: Add content after target element\n- insert: Add content at specific position (after, before, inside)\n- replace: Replace target element completely\n- delete: Remove target element\n\n**POSITION OPTIONS (for insert):**\n- after: Insert after the target element\n- before: Insert before the target element  \n- inside: Insert inside the target element (at the end)\n\n**TABLE RESTRICTIONS:** Tables must be updated as complete units. You cannot update individual cells - you must replace the entire table element.\n\n**DO NOT:**\n- Convert Markdown to HTML in command content\n- Wrap plain text in HTML tags in command content\n- Modify the user's content format in any way\n- Add HTML structure unless the user specifically provided HTML\n\n**DO:**\n- Pass content exactly as the user provided it in each command\n- Let the tool handle ALL format detection and conversion per command\n- Trust the tool's automatic processing\n\n**COMMAND FORMAT EXAMPLES:**\n```json\n[\n  {\"target\": \"title\", \"action\": \"replace\", \"content\": \"# New Header\"},\n  {\"target\": \"body\", \"action\": \"append\", \"content\": \"Simple text paragraph\"},\n  {\"target\": \"data-id:element-456\", \"action\": \"insert\", \"content\": \"- Item 1\\n- Item 2\", \"position\": \"before\"}\n]\n```\n\n**RESPONSE:** Returns success status, commands processed count, and detailed format detection results showing what the tool did automatically for each command.",

        "deletePage": "Delete a OneNote page permanently. This action cannot be undone.\n\nUser says \"Delete page X\"  confirm with user  deletePage(pageID). Always confirm destructive operations with the user before proceeding.\n\n**WARNING:** This is a permanent operation. Once deleted, the page and all its content cannot be recovered. Always verify the correct page ID and consider asking for user confirmation.",

        "getPageItemContent": "Get a page item (image, file) by ID. Returns binary data with proper MIME type and automatically scales images unless fullSize is specified.",

        "listPageItems": "List all items (images, files) attached to a specific page. Returns JSON array with pageItemID, tagName, type, and data-attachment (if present).",

        "copyPage": "Copy a page from one section to another. Creates a duplicate page in the target section.",

        "movePage": "Move a page from one section to another by copying then deleting the original.",

        "updatePageContent": "Replace the entire content of a page with content in ANY format. ** DO NOT CONVERT CONTENT - PASS AS-IS:** The tool automatically handles ALL format conversion internally.\n\n**CRITICAL:** Always pass content exactly as provided by the user WITHOUT any conversion. The tool accepts:\n- Raw Markdown (e.g., \"# Header\\n- Item 1\")\n- Plain text (e.g., \"Updated content\")\n- HTML (e.g., \"&lt;h1&gt;Header&lt;/h1&gt;&lt;p&gt;Content&lt;/p&gt;\")\n\n**USE CASE:** Complete page content replacement. For partial updates to specific elements, use updatePageContentAdvanced instead.\n\n**DO NOT:**\n- Convert Markdown to HTML yourself\n- Wrap plain text in HTML tags\n- Modify the user's content format in any way\n- Add HTML structure unless the user specifically provided HTML\n\n**DO:**\n- Pass content exactly as the user provided it\n- Let the tool handle ALL format detection and conversion\n- Trust the tool's automatic processing\n\n**RESPONSE:** Returns success status, detected format, and conversion details showing what the tool did automatically.",
}

// GetToolDescription returns the description for a specific tool
func GetToolDescription(toolName string) (string, error) <span class="cov8" title="1">{
        desc, exists := toolDescriptions[toolName]
        if !exists </span><span class="cov8" title="1">{
                return "", fmt.Errorf("description not found for tool: %s", toolName)
        }</span>
        <span class="cov8" title="1">return desc, nil</span>
}

// MustGetToolDescription returns the description for a tool or panics if not found
// This should only be used during server initialization where we want to fail fast
func MustGetToolDescription(toolName string) string <span class="cov8" title="1">{
        desc, exists := toolDescriptions[toolName]
        if !exists </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Tool description not found: %s", toolName))</span>
        }
        <span class="cov8" title="1">return desc</span>
}

// GetAllDescriptions returns all available tool descriptions
func GetAllDescriptions() map[string]string <span class="cov8" title="1">{
        // Return a copy to prevent modification of the original map
        result := make(map[string]string, len(toolDescriptions))
        for k, v := range toolDescriptions </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// groups.go - Section Group operations for the Microsoft Graph API client.
//
// This file contains all section group-related operations including listing,
// creating, and managing section groups within OneNote notebooks.
//
// Key Features:
// - List section groups in notebooks or other section groups
// - Create new section groups
// - List sections within section groups
// - Comprehensive container type detection
//
// Operations Supported:
// - ListSectionGroups: List section groups in a container (notebook/section group)
// - CreateSectionGroup: Create a new section group in a container
// - ListSectionsInSectionGroup: List sections within a section group
// - Helper functions for processing responses and validation
//
// Usage Example:
//   sectionClient := sections.NewSectionClient(graphClient)
//   sectionGroups, err := sectionClient.ListSectionGroups(notebookID)
//   if err != nil {
//       logging.SectionLogger.Error("Failed to list section groups", "error", err)
//   }
//
//   newSectionGroup, err := sectionClient.CreateSectionGroup(notebookID, "My New Section Group")
//   if err != nil {
//       logging.SectionLogger.Error("Failed to create section group", "error", err)
//   }

package sections

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

const (
        containerTypeSection      = "section"
        containerTypeSectionGroup = "sectionGroup"
        containerTypeNotebook     = "notebook"
)

// ListSectionGroups fetches all section groups in a notebook or section group using direct HTTP API calls.
// containerID: ID of the notebook or section group to list section groups from.
// Returns a slice of section group metadata maps and an error, if any.
// Note: Section groups can only be listed from notebooks or other section groups, not from sections.
func (c *SectionClient) ListSectionGroups(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing section groups for container using direct HTTP API", "container_id", containerID)

        // Sanitize and validate the containerID to prevent injection attacks
        sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine container type first for better error messages and logic flow
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type determined", "container_type", containerType)

        // Only allow listing section groups from notebooks or section groups
        // Sections cannot contain section groups according to OneNote hierarchy
        if containerType == containerTypeSection </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot list section groups from a section. Container ID %s is a section. Section groups can only be listed from notebooks or other section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != containerTypeNotebook &amp;&amp; containerType != containerTypeSectionGroup </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Section groups can only be listed from notebooks or section groups", containerID, containerType)
        }</span>

        // Construct the appropriate URL based on container type
        <span class="cov0" title="0">var url string
        if containerType == "notebook" </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using notebook endpoint", "url", url)
        }</span> else<span class="cov0" title="0"> { // sectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using section group endpoint", "url", url)
        }</span>

        // Make the API request
        <span class="cov0" title="0">var result []map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned status code", "status_code", resp.StatusCode)
                                return fmt.Errorf("failed to list section groups from %s: HTTP %d", containerType, resp.StatusCode)
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully retrieved section groups", "container_type", containerType)
                        processedResult, procErr := c.processSectionGroupsResponse(resp, "ListSectionGroups", containerID)
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = processedResult
                        return nil</span>
                },
                "GET", url, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err)
                return nil, fmt.Errorf("failed to list section groups from %s: %v", containerType, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ListSectionGroupsWithProgress fetches section groups with progress updates.
// Provides granular progress notifications during API calls to prevent client timeouts.
func (c *SectionClient) ListSectionGroupsWithProgress(containerID string, progressCallback func(progress int, message string)) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing section groups for container with progress", "container_id", containerID)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(0, "Initializing section group listing...")
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(20, "Determining container type...")
        }</span>

        // Determine container type first for better error messages and logic flow
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type determined", "container_type", containerType)

        // Only allow listing section groups from notebooks or section groups
        // Sections cannot contain section groups according to OneNote hierarchy
        if containerType == containerTypeSection </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot list section groups from a section. Container ID %s is a section. Section groups can only be listed from notebooks or other section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != containerTypeNotebook &amp;&amp; containerType != containerTypeSectionGroup </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Section groups can only be listed from notebooks or section groups", containerID, containerType)
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(40, fmt.Sprintf("Getting section groups from %s...", containerType))
        }</span>

        // Construct the appropriate URL based on container type
        <span class="cov0" title="0">var url string
        if containerType == "notebook" </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using notebook endpoint", "url", url)
        }</span> else<span class="cov0" title="0"> { // sectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using section group endpoint", "url", url)
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(60, "Making API request...")
        }</span>

        // Make the API request
        <span class="cov0" title="0">var result []map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned status code", "status_code", resp.StatusCode)
                                return fmt.Errorf("failed to list section groups from %s: HTTP %d", containerType, resp.StatusCode)
                        }</span>

                        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(80, "Processing response...")
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully retrieved section groups", "container_type", containerType)
                        processedResult, procErr := c.processSectionGroupsResponse(resp, "ListSectionGroups", containerID)
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = processedResult
                        
                        if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(100, fmt.Sprintf("Completed: %d section groups found", len(result)))
                        }</span>
                        
                        <span class="cov0" title="0">return nil</span>
                },
                "GET", url, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err)
                return nil, fmt.Errorf("failed to list section groups from %s: %v", containerType, err)
        }</span>
        
        <span class="cov0" title="0">return result, nil</span>
}

// processSectionGroupsResponse processes the HTTP response for section groups and returns filtered data
func (c *SectionClient) processSectionGroupsResponse(resp *http.Response, operation string, containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status_code", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse section groups response: %v", err)
        }</span>

        // Extract section groups from the response
        <span class="cov0" title="0">sectionGroups, ok := result["value"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("No value field found in response")
                return nil, fmt.Errorf("no value field found in section groups response")
        }</span>

        // Convert to map[string]interface{} format, preserving all raw data for hierarchical processing
        <span class="cov0" title="0">var resultSectionGroups []map[string]interface{}
        for i, sg := range sectionGroups </span><span class="cov0" title="0">{
                if sectionGroup, ok := sg.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Extract the section group ID and name for logging
                        sectionGroupID, hasID := sectionGroup["id"].(string)
                        sectionGroupName, hasName := sectionGroup["displayName"].(string)

                        if !hasID </span><span class="cov0" title="0">{
                                logging.SectionLogger.Warn("Section group missing ID", "index", i)
                                continue</span>
                        }

                        <span class="cov0" title="0">if !hasName </span><span class="cov0" title="0">{
                                logging.SectionLogger.Warn("Section group missing display name", "section_group_id", sectionGroupID)
                                sectionGroupName = "Unnamed Section Group"
                                // Set the displayName in the actual data
                                sectionGroup["displayName"] = sectionGroupName
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Processing section group", "id", sectionGroupID, "name", sectionGroupName)

                        // Preserve the full raw section group data for hierarchical processing
                        // This includes: id, displayName, createdDateTime, lastModifiedDateTime, parentNotebook, parentSectionGroup, etc.
                        resultSectionGroups = append(resultSectionGroups, sectionGroup)
                        logging.SectionLogger.Debug("Added section group to results", "name", sectionGroupName, "id", sectionGroupID)</span>
                } else<span class="cov0" title="0"> {
                        logging.SectionLogger.Warn("Section group is not a valid map", "index", i)
                }</span>
        }

        <span class="cov0" title="0">logging.SectionLogger.Info("Found total section groups", "count", len(resultSectionGroups))
        return resultSectionGroups, nil</span>
}

// ListSectionGroupsWithContext fetches section groups with progress notification support
func (c *SectionClient) ListSectionGroupsWithContext(ctx context.Context, containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing section groups with context", "container_id", containerID)

        // Send progress notification before section groups API call
        c.sendProgressNotification(ctx, "Fetching section groups...")

        // Call the original ListSectionGroups method  
        result, err := c.ListSectionGroups(containerID)
        
        if err == nil </span><span class="cov0" title="0">{
                // Send progress notification after successful completion
                c.sendProgressNotification(ctx, "Section groups retrieved successfully")
        }</span>
        
        <span class="cov0" title="0">return result, err</span>
}

// ListSectionsInSectionGroup fetches all sections in a section group by sectionGroupID using direct HTTP API calls.
// Returns a slice of section metadata maps and an error, if any.
func (c *SectionClient) ListSectionsInSectionGroup(sectionGroupID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing sections for section group using direct HTTP API", "section_group_id", sectionGroupID)

        // Sanitize and validate the sectionGroupID to prevent injection attacks
        sanitizedSectionGroupID, err := c.Client.SanitizeOneNoteID(sectionGroupID, "sectionGroupID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Construct the URL for listing sections in a section group
        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedSectionGroupID)
        logging.SectionLogger.Debug("Sections in section group URL", "url", url)

        // Make authenticated request
        content, err := httputils.SafeRequestWithBody(
                c.Client.MakeAuthenticatedRequest,
                c.Client.HandleHTTPResponse,
                c.Client.ReadResponseBody,
                "GET", url, nil, nil,
                "ListSectionsInSectionGroup",
        )
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Authenticated request failed", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Request completed successfully", "content_length", len(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse sections in section group response: %v", err)
        }</span>

        // Extract sections from the response
        <span class="cov0" title="0">sections, ok := result["value"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("No value field found in response")
                return nil, fmt.Errorf("no value field found in sections in section group response")
        }</span>

        // Convert to map[string]interface{} format with only essential information
        <span class="cov0" title="0">var resultSections []map[string]interface{}
        for _, s := range sections </span><span class="cov0" title="0">{
                if section, ok := s.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Extract only the essential information
                        filteredSection := map[string]interface{}{
                                "id":   section["id"],
                                "name": section["displayName"],
                        }

                        // Add parent information
                        if parentNotebook, exists := section["parentNotebook"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                filteredSection["parentNotebook"] = map[string]interface{}{
                                        "id":   parentNotebook["id"],
                                        "name": parentNotebook["displayName"],
                                }
                        }</span>

                        <span class="cov0" title="0">if parentSectionGroup, exists := section["parentSectionGroup"].(map[string]interface{}); exists &amp;&amp; parentSectionGroup != nil </span><span class="cov0" title="0">{
                                filteredSection["parentSectionGroup"] = map[string]interface{}{
                                        "id":   parentSectionGroup["id"],
                                        "name": parentSectionGroup["displayName"],
                                }
                        }</span>

                        <span class="cov0" title="0">resultSections = append(resultSections, filteredSection)</span>
                }
        }

        <span class="cov0" title="0">logging.SectionLogger.Info("Found total sections in section group", "count", len(resultSections))
        return resultSections, nil</span>
}

// CreateSectionGroup creates a new section group in a notebook or section group using direct HTTP API calls.
// containerID: ID of the notebook or section group to create the section group in.
// displayName: Display name for the new section group.
// Returns the created section group metadata and an error, if any.
// Note: Section groups can only be created inside notebooks or other section groups, not inside sections.
func (c *SectionClient) CreateSectionGroup(containerID, displayName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Creating section group in container using direct HTTP API", "display_name", displayName, "container_id", containerID)

        // Validate display name
        if err := utils.ValidateDisplayName(displayName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine container type first for better error messages
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        // Validate that we can create section groups in this container type
        <span class="cov0" title="0">if containerType == containerTypeSection </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create a section group inside a section. Container ID %s is a section. Section groups can only be created inside notebooks or other section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != containerTypeNotebook &amp;&amp; containerType != containerTypeSectionGroup </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Section groups can only be created inside notebooks or other section groups", containerID, containerType)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type confirmed", "container_type", containerType)

        // Create the request body
        requestBody := map[string]interface{}{
                "displayName": displayName,
        }

        // Marshal the request body to JSON
        jsonBody, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to marshal request body", "error", err)
                return nil, fmt.Errorf("failed to marshal request body: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Request body", "content", string(jsonBody))

        // Use conditional logic to call the correct endpoint based on container type
        var url string
        var endpointType string
        if containerType == containerTypeNotebook </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sectionGroups", sanitizedContainerID)
                endpointType = "notebook"
        }</span> else<span class="cov0" title="0"> { // containerTypeSectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sectionGroups", sanitizedContainerID)
                endpointType = "section group"
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Using correct endpoint based on container type", "url", url, "container_type", containerType, "endpoint_type", endpointType)

        // Make the API request to the correct endpoint
        var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned non-201 status", "status_code", resp.StatusCode, "endpoint_type", endpointType)
                                return fmt.Errorf("failed to create section group in %s: HTTP %d", endpointType, resp.StatusCode)
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully created section group", "endpoint_type", endpointType)
                        processedResult, procErr := c.processCreateSectionGroupResponse(resp, "CreateSectionGroup")
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = processedResult
                        return nil</span>
                },
                "POST", url, bytes.NewBuffer(jsonBody), map[string]string{"Content-Type": "application/json"},
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err, "endpoint_type", endpointType)
                return nil, fmt.Errorf("failed to create section group in %s: %v", endpointType, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// processCreateSectionGroupResponse processes the HTTP response for creating section groups and returns the result
func (c *SectionClient) processCreateSectionGroupResponse(resp *http.Response, operation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status_code", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse create section group response: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Info("Successfully created section group", "id", result["id"])
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// sections.go - Section operations for the Microsoft Graph API client.
//
// This file contains all section-related operations including listing,
// creating, and managing sections within OneNote notebooks and section groups.
//
// Key Features:
// - List sections in notebooks, section groups, or sections
// - Create new sections
// - Comprehensive container type detection
//
// Operations Supported:
// - ListSections: List sections in a container (notebook/section group)
// - CreateSection: Create a new section in a container
// - Helper functions for processing responses and validation
//
// Usage Example:
//   sectionClient := sections.NewSectionClient(graphClient)
//   sections, err := sectionClient.ListSections(notebookID)
//   if err != nil {
//       logging.SectionLogger.Error("Failed to list sections", "error", err)
//   }
//
//   newSection, err := sectionClient.CreateSection(notebookID, "My New Section")
//   if err != nil {
//       logging.SectionLogger.Error("Failed to create section", "error", err)
//   }

package sections

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/gebl/onenote-mcp-server/internal/graph"
        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

// Context keys are now imported from utils to avoid duplication
// (removed local constants since they're not used in this package anymore)

// SectionClient provides section-specific operations
type SectionClient struct {
        *graph.Client
}

// NewSectionClient creates a new SectionClient
func NewSectionClient(client *graph.Client) *SectionClient <span class="cov8" title="1">{
        return &amp;SectionClient{Client: client}
}</span>

// ListSections fetches immediate sections and section groups in a notebook or section group by ID using direct HTTP API calls.
// containerID: ID of the notebook or section group to list sections from.
// Returns a slice containing both sections and section groups metadata maps, and an error if any.
func (c *SectionClient) ListSections(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing immediate sections and section groups for container using direct HTTP API", "container_id", containerID)

        // Sanitize and validate the containerID to prevent injection attacks
        sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine if this is a notebook or section group by checking the response from both endpoints
        // Try notebook endpoint first
        <span class="cov0" title="0">notebookURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying notebook URL", "url", notebookURL)

        notebookResp, err := c.Client.MakeAuthenticatedRequest("GET", notebookURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Notebook endpoint failed, trying section group endpoint", "error", err)
        }</span> else<span class="cov0" title="0"> {
                defer notebookResp.Body.Close()
                if notebookResp.StatusCode == 200 </span><span class="cov0" title="0">{
                        logging.SectionLogger.Debug("Successfully found sections in notebook")
                        // Get immediate sections from notebook
                        directSections, errSections := c.processSectionsResponse(notebookResp, "ListSections")
                        if errSections != nil </span><span class="cov0" title="0">{
                                return nil, errSections
                        }</span>

                        // Get immediate section groups from the notebook
                        <span class="cov0" title="0">var allItems []map[string]interface{}
                        allItems = append(allItems, directSections...)

                        sectionGroups, groupsErr := c.ListSectionGroups(containerID)
                        if groupsErr != nil </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("Failed to get section groups from notebook", "container_id", containerID, "error", groupsErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Add section groups to the result (immediate children only)
                                allItems = append(allItems, sectionGroups...)
                        }</span>

                        <span class="cov0" title="0">return allItems, nil</span>
                }
        }

        // Try section group endpoint
        <span class="cov0" title="0">sectionGroupURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying section group URL", "url", sectionGroupURL)

        sectionGroupResp, err := c.Client.MakeAuthenticatedRequest("GET", sectionGroupURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Section group endpoint also failed", "error", err)
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID: %v", containerID, err)
        }</span>
        <span class="cov0" title="0">defer sectionGroupResp.Body.Close()

        if sectionGroupResp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID", containerID)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully found sections in section group")
        // Get immediate sections from section group
        directSections, err := c.processSectionsResponse(sectionGroupResp, "ListSections")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get immediate section groups from this section group
        <span class="cov0" title="0">var allItems []map[string]interface{}
        allItems = append(allItems, directSections...)

        nestedSectionGroups, err := c.ListSectionGroups(containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to get nested section groups from section group", "container_id", containerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Add section groups to the result (immediate children only)
                allItems = append(allItems, nestedSectionGroups...)
        }</span>

        <span class="cov0" title="0">return allItems, nil</span>
}

// ListSectionsWithContext fetches sections with progress notification support
func (c *SectionClient) ListSectionsWithContext(ctx context.Context, containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing sections with context", "container_id", containerID)

        // Note: Progress notifications handled at the NotebookTools layer

        // Sanitize and validate the containerID to prevent injection attacks
        sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine if this is a notebook or section group by checking the response from both endpoints
        // Try notebook endpoint first
        <span class="cov0" title="0">notebookURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying notebook URL", "url", notebookURL)

        // Send progress notification before notebook API call
        c.sendProgressNotification(ctx, "Making notebook sections API call...")

        notebookResp, err := c.Client.MakeAuthenticatedRequest("GET", notebookURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Notebook endpoint failed, trying section group endpoint", "error", err)
        }</span> else<span class="cov0" title="0"> {
                defer notebookResp.Body.Close()
                if notebookResp.StatusCode == 200 </span><span class="cov0" title="0">{
                        logging.SectionLogger.Debug("Successfully found sections in notebook")
                        
                        // Send progress notification after successful API call
                        c.sendProgressNotification(ctx, "Processing notebook sections response...")
                        
                        // Get immediate sections from notebook
                        directSections, errSections := c.processSectionsResponse(notebookResp, "ListSections")
                        if errSections != nil </span><span class="cov0" title="0">{
                                return nil, errSections
                        }</span>

                        // Get immediate section groups from the notebook with context
                        <span class="cov0" title="0">var allItems []map[string]interface{}
                        allItems = append(allItems, directSections...)

                        // Send progress notification before section groups API call
                        c.sendProgressNotification(ctx, "Fetching section groups...")
                        
                        sectionGroups, groupsErr := c.ListSectionGroupsWithContext(ctx, containerID)
                        if groupsErr != nil </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("Failed to get section groups from notebook", "container_id", containerID, "error", groupsErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Add section groups to the result (immediate children only)
                                allItems = append(allItems, sectionGroups...)
                        }</span>

                        <span class="cov0" title="0">return allItems, nil</span>
                }
        }

        // Try section group endpoint
        <span class="cov0" title="0">sectionGroupURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying section group URL", "url", sectionGroupURL)

        sectionGroupResp, err := c.Client.MakeAuthenticatedRequest("GET", sectionGroupURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Section group endpoint also failed", "error", err)
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID: %v", containerID, err)
        }</span>
        <span class="cov0" title="0">defer sectionGroupResp.Body.Close()

        if sectionGroupResp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID", containerID)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully found sections in section group")
        // Get immediate sections from section group
        directSections, err := c.processSectionsResponse(sectionGroupResp, "ListSections")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get immediate section groups from this section group with context
        <span class="cov0" title="0">var allItems []map[string]interface{}
        allItems = append(allItems, directSections...)

        // Note: Progress notifications handled at the NotebookTools layer
        nestedSectionGroups, err := c.ListSectionGroupsWithContext(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to get nested section groups from section group", "container_id", containerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Add section groups to the result (immediate children only)
                allItems = append(allItems, nestedSectionGroups...)
        }</span>

        <span class="cov0" title="0">return allItems, nil</span>
}

// ListSectionsWithProgress fetches immediate sections and section groups with progress updates.
// Provides granular progress notifications during API calls to prevent client timeouts.
func (c *SectionClient) ListSectionsWithProgress(containerID string, progressCallback func(progress int, message string)) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing immediate sections and section groups for container with progress", "container_id", containerID)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(0, "Initializing section listing...")
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine if this is a notebook or section group by checking the response from both endpoints
        // Try notebook endpoint first
        <span class="cov0" title="0">notebookURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying notebook URL with progress", "url", notebookURL)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(10, "Checking if container is notebook...")
        }</span>

        <span class="cov0" title="0">notebookResp, err := c.Client.MakeAuthenticatedRequest("GET", notebookURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Notebook endpoint failed, trying section group endpoint", "error", err)
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(20, "Not a notebook, checking if section group...")
                }</span>
        } else<span class="cov0" title="0"> {
                defer notebookResp.Body.Close()
                if notebookResp.StatusCode == 200 </span><span class="cov0" title="0">{
                        logging.SectionLogger.Debug("Successfully found sections in notebook")
                        if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(30, "Container is notebook, getting sections...")
                        }</span>
                        
                        // Get immediate sections from notebook
                        <span class="cov0" title="0">directSections, errSections := c.processSectionsResponse(notebookResp, "ListSectionsWithProgress")
                        if errSections != nil </span><span class="cov0" title="0">{
                                return nil, errSections
                        }</span>

                        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(60, fmt.Sprintf("Found %d sections, getting section groups...", len(directSections)))
                        }</span>

                        // Get immediate section groups from the notebook
                        <span class="cov0" title="0">var allItems []map[string]interface{}
                        allItems = append(allItems, directSections...)

                        sectionGroups, groupsErr := c.ListSectionGroupsWithProgress(containerID, func(progress int, message string) </span><span class="cov0" title="0">{
                                // Map section group progress from 60-90%
                                adjustedProgress := 60 + (progress * 30 / 100)
                                if progressCallback != nil </span><span class="cov0" title="0">{
                                        progressCallback(adjustedProgress, fmt.Sprintf("Section groups: %s", message))
                                }</span>
                        })
                        <span class="cov0" title="0">if groupsErr != nil </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("Failed to get section groups from notebook", "container_id", containerID, "error", groupsErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Add section groups to the result (immediate children only)
                                allItems = append(allItems, sectionGroups...)
                        }</span>

                        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(100, fmt.Sprintf("Completed: %d sections and section groups", len(allItems)))
                        }</span>

                        <span class="cov0" title="0">return allItems, nil</span>
                }
        }

        // Try section group endpoint
        <span class="cov0" title="0">sectionGroupURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying section group URL with progress", "url", sectionGroupURL)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(30, "Getting sections from section group...")
        }</span>

        <span class="cov0" title="0">sectionGroupResp, err := c.Client.MakeAuthenticatedRequest("GET", sectionGroupURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Section group endpoint also failed", "error", err)
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID: %v", containerID, err)
        }</span>
        <span class="cov0" title="0">defer sectionGroupResp.Body.Close()

        if sectionGroupResp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID", containerID)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully found sections in section group")
        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(50, "Processing section group sections...")
        }</span>
        
        // Get immediate sections from section group
        <span class="cov0" title="0">directSections, err := c.processSectionsResponse(sectionGroupResp, "ListSectionsWithProgress")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(70, fmt.Sprintf("Found %d sections, getting nested section groups...", len(directSections)))
        }</span>

        // Get immediate section groups from this section group
        <span class="cov0" title="0">var allItems []map[string]interface{}
        allItems = append(allItems, directSections...)

        nestedSectionGroups, err := c.ListSectionGroupsWithProgress(containerID, func(progress int, message string) </span><span class="cov0" title="0">{
                // Map nested section group progress from 70-95%
                adjustedProgress := 70 + (progress * 25 / 100)
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(adjustedProgress, fmt.Sprintf("Nested groups: %s", message))
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to get nested section groups from section group", "container_id", containerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Add section groups to the result (immediate children only)
                allItems = append(allItems, nestedSectionGroups...)
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(100, fmt.Sprintf("Completed: %d sections and section groups", len(allItems)))
        }</span>

        <span class="cov0" title="0">return allItems, nil</span>
}


// sendProgressNotification sends a progress notification using the centralized utility
func (c *SectionClient) sendProgressNotification(ctx context.Context, message string) <span class="cov0" title="0">{
        utils.SendContextualMessage(ctx, message, logging.SectionLogger)
}</span>

// processSectionsResponse processes the HTTP response for sections and returns filtered data
func (c *SectionClient) processSectionsResponse(resp *http.Response, operation string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse sections response: %v", err)
        }</span>

        // Extract sections from the response
        <span class="cov0" title="0">sections, ok := result["value"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("No value field found in response")
                return nil, fmt.Errorf("no value field found in sections response")
        }</span>

        // Convert to map[string]interface{} format, preserving raw data for hierarchical processing
        <span class="cov0" title="0">var resultSections []map[string]interface{}
        for _, s := range sections </span><span class="cov0" title="0">{
                if section, ok := s.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Preserve the full raw section data for hierarchical processing
                        // This includes: id, displayName, createdDateTime, lastModifiedDateTime, parentNotebook, parentSectionGroup, etc.
                        resultSections = append(resultSections, section)
                }</span>
        }

        <span class="cov0" title="0">logging.SectionLogger.Info("Found sections", "count", len(resultSections))

        // Ensure we always return a slice, even if empty
        if resultSections == nil </span><span class="cov0" title="0">{
                resultSections = []map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">return resultSections, nil</span>
}

// determineContainerType determines if a container ID is a notebook or section group by making test requests
func (c *SectionClient) determineContainerType(containerID string) (string, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Determining container type", "container_id", containerID)

        // Define endpoints to try in order
        endpoints := []httputils.HTTPRequestSpec{
                {
                        Method:  "GET",
                        URL:     fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s", containerID),
                        Headers: nil,
                        Body:    nil,
                },
                {
                        Method:  "GET", 
                        URL:     fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s", containerID),
                        Headers: nil,
                        Body:    nil,
                },
                {
                        Method:  "GET",
                        URL:     fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s", containerID),
                        Headers: nil,
                        Body:    nil,
                },
        }

        containerTypes := []string{"notebook", "sectionGroup", "section"}

        for i, endpoint := range endpoints </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Testing endpoint", "url", endpoint.URL, "expected_type", containerTypes[i])
                
                err := httputils.SafeRequest(
                        c.Client.MakeAuthenticatedRequest,
                        func(resp *http.Response, operation string) error </span><span class="cov0" title="0">{
                                if resp.StatusCode == 200 </span><span class="cov0" title="0">{
                                        logging.SectionLogger.Debug("Container type detected", "type", containerTypes[i])
                                        return nil // Success case
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("HTTP %d", resp.StatusCode)</span> // Non-200 status
                        },
                        endpoint.Method, endpoint.URL, endpoint.Body, endpoint.Headers,
                        fmt.Sprintf("determineContainerType_%s", containerTypes[i]),
                )
                
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        // Found the correct type
                        return containerTypes[i], nil
                }</span>
                
                <span class="cov0" title="0">logging.SectionLogger.Debug("Endpoint failed", "url", endpoint.URL, "error", err)</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("container ID %s is not a valid notebook, section group, or section", containerID)</span>
}


// CreateSection creates a new section in a notebook or section group using direct HTTP API calls.
// containerID: ID of the notebook or section group to create the section in.
// displayName: Display name for the new section.
// Returns the created section metadata and an error, if any.
// Note: Sections can only be created inside notebooks or section groups, not inside other sections.
func (c *SectionClient) CreateSection(containerID, displayName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Creating section in container using direct HTTP API", "display_name", displayName, "container_id", containerID)

        // Validate display name
        if err := utils.ValidateDisplayName(displayName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine container type first for better error messages
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        // Validate that we can create sections in this container type
        <span class="cov0" title="0">if containerType == "section" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create a section inside another section. Container ID %s is a section. Sections can only be created inside notebooks or section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != "notebook" &amp;&amp; containerType != "sectionGroup" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Sections can only be created inside notebooks or section groups", containerID, containerType)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type confirmed", "container_type", containerType)

        // Create the request body
        requestBody := map[string]interface{}{
                "displayName": displayName,
        }

        // Marshal the request body to JSON
        var buf bytes.Buffer
        encoder := json.NewEncoder(&amp;buf)
        encoder.SetEscapeHTML(false) // Prevent escaping
        err = encoder.Encode(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to marshal request body", "error", err)
                return nil, fmt.Errorf("failed to marshal request body: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Request body", "body", buf.String())

        // Construct the appropriate URL based on container type
        var url string
        if containerType == "notebook" </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
                logging.SectionLogger.Debug("Using notebook endpoint", "url", url)
        }</span> else<span class="cov0" title="0"> { // sectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
                logging.SectionLogger.Debug("Using section group endpoint", "url", url)
        }</span>

        // Make the API request
        <span class="cov0" title="0">var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned status code", "status", resp.StatusCode)
                                return fmt.Errorf("failed to create section in %s: HTTP %d", containerType, resp.StatusCode)
                        }</span>
                        
                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully created section", "container_type", containerType)
                        createResult, procErr := c.processCreateSectionResponse(resp, "CreateSection")
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = createResult
                        return nil</span>
                },
                "POST", url, &amp;buf, map[string]string{"Content-Type": "application/json"},
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err)
                return nil, fmt.Errorf("failed to create section in %s: %v", containerType, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// processCreateSectionResponse processes the HTTP response for creating sections and returns the result
func (c *SectionClient) processCreateSectionResponse(resp *http.Response, operation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse create section response: %v", err)
        }</span>

        // Validate the response contains required fields
        <span class="cov0" title="0">sectionID, hasID := result["id"].(string)
        if !hasID </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Created section response missing ID field")
                return nil, fmt.Errorf("created section response missing ID field")
        }</span>

        <span class="cov0" title="0">sectionName, hasName := result["displayName"].(string)
        if !hasName </span><span class="cov0" title="0">{
                logging.SectionLogger.Warn("Created section missing display name", "section_id", sectionID)
                sectionName = "Unnamed Section"
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully created section", "section_id", sectionID, "section_name", sectionName)
        logging.SectionLogger.Info("Successfully created section", "section_id", sectionID)

        return result, nil</span>
}

// ListAllSections fetches all sections across all notebooks using the global sections endpoint
// This is equivalent to https://graph.microsoft.com/v1.0/me/onenote/sections?$select=displayName,id
func (c *SectionClient) ListAllSections() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing all sections across all notebooks using global endpoint")

        // Use the global sections endpoint with select query to get displayName and id
        sectionsURL := "https://graph.microsoft.com/v1.0/me/onenote/sections?$select=displayName,id"
        logging.SectionLogger.Debug("Fetching from global sections endpoint", "url", sectionsURL)

        var sections []map[string]interface{}
        err := httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if err := c.Client.HandleHTTPResponse(resp, "ListAllSections"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">sectionsResult, procErr := c.processSectionsResponse(resp, "ListAllSections")
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">sections = sectionsResult
                        return nil</span>
                },
                "GET", sectionsURL, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to fetch sections from global endpoint", "error", err)
                return nil, fmt.Errorf("failed to fetch all sections: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Info("Successfully listed all sections", "sections_count", len(sections))
        return sections, nil</span>
}

// ListAllSectionsWithContext fetches all sections with progress notification support
func (c *SectionClient) ListAllSectionsWithContext(ctx context.Context) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing all sections with context")

        // Send progress notification if available
        c.sendProgressNotification(ctx, "Fetching all sections from global endpoint...")

        return c.ListAllSections()
}</span>

// GetSectionByID fetches a specific section by its ID
func (c *SectionClient) GetSectionByID(sectionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Getting section by ID", "section_id", sectionID)

        // Sanitize and validate the sectionID to prevent injection attacks
        sanitizedSectionID, err := c.Client.SanitizeOneNoteID(sectionID, "sectionID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Use the specific section endpoint
        <span class="cov0" title="0">sectionURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s", sanitizedSectionID)
        logging.SectionLogger.Debug("Fetching section details", "url", sectionURL)

        content, err := httputils.SafeRequestWithBody(
                c.Client.MakeAuthenticatedRequest,
                c.Client.HandleHTTPResponse,
                c.Client.ReadResponseBody,
                "GET", sectionURL, nil, nil,
                "GetSectionByID",
        )
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to fetch section by ID", "section_id", sectionID, "error", err)
                return nil, fmt.Errorf("failed to fetch section %s: %v", sectionID, err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse section response: %v", err)
        }</span>

        // Validate the response contains required fields
        <span class="cov0" title="0">if _, hasID := result["id"].(string); !hasID </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Section response missing ID field")
                return nil, fmt.Errorf("section response missing ID field")
        }</span>

        <span class="cov0" title="0">if displayName, hasName := result["displayName"].(string); hasName </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Successfully retrieved section", "section_id", sectionID, "section_name", displayName)
        }</span> else<span class="cov0" title="0"> {
                logging.SectionLogger.Debug("Successfully retrieved section (no display name)", "section_id", sectionID)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ResolveSectionNotebook resolves which notebook owns a section by its ID
func (c *SectionClient) ResolveSectionNotebook(ctx context.Context, sectionID string) (notebookID string, notebookName string, err error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Resolving notebook ownership for section",
                "section_id", sectionID)

        // Sanitize and validate the sectionID to prevent injection attacks
        sanitizedSectionID, err := c.Client.SanitizeOneNoteID(sectionID, "sectionID")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid section ID: %v", err)
        }</span>

        // Use Graph API to get section metadata including parent notebook
        // We use $expand to get the parent notebook information in the same call
        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s?$expand=parentNotebook", sanitizedSectionID)
        
        response, err := c.Client.MakeAuthenticatedRequest("GET", url, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to resolve section notebook via Graph API",
                        "section_id", sectionID,
                        "error", err.Error())
                return "", "", fmt.Errorf("failed to resolve section notebook: %w", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        if response.StatusCode != 200 </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Graph API returned error when resolving section notebook",
                        "section_id", sectionID,
                        "status_code", response.StatusCode)
                return "", "", fmt.Errorf("Graph API error %d when resolving section notebook", response.StatusCode)
        }</span>

        <span class="cov0" title="0">var sectionInfo struct {
                ID             string `json:"id"`
                DisplayName    string `json:"displayName"`
                ParentNotebook *struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"parentNotebook"`
        }

        if err := json.NewDecoder(response.Body).Decode(&amp;sectionInfo); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to decode section notebook resolution response",
                        "section_id", sectionID,
                        "error", err.Error())
                return "", "", fmt.Errorf("failed to decode Graph API response: %w", err)
        }</span>

        // Validate that we got the parent notebook information
        <span class="cov0" title="0">if sectionInfo.ParentNotebook == nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Section response missing parent notebook information",
                        "section_id", sectionID)
                return "", "", fmt.Errorf("unable to determine parent notebook for section %s", sectionID)
        }</span>

        <span class="cov0" title="0">notebookID = sectionInfo.ParentNotebook.ID
        notebookName = sectionInfo.ParentNotebook.DisplayName

        logging.SectionLogger.Debug("Successfully resolved section notebook ownership",
                "section_id", sectionID,
                "section_name", sectionInfo.DisplayName,
                "notebook_id", notebookID,
                "notebook_name", notebookName)

        return notebookID, notebookName, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// image.go - Image processing utilities for OneNote operations.
//
// This file contains image processing and manipulation utilities used for
// handling images in OneNote pages, including scaling and encoding functions.
//
// Key Features:
// - Image scaling for large images
// - Base64 encoding for image data
// - Support for multiple image formats (JPEG, PNG, GIF)
// - Quality optimization for web display
//
// Usage Example:
//   scaledImage, wasScaled, err := ScaleImageIfNeeded(imageData, "image/jpeg", 1024, 768)
//   if err != nil {
//       // Handle error
//   }
//
//   base64Data := EncodeToBase64(imageData)

package utils

import (
        "bytes"
        "fmt"
        "image"
        "image/gif"
        "image/jpeg"
        "image/png"
        "strings"

        "golang.org/x/image/draw"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// ScaleImageIfNeeded scales down large images to a more manageable size.
// maxWidth and maxHeight define the maximum dimensions for the scaled image.
// Returns the scaled image bytes and whether scaling was performed.
func ScaleImageIfNeeded(imageData []byte, contentType string, maxWidth, maxHeight int) ([]byte, bool, error) <span class="cov8" title="1">{
        // Check if this is an image type we can process
        if !strings.HasPrefix(contentType, "image/") </span><span class="cov8" title="1">{
                return imageData, false, nil
        }</span>

        // Decode the image
        <span class="cov8" title="1">img, _, err := image.Decode(bytes.NewReader(imageData))
        if err != nil </span><span class="cov8" title="1">{
                logging.GetLogger("utils").Debug("Failed to decode image for scaling", "error", err)
                return imageData, false, nil // Return original data if decoding fails
        }</span>

        <span class="cov8" title="1">bounds := img.Bounds()
        width := bounds.Dx()
        height := bounds.Dy()

        // Check if image needs scaling
        if width &lt;= maxWidth &amp;&amp; height &lt;= maxHeight </span><span class="cov8" title="1">{
                logging.GetLogger("utils").Debug("Image size within limits, no scaling needed", "width", width, "height", height, "max_width", maxWidth, "max_height", maxHeight)
                return imageData, false, nil
        }</span>

        <span class="cov8" title="1">logging.GetLogger("utils").Debug("Scaling image to fit within limits", "original_width", width, "original_height", height, "max_width", maxWidth, "max_height", maxHeight)

        // Calculate new dimensions while maintaining aspect ratio
        scaleX := float64(maxWidth) / float64(width)
        scaleY := float64(maxHeight) / float64(height)
        scale := scaleX
        if scaleY &lt; scaleX </span><span class="cov8" title="1">{
                scale = scaleY
        }</span>

        <span class="cov8" title="1">newWidth := int(float64(width) * scale)
        newHeight := int(float64(height) * scale)

        // Create a new image with the scaled dimensions
        scaledImg := image.NewRGBA(image.Rect(0, 0, newWidth, newHeight))

        // Scale the image using high-quality interpolation
        draw.ApproxBiLinear.Scale(scaledImg, scaledImg.Bounds(), img, img.Bounds(), draw.Over, nil)

        // Encode the scaled image back to bytes
        var buf bytes.Buffer
        switch contentType </span>{
        case "image/jpeg", "image/jpg":<span class="cov8" title="1">
                err = jpeg.Encode(&amp;buf, scaledImg, &amp;jpeg.Options{Quality: 85})</span>
        case "image/png":<span class="cov8" title="1">
                err = png.Encode(&amp;buf, scaledImg)</span>
        case "image/gif":<span class="cov8" title="1">
                err = gif.Encode(&amp;buf, scaledImg, nil)</span>
        default:<span class="cov0" title="0">
                logging.GetLogger("utils").Debug("Unsupported image format for scaling", "content_type", contentType)
                return imageData, false, nil</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                logging.GetLogger("utils").Debug("Failed to encode scaled image", "error", err)
                return imageData, false, nil
        }</span>

        <span class="cov8" title="1">scaledData := buf.Bytes()
        logging.GetLogger("utils").Debug("Successfully scaled image",
                "original_bytes", len(imageData), "scaled_bytes", len(scaledData),
                "original_width", width, "original_height", height,
                "new_width", newWidth, "new_height", newHeight)

        return scaledData, true, nil</span>
}

// EncodeToBase64 encodes bytes to a base64 string with a data URI prefix.
func EncodeToBase64(data []byte) string <span class="cov8" title="1">{
        return "data:;base64," + strings.TrimRight(strings.TrimSpace(fmt.Sprintf("%x", data)), "=")
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

package utils

import (
        "context"
        "fmt"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// ProgressNotifier provides centralized progress notification functionality
// for MCP tools and internal operations
type ProgressNotifier struct {
        server *server.MCPServer
        ctx    context.Context
        token  string
}

// NewProgressNotifier creates a new progress notifier instance
func NewProgressNotifier(s *server.MCPServer, ctx context.Context, token string) *ProgressNotifier <span class="cov8" title="1">{
        return &amp;ProgressNotifier{
                server: s,
                ctx:    ctx,
                token:  token,
        }
}</span>

// ExtractProgressToken extracts the progress token from MCP request metadata
func ExtractProgressToken(req mcp.CallToolRequest) string <span class="cov8" title="1">{
        // Extract progress token from request metadata if available
        if req.Params.Meta != nil &amp;&amp; req.Params.Meta.ProgressToken != nil </span><span class="cov8" title="1">{
                if token, ok := req.Params.Meta.ProgressToken.(string); ok </span><span class="cov8" title="1">{
                        return token
                }</span>
                // Handle case where ProgressToken is not a string (e.g., mcp.ProgressToken type)
                <span class="cov8" title="1">return fmt.Sprintf("%v", req.Params.Meta.ProgressToken)</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// SendNotification sends a progress notification with percentage calculation
func (pn *ProgressNotifier) SendNotification(progress, total int, message string) <span class="cov8" title="1">{
        SendProgressNotification(pn.server, pn.ctx, pn.token, progress, total, message)
}</span>

// SendMessage sends a simple progress message without percentage
func (pn *ProgressNotifier) SendMessage(message string) <span class="cov8" title="1">{
        SendProgressMessage(pn.server, pn.ctx, pn.token, message)
}</span>

// IsValid returns whether this notifier has the required components to send notifications
func (pn *ProgressNotifier) IsValid() bool <span class="cov8" title="1">{
        return pn.server != nil &amp;&amp; pn.token != ""
}</span>

// SendProgressNotification sends a progress notification with percentage-based progress
func SendProgressNotification(s *server.MCPServer, ctx context.Context, progressToken string, progress int, total int, message string) <span class="cov8" title="1">{
        if progressToken == "" </span><span class="cov8" title="1">{
                logging.UtilsLogger.Debug("Skipping progress notification - no progress token provided",
                        "progress", progress,
                        "total", total,
                        "message", message)
                return
        }</span>

        // Calculate percentage for enhanced logging
        <span class="cov8" title="1">percentage := float64(progress) / float64(total) * 100

        logging.UtilsLogger.Debug("Preparing to send progress notification to client",
                "progressToken", progressToken,
                "progress", progress,
                "total", total,
                "percentage", fmt.Sprintf("%.1f%%", percentage),
                "message", message,
                "has_server", s != nil)

        if s == nil </span><span class="cov8" title="1">{
                logging.UtilsLogger.Warn("Cannot send progress notification - MCP server is nil",
                        "progressToken", progressToken,
                        "progress", progress,
                        "message", message)
                return
        }</span>

        <span class="cov8" title="1">err := s.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                "progressToken": progressToken,
                "progress":      progress,
                "total":         total,
                "message":       message,
        })

        if err != nil </span><span class="cov8" title="1">{
                logging.UtilsLogger.Warn("Failed to send progress notification to client",
                        "error", err,
                        "progressToken", progressToken,
                        "progress", progress,
                        "total", total,
                        "percentage", fmt.Sprintf("%.1f%%", percentage),
                        "message", message)
        }</span> else<span class="cov0" title="0"> {
                logging.UtilsLogger.Debug("Successfully sent progress notification to client",
                        "progressToken", progressToken,
                        "progress", progress,
                        "total", total,
                        "percentage", fmt.Sprintf("%.1f%%", percentage),
                        "message", message)
        }</span>
}

// SendProgressMessage sends a simple progress message without percentage
func SendProgressMessage(s *server.MCPServer, ctx context.Context, progressToken string, message string) <span class="cov8" title="1">{
        if progressToken == "" </span><span class="cov8" title="1">{
                logging.UtilsLogger.Debug("Skipping progress message - no progress token provided",
                        "message", message)
                return
        }</span>

        <span class="cov8" title="1">logging.UtilsLogger.Debug("Preparing to send progress message to client",
                "progressToken", progressToken,
                "message", message,
                "has_server", s != nil)

        if s == nil </span><span class="cov8" title="1">{
                logging.UtilsLogger.Warn("Cannot send progress message - MCP server is nil",
                        "progressToken", progressToken,
                        "message", message)
                return
        }</span>

        <span class="cov8" title="1">err := s.SendNotificationToClient(ctx, "notifications/progress", map[string]any{
                "progressToken": progressToken,
                "message":       message,
        })

        if err != nil </span><span class="cov8" title="1">{
                logging.UtilsLogger.Warn("Failed to send progress message to client",
                        "error", err,
                        "progressToken", progressToken,
                        "message", message)
        }</span> else<span class="cov0" title="0"> {
                logging.UtilsLogger.Debug("Successfully sent progress message to client",
                        "progressToken", progressToken,
                        "message", message)
        }</span>
}

// Context keys for progress notification system
type contextKey string

const (
        MCPServerKey     contextKey = "mcpServer"
        ProgressTokenKey contextKey = "progressToken"
)

// ExtractFromContext extracts MCP server and progress token from context
// This supports the pattern used by internal clients like SectionClient
func ExtractFromContext(ctx context.Context) (*server.MCPServer, string) <span class="cov8" title="1">{
        var mcpServer *server.MCPServer
        var progressToken string

        if serverVal := ctx.Value(MCPServerKey); serverVal != nil </span><span class="cov8" title="1">{
                if s, ok := serverVal.(*server.MCPServer); ok </span><span class="cov8" title="1">{
                        mcpServer = s
                }</span>
        }

        <span class="cov8" title="1">if tokenVal := ctx.Value(ProgressTokenKey); tokenVal != nil </span><span class="cov8" title="1">{
                if token, ok := tokenVal.(string); ok </span><span class="cov8" title="1">{
                        progressToken = token
                }</span>
        }

        <span class="cov8" title="1">return mcpServer, progressToken</span>
}

// SendContextualMessage sends a progress message using context values
// This is used by internal clients that store progress info in context
func SendContextualMessage(ctx context.Context, message string, logger interface{}) <span class="cov8" title="1">{
        mcpServer, progressToken := ExtractFromContext(ctx)
        
        if mcpServer != nil &amp;&amp; progressToken != "" </span><span class="cov8" title="1">{
                SendProgressMessage(mcpServer, ctx, progressToken, message)
        }</span> else<span class="cov8" title="1"> {
                // Log the attempt for debugging
                if logger != nil </span><span class="cov8" title="1">{
                        logging.UtilsLogger.Debug("Progress notification context incomplete",
                                "message", message,
                                "has_server", mcpServer != nil,
                                "has_token", progressToken != "",
                                "progressToken", progressToken)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// tool_helpers.go - Common utilities for MCP tool handlers to reduce code duplication.
//
// This module provides centralized functions for common MCP tool handler patterns:
// - Error result creation with consistent formatting
// - JSON marshaling with standardized error handling
// - Tool operation logging with timing and context
// - HTTP request/response handling with automatic cleanup
//
// These utilities eliminate repeated boilerplate code across tool handlers and ensure
// consistent error handling, logging, and response formatting throughout the codebase.

package utils

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// ToolResult provides helper functions for creating consistent MCP tool results
type ToolResult struct{}

// NewError creates a standardized error result with consistent formatting
func (tr ToolResult) NewError(operation string, err error) *mcp.CallToolResult <span class="cov0" title="0">{
        return mcp.NewToolResultError(fmt.Sprintf("Failed to %s: %v", operation, err))
}</span>

// NewErrorf creates a standardized error result with formatted message
func (tr ToolResult) NewErrorf(operation string, format string, args ...interface{}) *mcp.CallToolResult <span class="cov0" title="0">{
        message := fmt.Sprintf(format, args...)
        return mcp.NewToolResultError(fmt.Sprintf("Failed to %s: %s", operation, message))
}</span>

// NewJSONResult marshals data to JSON and returns a text result, or error result if marshaling fails
func (tr ToolResult) NewJSONResult(operation string, data interface{}) *mcp.CallToolResult <span class="cov0" title="0">{
        jsonBytes, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Error("Failed to marshal JSON response", "operation", operation, "error", err)
                return tr.NewError(fmt.Sprintf("marshal %s response", operation), err)
        }</span>
        <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes))</span>
}

// NewJSONResultWithFallback marshals data to JSON, with fallback text if marshaling fails
func (tr ToolResult) NewJSONResultWithFallback(operation string, data interface{}, fallbackText string) *mcp.CallToolResult <span class="cov0" title="0">{
        jsonBytes, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logging.ToolsLogger.Warn("Failed to marshal JSON response, using fallback", 
                        "operation", operation, "error", err, "fallback", fallbackText)
                return mcp.NewToolResultText(fallbackText)
        }</span>
        <span class="cov0" title="0">return mcp.NewToolResultText(string(jsonBytes))</span>
}

// Global instance for easy access
var ToolResults = ToolResult{}

// ToolLogger provides standardized logging for tool operations
type ToolLogger struct {
        operation string
        startTime time.Time
}

// NewToolLogger creates a new tool logger for an operation
func NewToolLogger(operation string) *ToolLogger <span class="cov0" title="0">{
        startTime := time.Now()
        logging.ToolsLogger.Info("Starting tool operation", "operation", operation, "type", "tool_invocation")
        return &amp;ToolLogger{
                operation: operation,
                startTime: startTime,
        }
}</span>

// LogError logs an error with operation context
func (tl *ToolLogger) LogError(err error, extraFields ...interface{}) <span class="cov0" title="0">{
        fields := []interface{}{"operation", tl.operation, "error", err}
        fields = append(fields, extraFields...)
        logging.ToolsLogger.Error("Tool operation failed", fields...)
}</span>

// LogDebug logs debug information with operation context
func (tl *ToolLogger) LogDebug(message string, extraFields ...interface{}) <span class="cov0" title="0">{
        fields := []interface{}{"operation", tl.operation}
        fields = append(fields, extraFields...)
        logging.ToolsLogger.Debug(message, fields...)
}</span>

// LogSuccess logs successful completion with duration
func (tl *ToolLogger) LogSuccess(extraFields ...interface{}) <span class="cov0" title="0">{
        elapsed := time.Since(tl.startTime)
        fields := []interface{}{"operation", tl.operation, "duration", elapsed}
        fields = append(fields, extraFields...)
        logging.ToolsLogger.Debug("Tool operation completed successfully", fields...)
}</span>

// HTTPResponse wraps an HTTP response with automatic cleanup and error handling
type HTTPResponse struct {
        *http.Response
        cleaned bool
}

// NewHTTPResponse creates a new HTTPResponse wrapper that ensures proper cleanup
func NewHTTPResponse(resp *http.Response) *HTTPResponse <span class="cov0" title="0">{
        return &amp;HTTPResponse{Response: resp, cleaned: false}
}</span>

// Close closes the response body if not already closed
func (hr *HTTPResponse) Close() error <span class="cov0" title="0">{
        if !hr.cleaned &amp;&amp; hr.Response != nil &amp;&amp; hr.Response.Body != nil </span><span class="cov0" title="0">{
                hr.cleaned = true
                return hr.Response.Body.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReadAll reads the entire response body and automatically closes it
func (hr *HTTPResponse) ReadAll() ([]byte, error) <span class="cov0" title="0">{
        if hr.Response == nil || hr.Response.Body == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no response body available")
        }</span>
        
        <span class="cov0" title="0">defer hr.Close()
        return io.ReadAll(hr.Response.Body)</span>
}

// HTTPClient provides utilities for making HTTP requests with automatic cleanup
type HTTPClient struct {
        client interface {
                MakeAuthenticatedRequest(method, url string, body io.Reader, headers map[string]string) (*http.Response, error)
                HandleHTTPResponse(resp *http.Response, operation string) error
                ReadResponseBody(resp *http.Response, operation string) ([]byte, error)
        }
}

// NewHTTPClient creates a new HTTPClient wrapper
func NewHTTPClient(client interface {
        MakeAuthenticatedRequest(method, url string, body io.Reader, headers map[string]string) (*http.Response, error)
        HandleHTTPResponse(resp *http.Response, operation string) error
        ReadResponseBody(resp *http.Response, operation string) ([]byte, error)
}) *HTTPClient <span class="cov0" title="0">{
        return &amp;HTTPClient{client: client}
}</span>

// MakeRequest makes an authenticated HTTP request with automatic cleanup and error handling
func (hc *HTTPClient) MakeRequest(method, url string, body io.Reader, headers map[string]string, operation string) (*HTTPResponse, error) <span class="cov0" title="0">{
        resp, err := hc.client.MakeAuthenticatedRequest(method, url, body, headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">httpResp := NewHTTPResponse(resp)
        
        // Handle HTTP response errors
        if err := hc.client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                httpResp.Close() // Ensure cleanup on error
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return httpResp, nil</span>
}

// MakeRequestAndReadBody makes a request and reads the response body in one operation
func (hc *HTTPClient) MakeRequestAndReadBody(method, url string, body io.Reader, headers map[string]string, operation string) ([]byte, error) <span class="cov0" title="0">{
        httpResp, err := hc.MakeRequest(method, url, body, headers, operation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return httpResp.ReadAll()</span>
}

// ToolParameterExtractor provides utilities for extracting and validating tool parameters
type ToolParameterExtractor struct {
        req    mcp.CallToolRequest
        logger *ToolLogger
}

// NewParameterExtractor creates a new parameter extractor for a tool request
func NewParameterExtractor(req mcp.CallToolRequest, logger *ToolLogger) *ToolParameterExtractor <span class="cov0" title="0">{
        return &amp;ToolParameterExtractor{req: req, logger: logger}
}</span>

// RequireString extracts a required string parameter with validation
func (tpe *ToolParameterExtractor) RequireString(paramName string) (string, error) <span class="cov0" title="0">{
        value, err := tpe.req.RequireString(paramName)
        if err != nil </span><span class="cov0" title="0">{
                tpe.logger.LogError(fmt.Errorf("missing required parameter: %s", paramName))
                return "", fmt.Errorf("%s is required", paramName)
        }</span>
        
        <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                tpe.logger.LogError(fmt.Errorf("empty required parameter: %s", paramName))
                return "", fmt.Errorf("%s cannot be empty", paramName)
        }</span>
        
        <span class="cov0" title="0">tpe.logger.LogDebug("Extracted parameter", paramName, value)
        return value, nil</span>
}

// RequireStringWithLogging extracts a required string parameter with logging
func (tpe *ToolParameterExtractor) RequireStringWithLogging(paramName string) (string, error) <span class="cov0" title="0">{
        value, err := tpe.req.RequireString(paramName)
        if err != nil </span><span class="cov0" title="0">{
                tpe.logger.LogError(fmt.Errorf("missing required parameter: %s", paramName))
                return "", fmt.Errorf("%s is required", paramName)
        }</span>
        
        <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                tpe.logger.LogError(fmt.Errorf("empty required parameter: %s", paramName))
                return "", fmt.Errorf("%s cannot be empty", paramName)
        }</span>
        
        <span class="cov0" title="0">tpe.logger.LogDebug("Extracted parameter", paramName, value)
        return value, nil</span>
}

// ProgressHandler provides utilities for handling progress notifications in tools
type ProgressHandler struct {
        progressToken string
        logger        *ToolLogger
}

// NewProgressHandler creates a new progress handler
func NewProgressHandler(req mcp.CallToolRequest, logger *ToolLogger) *ProgressHandler <span class="cov0" title="0">{
        progressToken := ExtractProgressToken(req)
        return &amp;ProgressHandler{progressToken: progressToken, logger: logger}
}</span>

// HasProgressToken returns true if a progress token is available
func (ph *ProgressHandler) HasProgressToken() bool <span class="cov0" title="0">{
        return ph.progressToken != ""
}</span>

// SendProgress sends a progress notification if a token is available
func (ph *ProgressHandler) SendProgress(ctx context.Context, s interface{}, progress int, total int, message string) <span class="cov0" title="0">{
        if ph.progressToken != "" &amp;&amp; s != nil </span><span class="cov0" title="0">{
                if mcpServer, ok := s.(*server.MCPServer); ok </span><span class="cov0" title="0">{
                        SendProgressNotification(mcpServer, ctx, ph.progressToken, progress, total, message)
                        ph.logger.LogDebug("Progress notification sent", "progress", progress, "total", total, "message", message)
                }</span>
        }
}

// SendProgressMessage sends a simple progress message if a token is available
func (ph *ProgressHandler) SendProgressMessage(ctx context.Context, s interface{}, message string) <span class="cov0" title="0">{
        if ph.progressToken != "" &amp;&amp; s != nil </span><span class="cov0" title="0">{
                if mcpServer, ok := s.(*server.MCPServer); ok </span><span class="cov0" title="0">{
                        SendProgressMessage(mcpServer, ctx, ph.progressToken, message)
                        ph.logger.LogDebug("Progress message sent", "message", message)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// validation.go - Validation utilities for OneNote operations.
//
// This file contains validation functions for OneNote display names and other
// input validation utilities used across the application.
//
// Key Features:
// - Display name validation for OneNote sections, section groups, and pages
// - Illegal character detection and replacement suggestions
// - User-friendly error messages with alternatives
//
// Usage Example:
//   err := validateDisplayName("My Section")
//   if err != nil {
//       // Handle validation error
//   }
//
//   suggestedName := suggestValidName("My Section?", "?")
//   // Returns "My Section."

package utils

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/yuin/goldmark"
        "github.com/yuin/goldmark/ast"
        "github.com/yuin/goldmark/extension"
        "github.com/yuin/goldmark/parser"
        "github.com/yuin/goldmark/renderer/html"
        "github.com/yuin/goldmark/text"
        md "github.com/JohannesKaufmann/html-to-markdown"
        "github.com/PuerkitoBio/goquery"
        
        "github.com/gebl/onenote-mcp-server/internal/logging"
)

// ValidateDisplayName validates that a display name doesn't contain illegal characters.
// displayName: The display name to validate.
// Returns an error if the name contains illegal characters.
func ValidateDisplayName(displayName string) error <span class="cov8" title="1">{
        illegalChars := []string{"?", "*", "\\", "/", ":", "&lt;", "&gt;", "|", "&amp;", "#", "'", "'", "%", "~"}
        for _, char := range illegalChars </span><span class="cov8" title="1">{
                if strings.Contains(displayName, char) </span><span class="cov8" title="1">{
                        suggestedName := SuggestValidName(displayName, char)
                        return fmt.Errorf("display name contains illegal character '%s'. Illegal characters are: ?*\\/:&lt;&gt;|&amp;#''%%~\n\nSuggestion: Try using '%s' instead of '%s'.\n\nSuggested valid name: '%s'", char, GetReplacementChar(char), char, suggestedName)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SuggestValidName suggests a valid name by replacing illegal characters with appropriate alternatives
func SuggestValidName(name, illegalChar string) string <span class="cov8" title="1">{
        replacements := map[string]string{
                "?":  ".",
                "*":  ".",
                "\\": "-",
                "/":  "-",
                ":":  "-",
                "&lt;":  "(",
                "&gt;":  ")",
                "|":  "-",
                "&amp;":  "and",
                "#":  "number",
                "%":  "percent",
                "~":  "-",
        }

        if replacement, exists := replacements[illegalChar]; exists </span><span class="cov8" title="1">{
                return strings.ReplaceAll(name, illegalChar, replacement)
        }</span>
        <span class="cov8" title="1">return name</span>
}

// GetReplacementChar returns a suggested replacement character for the given illegal character
func GetReplacementChar(illegalChar string) string <span class="cov8" title="1">{
        replacements := map[string]string{
                "?":  ".",
                "*":  ".",
                "\\": "-",
                "/":  "-",
                ":":  "-",
                "&lt;":  "(",
                "&gt;":  ")",
                "|":  "-",
                "&amp;":  "and",
                "#":  "number",
                "%":  "percent",
                "~":  "-",
        }

        if replacement, exists := replacements[illegalChar]; exists </span><span class="cov8" title="1">{
                return replacement
        }</span>
        <span class="cov8" title="1">return "-"</span>
}

// TextFormat represents the format of text content
type TextFormat int

const (
        FormatASCII TextFormat = iota
        FormatMarkdown
        FormatHTML
)

// String returns the string representation of TextFormat
func (f TextFormat) String() string <span class="cov8" title="1">{
        switch f </span>{
        case FormatASCII:<span class="cov8" title="1">
                return "ASCII"</span>
        case FormatMarkdown:<span class="cov8" title="1">
                return "Markdown"</span>
        case FormatHTML:<span class="cov8" title="1">
                return "HTML"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// DetectTextFormat analyzes text content to determine if it's HTML, Markdown, or plain ASCII
func DetectTextFormat(content string) TextFormat <span class="cov8" title="1">{
        originalLength := len(content)
        content = strings.TrimSpace(content)
        trimmedLength := len(content)
        
        logging.UtilsLogger.Debug("Starting text format detection",
                "original_length", originalLength,
                "trimmed_length", trimmedLength,
                "content_preview", truncateString(content, 100))
        
        if content == "" </span><span class="cov8" title="1">{
                logging.UtilsLogger.Debug("Content is empty, returning ASCII format")
                return FormatASCII
        }</span>

        // Check for HTML tags first
        <span class="cov8" title="1">logging.UtilsLogger.Debug("Checking for HTML tags")
        if hasHTMLTags(content) </span><span class="cov8" title="1">{
                logging.UtilsLogger.Debug("HTML tags detected, returning HTML format")
                return FormatHTML
        }</span>

        // Check for Markdown syntax
        <span class="cov8" title="1">logging.UtilsLogger.Debug("Checking for Markdown syntax")
        if hasMarkdownSyntax(content) </span><span class="cov8" title="1">{
                logging.UtilsLogger.Debug("Markdown syntax detected, returning Markdown format")
                return FormatMarkdown
        }</span>

        // Default to ASCII if no specific format detected
        <span class="cov8" title="1">logging.UtilsLogger.Debug("No specific format detected, returning ASCII format")
        return FormatASCII</span>
}

// hasHTMLTags checks if the content contains HTML tags
func hasHTMLTags(content string) bool <span class="cov8" title="1">{
        // Look for HTML tag patterns like &lt;tag&gt;, &lt;/tag&gt;, &lt;tag attr="value"&gt;
        htmlTagRegex := regexp.MustCompile(`&lt;\/?[a-zA-Z][^&gt;]*&gt;`)
        matches := htmlTagRegex.FindAllString(content, -1)
        hasMatch := len(matches) &gt; 0
        
        logging.UtilsLogger.Debug("HTML tag detection",
                "content_length", len(content),
                "regex_pattern", `&lt;\/?[a-zA-Z][^&gt;]*&gt;`,
                "matches_found", len(matches),
                "has_html_tags", hasMatch,
                "detected_tags", matches)
        
        return hasMatch
}</span>

// hasMarkdownSyntax checks if the content contains Markdown syntax using goldmark parser
func hasMarkdownSyntax(content string) bool <span class="cov8" title="1">{
        logging.UtilsLogger.Debug("Starting Markdown syntax detection with goldmark",
                "content_length", len(content),
                "content_preview", truncateString(content, 100))
        
        // First check for common markdown patterns using regex (fast check)
        if hasCommonMarkdownPatterns(content) </span><span class="cov8" title="1">{
                logging.UtilsLogger.Debug("Common markdown patterns detected via regex")
                return true
        }</span>
        
        // Create goldmark parser with extensions for more thorough parsing
        <span class="cov8" title="1">md := goldmark.New(
                goldmark.WithExtensions(
                        extension.GFM,
                        extension.Table,
                        extension.Strikethrough,
                        extension.TaskList,
                ),
        )
        
        // Parse the content
        reader := text.NewReader([]byte(content))
        doc := md.Parser().Parse(reader)
        
        // Count meaningful markdown nodes
        markdownNodes := 0
        detectedTypes := []string{}
        
        err := ast.Walk(doc, func(n ast.Node, entering bool) (ast.WalkStatus, error) </span><span class="cov8" title="1">{
                if entering </span><span class="cov8" title="1">{
                        switch n.Kind() </span>{
                        case ast.KindHeading:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "heading")</span>
                        case ast.KindList:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "list")</span>
                        case ast.KindEmphasis:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "emphasis")</span>
                        case ast.KindLink:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "link")</span>
                        case ast.KindCodeBlock:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "codeblock")</span>
                        case ast.KindFencedCodeBlock:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "fenced_codeblock")</span>
                        case ast.KindBlockquote:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "blockquote")</span>
                        case ast.KindThematicBreak:<span class="cov0" title="0">
                                markdownNodes++
                                detectedTypes = append(detectedTypes, "horizontal_rule")</span>
                        }
                }
                <span class="cov8" title="1">return ast.WalkContinue, nil</span>
        })
        
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                logging.UtilsLogger.Debug("Error walking AST", "error", err)
                return false
        }</span>
        
        <span class="cov8" title="1">hasMarkdown := markdownNodes &gt; 0
        
        logging.UtilsLogger.Debug("Markdown syntax detection completed with goldmark",
                "markdown_nodes_found", markdownNodes,
                "detected_types", detectedTypes,
                "has_markdown_syntax", hasMarkdown)
        
        return hasMarkdown</span>
}

// hasCommonMarkdownPatterns checks for common markdown patterns using regex
func hasCommonMarkdownPatterns(content string) bool <span class="cov8" title="1">{
        patterns := []struct {
                name    string
                regex   *regexp.Regexp
        }{
                {"headers", regexp.MustCompile(`^#{1,6}\s`)},
                {"unordered_lists", regexp.MustCompile(`^[-*+]\s`)},
                {"ordered_lists", regexp.MustCompile(`^\d+\.\s`)},
                {"blockquotes", regexp.MustCompile(`^&gt;\s`)},
                {"code_blocks", regexp.MustCompile("^```|^~~~")},
                {"horizontal_rules", regexp.MustCompile(`^(---+|\*\*\*+|___+)$`)},
                {"tables", regexp.MustCompile(`^\|.*\|.*$`)},
                {"strikethrough", regexp.MustCompile(`~~.*?~~`)},
                {"emphasis", regexp.MustCompile(`\*\*.*?\*\*|\*.*?\*|__.*?__|_.*?_`)},
                {"inline_code", regexp.MustCompile("`.*?`")},
                {"links", regexp.MustCompile(`\[.*?\]\(.*?\)`)},
        }
        
        lines := strings.Split(content, "\n")
        
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Check line-based patterns
                <span class="cov8" title="1">for _, p := range patterns </span><span class="cov8" title="1">{
                        if p.name == "strikethrough" || p.name == "emphasis" || p.name == "inline_code" || p.name == "links" </span><span class="cov8" title="1">{
                                // These can appear anywhere in the content, not just at line start
                                if p.regex.MatchString(content) </span><span class="cov8" title="1">{
                                        logging.UtilsLogger.Debug("Markdown pattern detected via regex",
                                                "pattern_name", p.name,
                                                "content_preview", truncateString(content, 50))
                                        return true
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // These must appear at the start of lines
                                if p.regex.MatchString(line) </span><span class="cov8" title="1">{
                                        logging.UtilsLogger.Debug("Markdown pattern detected via regex",
                                                "pattern_name", p.name,
                                                "line_content", truncateString(line, 50))
                                        return true
                                }</span>
                        }
                }
        }
        
        <span class="cov8" title="1">return false</span>
}


// ConvertToHTML converts text content to HTML based on its detected format
func ConvertToHTML(content string) (string, TextFormat) <span class="cov8" title="1">{
        originalLength := len(content)
        logging.UtilsLogger.Debug("Starting content conversion to HTML",
                "original_length", originalLength,
                "content_preview", truncateString(content, 100))
        
        format := DetectTextFormat(content)
        
        logging.UtilsLogger.Debug("Format detected, proceeding with conversion",
                "detected_format", format.String())
        
        var convertedHTML string
        
        switch format </span>{
        case FormatHTML:<span class="cov8" title="1">
                // Already HTML, return as-is
                logging.UtilsLogger.Debug("Content is HTML, returning as-is")
                convertedHTML = content</span>
        case FormatMarkdown:<span class="cov8" title="1">
                // Convert Markdown to HTML
                logging.UtilsLogger.Debug("Converting Markdown to HTML")
                convertedHTML = convertMarkdownToHTML(content)</span>
        case FormatASCII:<span class="cov8" title="1">
                // Wrap plain text in paragraph tags, preserving line breaks
                logging.UtilsLogger.Debug("Converting ASCII to HTML")
                convertedHTML = convertASCIIToHTML(content)</span>
        default:<span class="cov0" title="0">
                // Fallback to ASCII conversion
                logging.UtilsLogger.Debug("Unknown format, falling back to ASCII conversion")
                convertedHTML = convertASCIIToHTML(content)
                format = FormatASCII</span>
        }
        
        <span class="cov8" title="1">convertedLength := len(convertedHTML)
        logging.UtilsLogger.Debug("Content conversion completed",
                "original_length", originalLength,
                "converted_length", convertedLength,
                "length_change", convertedLength-originalLength,
                "final_format", format.String(),
                "converted_preview", truncateString(convertedHTML, 100))
        
        return convertedHTML, format</span>
}

// convertMarkdownToHTML converts Markdown text to HTML using goldmark
func convertMarkdownToHTML(markdownText string) string <span class="cov8" title="1">{
        logging.UtilsLogger.Debug("Starting Markdown to HTML conversion with goldmark",
                "input_length", len(markdownText),
                "input_preview", truncateString(markdownText, 100))
        
        // Set up goldmark with extensions and options suitable for OneNote
        md := goldmark.New(
                goldmark.WithExtensions(
                        extension.GFM,           // GitHub Flavored Markdown
                        extension.Table,         // Table support
                        extension.Strikethrough, // Strikethrough support
                        extension.TaskList,      // Task list support
                ),
                goldmark.WithParserOptions(
                        parser.WithAutoHeadingID(), // Auto-generate heading IDs
                ),
                goldmark.WithRendererOptions(
                        html.WithHardWraps(), // Convert line breaks to &lt;br&gt;
                        html.WithUnsafe(),    // Allow raw HTML (needed for OneNote)
                ),
        )
        
        logging.UtilsLogger.Debug("Goldmark configured",
                "extensions", "GFM, Table, Strikethrough, TaskList",
                "options", "AutoHeadingID, HardWraps, Unsafe")
        
        // Convert markdown to HTML
        var buf strings.Builder
        err := md.Convert([]byte(markdownText), &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                logging.UtilsLogger.Error("Markdown conversion failed", "error", err)
                // Fallback to treating as plain text
                return convertASCIIToHTML(markdownText)
        }</span>
        
        <span class="cov8" title="1">resultHTML := buf.String()
        
        logging.UtilsLogger.Debug("Markdown to HTML conversion completed with goldmark",
                "input_length", len(markdownText),
                "output_length", len(resultHTML),
                "output_preview", truncateString(resultHTML, 100))
        
        return resultHTML</span>
}

// convertASCIIToHTML converts plain ASCII text to HTML, preserving line breaks
func convertASCIIToHTML(text string) string <span class="cov8" title="1">{
        originalLength := len(text)
        logging.UtilsLogger.Debug("Starting ASCII to HTML conversion",
                "input_length", originalLength,
                "input_preview", truncateString(text, 100))
        
        // Escape HTML special characters
        escapedText := text
        replacements := map[string]string{
                "&amp;":  "&amp;amp;",
                "&lt;":  "&amp;lt;",
                "&gt;":  "&amp;gt;",
                "\"": "&amp;quot;",
                "'":  "&amp;#39;",
        }
        
        for char, replacement := range replacements </span><span class="cov8" title="1">{
                beforeLength := len(escapedText)
                escapedText = strings.ReplaceAll(escapedText, char, replacement)
                afterLength := len(escapedText)
                if beforeLength != afterLength </span><span class="cov0" title="0">{
                        logging.UtilsLogger.Debug("HTML character escaped",
                                "character", char,
                                "replacement", replacement,
                                "before_length", beforeLength,
                                "after_length", afterLength)
                }</span>
        }
        
        // Convert line breaks to &lt;br&gt; tags and wrap in paragraph
        <span class="cov8" title="1">lines := strings.Split(escapedText, "\n")
        totalLines := len(lines)
        var processedLines []string
        
        logging.UtilsLogger.Debug("Processing lines for HTML conversion",
                "total_lines", totalLines)
        
        for i, line := range lines </span><span class="cov8" title="1">{
                originalLine := line
                line = strings.TrimSpace(line)
                if line != "" </span><span class="cov8" title="1">{
                        processedLines = append(processedLines, line)
                        logging.UtilsLogger.Debug("Line processed",
                                "line_number", i+1,
                                "original", truncateString(originalLine, 30),
                                "trimmed", truncateString(line, 30),
                                "kept", true)
                }</span> else<span class="cov0" title="0"> {
                        logging.UtilsLogger.Debug("Line skipped (empty)",
                                "line_number", i+1,
                                "original", truncateString(originalLine, 30),
                                "kept", false)
                }</span>
        }
        
        <span class="cov8" title="1">var result string
        
        // Join lines with &lt;br&gt; tags if multiple lines, otherwise just wrap in &lt;p&gt;
        if len(processedLines) == 0 </span><span class="cov0" title="0">{
                result = "&lt;p&gt;&lt;/p&gt;"
                logging.UtilsLogger.Debug("No content lines, returning empty paragraph")
        }</span> else<span class="cov8" title="1"> if len(processedLines) == 1 </span><span class="cov0" title="0">{
                result = "&lt;p&gt;" + processedLines[0] + "&lt;/p&gt;"
                logging.UtilsLogger.Debug("Single line, wrapping in paragraph")
        }</span> else<span class="cov8" title="1"> {
                result = "&lt;p&gt;" + strings.Join(processedLines, "&lt;br&gt;") + "&lt;/p&gt;"
                logging.UtilsLogger.Debug("Multiple lines, joining with &lt;br&gt; tags",
                        "lines_count", len(processedLines))
        }</span>
        
        <span class="cov8" title="1">logging.UtilsLogger.Debug("ASCII to HTML conversion completed",
                "input_length", originalLength,
                "output_length", len(result),
                "processed_lines", len(processedLines),
                "output_preview", truncateString(result, 100))
        
        return result</span>
}

// truncateString truncates a string to a maximum length for logging purposes
func truncateString(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:maxLen] + "..."</span>
}

// ConvertHTMLToMarkdown converts HTML content to Markdown format
func ConvertHTMLToMarkdown(htmlContent string) (string, error) <span class="cov8" title="1">{
        logging.UtilsLogger.Debug("Starting HTML to Markdown conversion",
                "input_length", len(htmlContent),
                "input_preview", truncateString(htmlContent, 100))

        converter := md.NewConverter("", true, nil)
        
        markdownText, err := converter.ConvertString(htmlContent)
        if err != nil </span><span class="cov0" title="0">{
                logging.UtilsLogger.Error("HTML to Markdown conversion failed", "error", err)
                return "", fmt.Errorf("failed to convert HTML to Markdown: %v", err)
        }</span>

        // Clean up the markdown - remove excessive whitespace
        <span class="cov8" title="1">cleanMarkdown := strings.TrimSpace(markdownText)

        logging.UtilsLogger.Debug("HTML to Markdown conversion completed",
                "input_length", len(htmlContent),
                "output_length", len(cleanMarkdown),
                "output_preview", truncateString(cleanMarkdown, 100))

        return cleanMarkdown, nil</span>
}

// ConvertHTMLToText converts HTML content to plain text format using goquery
func ConvertHTMLToText(htmlContent string) (string, error) <span class="cov8" title="1">{
        logging.UtilsLogger.Debug("Starting HTML to plain text conversion with goquery",
                "input_length", len(htmlContent),
                "input_preview", truncateString(htmlContent, 100))

        // Parse the HTML with goquery
        doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                logging.UtilsLogger.Error("HTML parsing with goquery failed", "error", err)
                return "", fmt.Errorf("failed to parse HTML with goquery: %v", err)
        }</span>

        <span class="cov8" title="1">var textBuilder strings.Builder

        // Process specific elements in order to avoid duplication
        processElement(doc.Find("body"), &amp;textBuilder)

        plainText := textBuilder.String()

        // Clean up the text - remove excessive whitespace and normalize spacing
        cleanText := strings.TrimSpace(plainText)
        
        // Replace multiple consecutive spaces with single space
        re := regexp.MustCompile(`[ \t]+`)
        cleanText = re.ReplaceAllString(cleanText, " ")
        
        // Replace multiple consecutive newlines with just two (paragraph breaks)
        re = regexp.MustCompile(`\n{3,}`)
        cleanText = re.ReplaceAllString(cleanText, "\n\n")
        
        // Clean up spacing around newlines
        re = regexp.MustCompile(`\n[ \t]+`)
        cleanText = re.ReplaceAllString(cleanText, "\n")
        re = regexp.MustCompile(`[ \t]+\n`)
        cleanText = re.ReplaceAllString(cleanText, "\n")

        logging.UtilsLogger.Debug("HTML to plain text conversion completed with goquery",
                "input_length", len(htmlContent),
                "output_length", len(cleanText),
                "output_preview", truncateString(cleanText, 100))

        return cleanText, nil</span>
}

// processElement recursively processes HTML elements to build text with proper structure
func processElement(selection *goquery.Selection, textBuilder *strings.Builder) <span class="cov8" title="1">{
        selection.Contents().Each(func(i int, s *goquery.Selection) </span><span class="cov8" title="1">{
                // If it's a text node, add it directly
                if goquery.NodeName(s) == "#text" </span><span class="cov8" title="1">{
                        text := strings.TrimSpace(s.Text())
                        if text != "" </span><span class="cov8" title="1">{
                                if textBuilder.Len() &gt; 0 &amp;&amp; !strings.HasSuffix(textBuilder.String(), " ") &amp;&amp; !strings.HasSuffix(textBuilder.String(), "\n") </span><span class="cov0" title="0">{
                                        textBuilder.WriteString(" ")
                                }</span>
                                <span class="cov8" title="1">textBuilder.WriteString(text)</span>
                        }
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">tagName := goquery.NodeName(s)
                
                // Handle different elements with appropriate formatting
                switch tagName </span>{
                case "h1", "h2", "h3", "h4", "h5", "h6":<span class="cov0" title="0">
                        // Headers: add spacing and the text
                        if textBuilder.Len() &gt; 0 </span><span class="cov0" title="0">{
                                textBuilder.WriteString("\n\n")
                        }</span>
                        <span class="cov0" title="0">textBuilder.WriteString(strings.TrimSpace(s.Text()))
                        textBuilder.WriteString("\n")</span>
                        
                case "p":<span class="cov8" title="1">
                        // Paragraphs: add spacing and process contents
                        if textBuilder.Len() &gt; 0 </span><span class="cov8" title="1">{
                                textBuilder.WriteString("\n\n")
                        }</span>
                        <span class="cov8" title="1">processElement(s, textBuilder)</span>
                        
                case "div":<span class="cov0" title="0">
                        // Divs: process contents with spacing
                        if textBuilder.Len() &gt; 0 &amp;&amp; !strings.HasSuffix(textBuilder.String(), "\n") </span><span class="cov0" title="0">{
                                textBuilder.WriteString("\n\n")
                        }</span>
                        <span class="cov0" title="0">processElement(s, textBuilder)</span>
                        
                case "br":<span class="cov0" title="0">
                        // Line breaks
                        textBuilder.WriteString("\n")</span>
                        
                case "ul", "ol":<span class="cov0" title="0">
                        // Lists: add spacing and process list items
                        if textBuilder.Len() &gt; 0 </span><span class="cov0" title="0">{
                                textBuilder.WriteString("\n")
                        }</span>
                        <span class="cov0" title="0">processElement(s, textBuilder)</span>
                        
                case "li":<span class="cov0" title="0">
                        // List items: add bullet point and process contents
                        textBuilder.WriteString("\n- ")
                        processElement(s, textBuilder)</span>
                        
                case "table":<span class="cov0" title="0">
                        // Tables: add spacing and process table contents
                        if textBuilder.Len() &gt; 0 </span><span class="cov0" title="0">{
                                textBuilder.WriteString("\n")
                        }</span>
                        <span class="cov0" title="0">processElement(s, textBuilder)</span>
                        
                case "tr":<span class="cov0" title="0">
                        // Table rows: add newline and process cells
                        if textBuilder.Len() &gt; 0 &amp;&amp; !strings.HasSuffix(textBuilder.String(), "\n") </span><span class="cov0" title="0">{
                                textBuilder.WriteString("\n")
                        }</span>
                        <span class="cov0" title="0">processElement(s, textBuilder)</span>
                        
                case "td", "th":<span class="cov0" title="0">
                        // Table cells: add tab separation and process contents
                        if textBuilder.Len() &gt; 0 &amp;&amp; !strings.HasSuffix(textBuilder.String(), "\n") &amp;&amp; !strings.HasSuffix(textBuilder.String(), "\t") </span><span class="cov0" title="0">{
                                textBuilder.WriteString("\t")
                        }</span>
                        <span class="cov0" title="0">processElement(s, textBuilder)</span>
                        
                default:<span class="cov0" title="0">
                        // For other elements, just process their contents
                        processElement(s, textBuilder)</span>
                }
        })
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
