
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>notebooks: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gebl/onenote-mcp-server/internal/notebooks/notebooks.go (1.0%)</option>
				
				<option value="file1">github.com/gebl/onenote-mcp-server/internal/pages/pages.go (8.4%)</option>
				
				<option value="file2">github.com/gebl/onenote-mcp-server/internal/sections/groups.go (0.0%)</option>
				
				<option value="file3">github.com/gebl/onenote-mcp-server/internal/sections/sections.go (0.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// notebooks.go - Notebook operations for the Microsoft Graph API client.
//
// This file contains all notebook-related operations including listing notebooks,
// searching within notebooks, and other notebook management functions.
//
// Key Features:
// - List all OneNote notebooks for the authenticated user with pagination
// - Search pages within notebooks with recursive traversal
// - Comprehensive notebook structure exploration
// - Automatic pagination handling for large notebook collections
//
// Operations Supported:
// - ListNotebooks: List all notebooks with automatic pagination
// - SearchPages: Search pages by title within a specific notebook
// - searchPagesRecursively: Internal function for recursive search
// - extractNotebookList: Helper function to extract notebook data
//
// Usage Example:
//   notebooks, err := graphClient.ListNotebooks()
//   if err != nil {
//       logging.NotebookLogger.Error("Failed to list notebooks", "error", err)
//   }
//
//   results, err := graphClient.SearchPages("meeting", notebookID)
//   if err != nil {
//       logging.NotebookLogger.Error("Failed to search pages", "error", err)
//   }

package notebooks

import (
        "context"
        "fmt"
        "strings"

        abstractions "github.com/microsoft/kiota-abstractions-go"
        msgraphmodels "github.com/microsoftgraph/msgraph-sdk-go/models"

        "github.com/gebl/onenote-mcp-server/internal/graph"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/pages"
        "github.com/gebl/onenote-mcp-server/internal/sections"
)

// NotebookClient provides notebook operations for the Graph API client
type NotebookClient struct {
        *graph.Client
}

// NewNotebookClient creates a new notebook client
func NewNotebookClient(client *graph.Client) *NotebookClient <span class="cov8" title="1">{
        return &amp;NotebookClient{Client: client}
}</span>

// ListNotebooks lists all OneNote notebooks for the authenticated user.
// Returns an array of notebook objects with ID and display name.
// This function handles pagination using the SDK's nextLink mechanism.
func (c *NotebookClient) ListNotebooks() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Info("Listing notebooks using Microsoft Graph SDK with paging")

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        result, err := c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
        logging.NotebookLogger.Debug("SDK result", "result", result)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Auth error detected in SDK call, attempting token refresh")
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Token refresh failed", "error", refreshErr)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">result, err = c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var notebooks []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                notebooks = append(notebooks, extractNotebookList(result)...)
        }</span>
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        for nextLink != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Fetching next page of notebooks", "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateNotebookCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch next page of notebooks: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.NotebookCollectionResponseable)
                notebooks = append(notebooks, extractNotebookList(pageResp)...)
                nextLink = pageResp.GetOdataNextLink()</span>
        }
        <span class="cov0" title="0">logging.NotebookLogger.Debug("Parsed notebooks", "notebooks", notebooks)
        logging.NotebookLogger.Info("Found notebooks", "count", len(notebooks))

        // Ensure we always return a slice, even if empty
        if notebooks == nil </span><span class="cov0" title="0">{
                notebooks = []map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">return notebooks, nil</span>
}

// ListNotebooksDetailed lists all OneNote notebooks for the authenticated user with full metadata.
// Returns an array of notebook objects with comprehensive details including timestamps, links, ownership, and metadata.
// This function handles pagination using the SDK's nextLink mechanism.
func (c *NotebookClient) ListNotebooksDetailed() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Info("Listing notebooks with detailed information using Microsoft Graph SDK with paging")

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        
        // Add debugging to understand why we're getting ArgumentNull error
        logging.NotebookLogger.Debug("About to call Graph SDK", 
                "graph_client_nil", c.GraphClient == nil,
                "access_token_empty", c.AccessToken == "",
                "access_token_length", len(c.AccessToken))
        
        if c.GraphClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GraphClient is nil")
        }</span>
        
        <span class="cov0" title="0">result, err := c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
        logging.NotebookLogger.Debug("SDK result for detailed notebooks", "result", result)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Auth error detected in SDK call, attempting token refresh")
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Token refresh failed", "error", refreshErr)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">result, err = c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var notebooks []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                notebooks = append(notebooks, extractDetailedNotebookList(result)...)
        }</span>
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        for nextLink != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Fetching next page of detailed notebooks", "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateNotebookCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch next page of detailed notebooks: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.NotebookCollectionResponseable)
                notebooks = append(notebooks, extractDetailedNotebookList(pageResp)...)
                nextLink = pageResp.GetOdataNextLink()</span>
        }
        <span class="cov0" title="0">logging.NotebookLogger.Debug("Parsed detailed notebooks", "notebooks", notebooks)
        logging.NotebookLogger.Info("Found detailed notebooks", "count", len(notebooks))

        // Ensure we always return a slice, even if empty
        if notebooks == nil </span><span class="cov0" title="0">{
                notebooks = []map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">return notebooks, nil</span>
}

// GetDetailedNotebookByName retrieves comprehensive notebook information by display name.
// Returns all available attributes including timestamps, links, ownership, and metadata.
func (c *NotebookClient) GetDetailedNotebookByName(notebookName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Info("Getting detailed notebook information by name", "notebook_name", notebookName)

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        result, err := c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Auth error detected in SDK call, attempting token refresh")
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Token refresh failed", "error", refreshErr)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">result, err = c.GraphClient.Me().Onenote().Notebooks().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        // Process all pages of results to find the notebook by name
        <span class="cov0" title="0">var allNotebooks []msgraphmodels.Notebookable
        if result != nil </span><span class="cov0" title="0">{
                allNotebooks = append(allNotebooks, result.GetValue()...)
        }</span>

        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        for nextLink != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Fetching next page of notebooks for detailed search", "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateNotebookCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch next page of notebooks: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.NotebookCollectionResponseable)
                allNotebooks = append(allNotebooks, pageResp.GetValue()...)
                nextLink = pageResp.GetOdataNextLink()</span>
        }

        // Search for the notebook by name (case-insensitive)
        <span class="cov0" title="0">for _, nb := range allNotebooks </span><span class="cov0" title="0">{
                if nb.GetDisplayName() != nil &amp;&amp; strings.EqualFold(*nb.GetDisplayName(), notebookName) </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Found notebook by name", "notebook_name", notebookName, "id", *nb.GetId())

                        // Extract detailed information for this notebook
                        detailedInfo := extractDetailedNotebookInfo(nb)

                        logging.NotebookLogger.Info("Retrieved detailed notebook information", "notebook_name", notebookName, "attributes_count", len(detailedInfo))
                        return detailedInfo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("notebook with name '%s' not found", notebookName)</span>
}

// extractNotebookList extracts notebook info from a NotebookCollectionResponseable
func extractNotebookList(result msgraphmodels.NotebookCollectionResponseable) []map[string]interface{} <span class="cov0" title="0">{
        var notebooks []map[string]interface{}
        for _, nb := range result.GetValue() </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                if nb.GetId() != nil </span><span class="cov0" title="0">{
                        m["notebookId"] = *nb.GetId()
                }</span>
                <span class="cov0" title="0">if nb.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        m["displayName"] = *nb.GetDisplayName()
                }</span>
                <span class="cov0" title="0">notebooks = append(notebooks, m)</span>
        }
        <span class="cov0" title="0">return notebooks</span>
}

// extractDetailedNotebookList extracts comprehensive notebook info with all available attributes
func extractDetailedNotebookList(result msgraphmodels.NotebookCollectionResponseable) []map[string]interface{} <span class="cov0" title="0">{
        var notebooks []map[string]interface{}
        for _, nb := range result.GetValue() </span><span class="cov0" title="0">{
                m := extractDetailedNotebookInfo(nb)
                notebooks = append(notebooks, m)
        }</span>
        <span class="cov0" title="0">return notebooks</span>
}

// extractDetailedNotebookInfo extracts all available attributes from a single notebook
func extractDetailedNotebookInfo(nb msgraphmodels.Notebookable) map[string]interface{} <span class="cov0" title="0">{
        m := map[string]interface{}{}

        // Basic properties
        if nb.GetId() != nil </span><span class="cov0" title="0">{
                m["id"] = *nb.GetId()
                m["notebookId"] = *nb.GetId() // Keep backward compatibility
        }</span>
        <span class="cov0" title="0">if nb.GetDisplayName() != nil </span><span class="cov0" title="0">{
                m["displayName"] = *nb.GetDisplayName()
        }</span>

        // Timestamps
        <span class="cov0" title="0">if nb.GetCreatedDateTime() != nil </span><span class="cov0" title="0">{
                m["createdDateTime"] = nb.GetCreatedDateTime().Format("2006-01-02T15:04:05Z")
        }</span>
        <span class="cov0" title="0">if nb.GetLastModifiedDateTime() != nil </span><span class="cov0" title="0">{
                m["lastModifiedDateTime"] = nb.GetLastModifiedDateTime().Format("2006-01-02T15:04:05Z")
        }</span>

        // Metadata properties
        <span class="cov0" title="0">if nb.GetIsDefault() != nil </span><span class="cov0" title="0">{
                m["isDefault"] = *nb.GetIsDefault()
        }</span>
        <span class="cov0" title="0">if nb.GetIsShared() != nil </span><span class="cov0" title="0">{
                m["isShared"] = *nb.GetIsShared()
        }</span>
        <span class="cov0" title="0">if nb.GetUserRole() != nil </span><span class="cov0" title="0">{
                m["userRole"] = nb.GetUserRole().String()
        }</span>

        // Note: Links and API endpoints are excluded from the response

        // Identity information
        <span class="cov0" title="0">if createdBy := nb.GetCreatedBy(); createdBy != nil </span><span class="cov0" title="0">{
                createdByMap := extractIdentitySet(createdBy)
                if len(createdByMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["createdBy"] = createdByMap
                }</span>
        }
        <span class="cov0" title="0">if lastModifiedBy := nb.GetLastModifiedBy(); lastModifiedBy != nil </span><span class="cov0" title="0">{
                lastModifiedByMap := extractIdentitySet(lastModifiedBy)
                if len(lastModifiedByMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["lastModifiedBy"] = lastModifiedByMap
                }</span>
        }

        <span class="cov0" title="0">return m</span>
}

// extractIdentitySet extracts identity information from an IdentitySet
func extractIdentitySet(identitySet msgraphmodels.IdentitySetable) map[string]interface{} <span class="cov0" title="0">{
        m := map[string]interface{}{}

        if user := identitySet.GetUser(); user != nil </span><span class="cov0" title="0">{
                userMap := map[string]interface{}{}
                if user.GetId() != nil </span><span class="cov0" title="0">{
                        userMap["id"] = *user.GetId()
                }</span>
                <span class="cov0" title="0">if user.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        userMap["displayName"] = *user.GetDisplayName()
                }</span>
                <span class="cov0" title="0">if len(userMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["user"] = userMap
                }</span>
        }

        <span class="cov0" title="0">if application := identitySet.GetApplication(); application != nil </span><span class="cov0" title="0">{
                appMap := map[string]interface{}{}
                if application.GetId() != nil </span><span class="cov0" title="0">{
                        appMap["id"] = *application.GetId()
                }</span>
                <span class="cov0" title="0">if application.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        appMap["displayName"] = *application.GetDisplayName()
                }</span>
                <span class="cov0" title="0">if len(appMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["application"] = appMap
                }</span>
        }

        <span class="cov0" title="0">if device := identitySet.GetDevice(); device != nil </span><span class="cov0" title="0">{
                deviceMap := map[string]interface{}{}
                if device.GetId() != nil </span><span class="cov0" title="0">{
                        deviceMap["id"] = *device.GetId()
                }</span>
                <span class="cov0" title="0">if device.GetDisplayName() != nil </span><span class="cov0" title="0">{
                        deviceMap["displayName"] = *device.GetDisplayName()
                }</span>
                <span class="cov0" title="0">if len(deviceMap) &gt; 0 </span><span class="cov0" title="0">{
                        m["device"] = deviceMap
                }</span>
        }

        <span class="cov0" title="0">return m</span>
}

// SearchPages searches for pages by title within a specific notebook.
// This function recursively searches through all sections and section groups.
// Returns an array of matching pages with section context information.
//
// Parameters:
// - query: the search string to match in page titles (case-insensitive)
// - notebookID: the ID of the notebook to search within
//
// Returns:
// - pageId: unique identifier for the page
// - pageTitle: title of the page
// - sectionId: ID of the section containing the page
// - sectionName: name of the section containing the page
// - sectionPath: full hierarchy path (e.g., "Notebook/Section Group/Section")
func (c *NotebookClient) SearchPages(query string, notebookID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Debug("Starting SearchPages", "query", query, "notebook_id", notebookID)
        logging.NotebookLogger.Info("Searching pages", "query", query, "notebook_id", notebookID)

        // Check token status
        if c.TokenManager != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Token manager available, checking token expiration")
                if c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Token is expired, attempting refresh before SDK call")
                        if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                                logging.NotebookLogger.Debug("Failed to refresh token", "error", err)
                                return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                        }</span>
                        <span class="cov0" title="0">logging.NotebookLogger.Debug("Token refresh completed successfully")</span>
                } else<span class="cov0" title="0"> {
                        logging.NotebookLogger.Debug("Token is still valid, no refresh needed")
                }</span>
        } else<span class="cov0" title="0"> {
                logging.NotebookLogger.Debug("No token manager available, using static token")
        }</span>

        // Sanitize the notebook ID
        <span class="cov0" title="0">sanitizedNotebookID, err := c.Client.SanitizeOneNoteID(notebookID, "notebookID")
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Invalid notebook ID", "error", err)
                return nil, err
        }</span>

        // First, get all sections in the notebook
        <span class="cov0" title="0">logging.NotebookLogger.Debug("Fetching sections for notebook", "notebook_id", sanitizedNotebookID)
        sections, err := c.ListSections(sanitizedNotebookID)
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to fetch sections", "error", err)
                return nil, fmt.Errorf("failed to fetch sections for notebook %s: %v", notebookID, err)
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Found sections in notebook", "count", len(sections))

        // Recursively search all sections and section groups
        var allPages []map[string]interface{}

        // Start recursive search from the notebook
        notebookPages, err := c.searchPagesRecursively(sanitizedNotebookID, query, "notebook", "")
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to search notebook recursively", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">allPages = append(allPages, notebookPages...)
        logging.NotebookLogger.Debug("Found total pages in notebook search", "count", len(allPages))

        logging.NotebookLogger.Info("Found pages matching query", "count", len(allPages), "query", query, "notebook_id", notebookID)

        return allPages, nil</span>
}

// searchPagesRecursively searches for pages recursively through sections and section groups.
// This function traverses the entire container hierarchy, searching all sections and
// recursively exploring section groups to find pages that match the query.
//
// Parameters:
// - containerID: the ID of the container (notebook or section group) to search
// - query: the search string to match in page titles (case-insensitive)
// - containerType: human-readable type for logging ("notebook" or "section group")
// - parentPath: the hierarchy path leading to this container
//
// Returns a slice of page metadata maps with section context and an error, if any.
func (c *NotebookClient) searchPagesRecursively(containerID, query, containerType, parentPath string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.NotebookLogger.Debug("Searching recursively", "container_type", containerType, "container_id", containerID, "path", parentPath)

        var allPages []map[string]interface{}

        // Get sections in this container
        sections, err := c.ListSections(containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to get sections", "container_type", containerType, "container_id", containerID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Found sections", "count", len(sections), "container_type", containerType, "container_id", containerID)

        // Search pages in each section
        for i, section := range sections </span><span class="cov0" title="0">{
                sectionID, ok := section["id"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Section has no valid ID, skipping", "index", i+1)
                        continue</span>
                }

                <span class="cov0" title="0">sectionName, _ := section["displayName"].(string)
                sectionPath := parentPath + "/" + sectionName
                logging.NotebookLogger.Debug("Searching section", "name", sectionName, "id", sectionID, "path", sectionPath)

                // Get all pages in this section
                sectionPages, errPages := c.ListPages(sectionID)
                if errPages != nil </span><span class="cov0" title="0">{
                        logging.NotebookLogger.Debug("Failed to get pages in section", "section_id", sectionID, "error", errPages)
                        continue</span>
                }

                <span class="cov0" title="0">logging.NotebookLogger.Debug("Found pages in section", "count", len(sectionPages), "section_name", sectionName)

                // Filter pages by title
                queryLower := strings.ToLower(query)
                for _, page := range sectionPages </span><span class="cov0" title="0">{
                        if title, ok := page["title"].(string); ok </span><span class="cov0" title="0">{
                                titleLower := strings.ToLower(title)
                                if strings.Contains(titleLower, queryLower) </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Page matches query", "title", title, "section", sectionName)
                                        // Add context information
                                        page["sectionName"] = sectionName
                                        page["sectionId"] = sectionID
                                        page["sectionPath"] = sectionPath
                                        allPages = append(allPages, page)
                                }</span>
                        }
                }
        }

        // Get section groups in this container
        <span class="cov0" title="0">sectionGroups, err := c.ListSectionGroups(containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.NotebookLogger.Debug("Failed to get section groups", "container_type", containerType, "container_id", containerID, "error", err)
                // Don't return error, just continue without section groups
        }</span> else<span class="cov0" title="0"> {
                logging.NotebookLogger.Debug("Found section groups", "count", len(sectionGroups), "container_type", containerType, "container_id", containerID)

                // Recursively search each section group
                for i, sectionGroup := range sectionGroups </span><span class="cov0" title="0">{
                        sectionGroupID, ok := sectionGroup["id"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                logging.NotebookLogger.Debug("Section group has no valid ID, skipping", "index", i+1)
                                continue</span>
                        }

                        <span class="cov0" title="0">sectionGroupName, _ := sectionGroup["displayName"].(string)
                        sectionGroupPath := parentPath + "/" + sectionGroupName
                        logging.NotebookLogger.Debug("Recursively searching section group",
                                "section_group_name", sectionGroupName, "section_group_id", sectionGroupID, "section_group_path", sectionGroupPath)

                        // Recursively search this section group
                        sectionGroupPages, err := c.searchPagesRecursively(sectionGroupID, query, "section group", sectionGroupPath)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.NotebookLogger.Debug("Failed to search section group", "section_group_id", sectionGroupID, "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">logging.NotebookLogger.Debug("Found matching pages in section group", "count", len(sectionGroupPages), "section_group_name", sectionGroupName)
                        allPages = append(allPages, sectionGroupPages...)</span>
                }
        }

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Recursive search completed",
                "container_type", containerType, "container_id", containerID, "pages_count", len(allPages))
        return allPages, nil</span>
}

func (c *NotebookClient) ListSections(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Delegate to the sections client
        sectionClient := sections.NewSectionClient(c.Client)
        return sectionClient.ListSections(containerID)
}</span>

func (c *NotebookClient) ListSectionGroups(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Delegate to the sections client
        sectionClient := sections.NewSectionClient(c.Client)
        return sectionClient.ListSectionGroups(containerID)
}</span>

func (c *NotebookClient) ListPages(sectionID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Delegate to the pages client
        pageClient := pages.NewPageClient(c.Client)
        return pageClient.ListPages(sectionID)
}</span>

// GetDefaultNotebookID returns the ID of the default notebook specified in the config.
// If no default notebook is configured, it returns an error.
func GetDefaultNotebookID(client *graph.Client, config *graph.Config) (string, error) <span class="cov8" title="1">{
        if config == nil || config.NotebookName == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no default notebook name configured")
        }</span>

        <span class="cov0" title="0">logging.NotebookLogger.Debug("Looking up default notebook", "name", config.NotebookName)

        // Create a notebook client to list notebooks
        notebookClient := NewNotebookClient(client)

        // List all notebooks to find the one with the matching name
        notebooks, err := notebookClient.ListNotebooks()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list notebooks: %v", err)
        }</span>

        // Search for the notebook with the matching name
        <span class="cov0" title="0">for _, notebook := range notebooks </span><span class="cov0" title="0">{
                if displayName, exists := notebook["displayName"].(string); exists </span><span class="cov0" title="0">{
                        if displayName == config.NotebookName </span><span class="cov0" title="0">{
                                if id, exists := notebook["notebookId"].(string); exists </span><span class="cov0" title="0">{
                                        logging.NotebookLogger.Debug("Found default notebook", "name", displayName, "id", id)
                                        return id, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("default notebook '%s' not found", config.NotebookName)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// pages.go - Page operations for the Microsoft Graph API client.
//
// This file contains all page-related operations including listing pages,
// creating, updating, deleting, copying, and moving pages, as well as
// handling page items (images, files) and content management.
//
// Key Features:
// - Complete page CRUD operations (Create, Read, Update, Delete)
// - Page content management with HTML support
// - Page item handling (images, files, objects)
// - Advanced content updates with commands
// - Asynchronous page operations (copy, move)
// - Image optimization and metadata extraction
// - HTML parsing and content extraction
//
// Operations Supported:
// - ListPages: List all pages in a section with pagination
// - GetPageContent: Retrieve page HTML content
// - CreatePage: Create new pages with HTML content
// - UpdatePageContent: Update page content with advanced commands
// - UpdatePageContentSimple: Simple content replacement
// - DeletePage: Delete pages by ID
// - CopyPage: Copy pages between sections with async operations
// - MovePage: Move pages between sections
// - GetPageItem: Get complete page item data with binary content
// - ListPageItems: List embedded items in a page
//
// Usage Example:
//   pageClient := pages.NewPageClient(graphClient)
//   pages, err := pageClient.ListPages(sectionID)
//   if err != nil {
//       logging.PageLogger.Error("Failed to list pages", "error", err)
//   }
//
//   result, err := pageClient.CreatePage(sectionID, "My Page", "&lt;html&gt;&lt;body&gt;Content&lt;/body&gt;&lt;/html&gt;")
//   if err != nil {
//       logging.PageLogger.Error("Failed to create page", "error", err)
//   }

package pages

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "math/rand"
        "mime/multipart"
        "net/http"
        "net/textproto"
        "regexp"
        "strings"
        "time"

        "golang.org/x/net/html"

        abstractions "github.com/microsoft/kiota-abstractions-go"
        msgraphmodels "github.com/microsoftgraph/msgraph-sdk-go/models"

        "github.com/gebl/onenote-mcp-server/internal/graph"
        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

const (
        imgTag    = "img"
        objectTag = "object"
)

// PageClient provides page-specific operations
type PageClient struct {
        *graph.Client
}

// NewPageClient creates a new PageClient
func NewPageClient(client *graph.Client) *PageClient <span class="cov8" title="1">{
        return &amp;PageClient{Client: client}
}</span>

// ResolvePageNotebook resolves which notebook contains a specific page ID
// This method implements the authorization.PageNotebookResolver interface
func (pc *PageClient) ResolvePageNotebook(ctx context.Context, pageID string) (notebookID string, notebookName string, sectionID string, sectionName string, err error) <span class="cov0" title="0">{
        logging.PageLogger.Debug("Resolving notebook ownership for page",
                "page_id", pageID)

        // Use Graph API to get page metadata including parent section and notebook
        // Note: Using $expand instead of $select because Graph API v1.0 may not return parent objects with $select
        url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s?$expand=parentSection,parentNotebook", pageID)
        
        response, err := pc.Client.MakeAuthenticatedRequest("GET", url, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to resolve page notebook via Graph API",
                        "page_id", pageID,
                        "error", err.Error())
                return "", "", "", "", fmt.Errorf("failed to resolve page notebook: %w", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        if response.StatusCode != 200 </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Graph API returned error when resolving page notebook",
                        "page_id", pageID,
                        "status_code", response.StatusCode)
                return "", "", "", "", fmt.Errorf("Graph API error %d when resolving page notebook", response.StatusCode)
        }</span>

        <span class="cov0" title="0">var pageInfo struct {
                ID             string `json:"id"`
                Title          string `json:"title"`
                ParentSection  *struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"parentSection"`
                ParentNotebook *struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"parentNotebook"`
        }

        // Read response body to log it for debugging
        content, err := pc.ReadResponseBody(response, "ResolvePageNotebook")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to read response body for page notebook resolution",
                        "page_id", pageID,
                        "error", err.Error())
                return "", "", "", "", fmt.Errorf("failed to read page notebook response body: %w", err)
        }</span>
        
        // Log the actual JSON response for debugging
        <span class="cov0" title="0">logging.PageLogger.Debug("Page notebook resolution response", "page_id", pageID, "response_body", string(content))
        
        if err := json.Unmarshal(content, &amp;pageInfo); err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to decode page notebook resolution response",
                        "page_id", pageID,
                        "error", err.Error())
                return "", "", "", "", fmt.Errorf("failed to decode page notebook response: %w", err)
        }</span>

        // Log the parsed information for debugging
        <span class="cov0" title="0">logging.PageLogger.Debug("Parsed page info from JSON", 
                "page_id", pageID,
                "parsed_page_id", pageInfo.ID,
                "parsed_title", pageInfo.Title,
                "parent_notebook_nil", pageInfo.ParentNotebook == nil,
                "parent_section_nil", pageInfo.ParentSection == nil)

        // Extract the information
        if pageInfo.ParentNotebook != nil </span><span class="cov0" title="0">{
                notebookID = pageInfo.ParentNotebook.ID
                notebookName = pageInfo.ParentNotebook.DisplayName
                logging.PageLogger.Debug("Extracted notebook info", "page_id", pageID, "notebook_id", notebookID, "notebook_name", notebookName)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("ParentNotebook is nil in response", "page_id", pageID)
        }</span>
        
        <span class="cov0" title="0">if pageInfo.ParentSection != nil </span><span class="cov0" title="0">{
                sectionID = pageInfo.ParentSection.ID
                sectionName = pageInfo.ParentSection.DisplayName
                logging.PageLogger.Debug("Extracted section info", "page_id", pageID, "section_id", sectionID, "section_name", sectionName)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("ParentSection is nil in response", "page_id", pageID)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Info("Successfully resolved page notebook ownership",
                "page_id", pageID,
                "notebook_id", notebookID,
                "notebook_name", notebookName,
                "section_id", sectionID,
                "section_name", sectionName)

        return notebookID, notebookName, sectionID, sectionName, nil</span>
}

// PageItemData represents the complete data for a OneNote page item (e.g., image) including metadata and content.
type PageItemData struct {
        ContentType string            `json:"contentType"` // MIME type of the page item
        Filename    string            `json:"filename"`    // Suggested filename for the page item
        Size        int64             `json:"size"`        // Size of the page item in bytes
        Content     []byte            `json:"content"`     // Raw binary content of the page item
        TagName     string            `json:"tagName"`     // HTML tag name (img, object, etc.)
        Attributes  map[string]string `json:"attributes"`  // All HTML attributes from the tag
        OriginalURL string            `json:"originalUrl"` // Original URL from the HTML tag
}

// UpdateCommand represents a single update operation for OneNote page content.
// Based on Microsoft Graph OneNote API documentation.
type UpdateCommand struct {
        Target   string `json:"target"`             // Element to update (data-id, generated id, body, title)
        Action   string `json:"action"`             // Action to perform (append, insert, prepend, replace)
        Position string `json:"position,omitempty"` // Position for insert/append (before, after) - omitted for append action
        Content  string `json:"content"`            // HTML content to add/replace
}

// MarshalJSON implements custom JSON marshaling to exclude position field for append actions
func (uc UpdateCommand) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type UpdateCommandAlias UpdateCommand // Create alias to avoid infinite recursion

        // For append action, create a copy without the position field
        if uc.Action == "append" </span><span class="cov8" title="1">{
                alias := UpdateCommandAlias{
                        Target:  uc.Target,
                        Action:  uc.Action,
                        Content: uc.Content,
                        // Position field is omitted
                }
                return json.Marshal(alias)
        }</span>

        // For other actions, marshal normally
        <span class="cov8" title="1">return json.Marshal(UpdateCommandAlias(uc))</span>
}

// PageItemInfo represents a parsed page item with attributes and extracted ID
type PageItemInfo struct {
        TagName     string            `json:"tagName"`     // "img" or "object"
        PageItemID  string            `json:"pageItemId"`  // Extracted from src/data URL
        Attributes  map[string]string `json:"attributes"`  // All attributes from the tag
        OriginalURL string            `json:"originalUrl"` // Original src/data URL
}

// ListPages fetches all pages in a section by sectionID using the Microsoft Graph SDK.
// Returns a slice of page metadata maps and an error, if any.
// This function handles pagination using the SDK's nextLink mechanism.
func (c *PageClient) ListPages(sectionID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting ListPages operation", "section_id", sectionID)

        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before ListPages", "section_id", sectionID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during ListPages", "section_id", sectionID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for ListPages", "section_id", sectionID)</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        logging.PageLogger.Debug("Making Graph API call to list pages", "section_id", sectionID)
        result, err := c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Initial Graph API call failed", "section_id", sectionID, "error", err)
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Authentication error detected, attempting token refresh", "section_id", sectionID)
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Token refresh failed after auth error", "section_id", sectionID, "refresh_error", refreshErr, "original_error", err)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed, retrying Graph API call", "section_id", sectionID)
                                result, err = c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Graph API call failed after token refresh", "section_id", sectionID, "error", err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Graph API call succeeded after token refresh", "section_id", sectionID)</span>
                        } else<span class="cov0" title="0"> {
                                logging.PageLogger.Error("Authentication error but no token manager available", "section_id", sectionID, "error", err)
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.PageLogger.Error("Graph API call failed with non-auth error", "section_id", sectionID, "error", err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var pages []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                pages = append(pages, extractOnenotePageList(result)...)
                logging.PageLogger.Debug("Initial page batch retrieved", "section_id", sectionID, "page_count", len(pages))
        }</span>
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        paginationCount := 0
        for nextLink != nil </span><span class="cov0" title="0">{
                paginationCount++
                logging.PageLogger.Debug("Processing pagination", "section_id", sectionID, "pagination_count", paginationCount, "next_link", *nextLink)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateOnenotePageCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Pagination request failed", "section_id", sectionID, "pagination_count", paginationCount, "error", err)
                        return nil, fmt.Errorf("failed to fetch next page of pages: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.OnenotePageCollectionResponseable)
                batchPages := extractOnenotePageList(pageResp)
                pages = append(pages, batchPages...)
                logging.PageLogger.Debug("Pagination batch retrieved", "section_id", sectionID, "pagination_count", paginationCount, "batch_size", len(batchPages), "total_pages", len(pages))
                nextLink = pageResp.GetOdataNextLink()</span>
        }
        <span class="cov0" title="0">logging.PageLogger.Info("ListPages completed successfully", "section_id", sectionID, "total_pages", len(pages), "pagination_requests", paginationCount)
        return pages, nil</span>
}

// ListPagesWithProgress fetches all pages in a section with progress updates for long-running operations.
// Provides granular progress notifications during pagination to prevent client timeouts.
func (c *PageClient) ListPagesWithProgress(sectionID string, progressCallback func(progress int, message string)) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting ListPagesWithProgress operation", "section_id", sectionID)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(0, "Initializing page listing...")
        }</span>

        <span class="cov0" title="0">if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before ListPagesWithProgress", "section_id", sectionID)
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(5, "Refreshing authentication token...")
                }</span>
                <span class="cov0" title="0">if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during ListPagesWithProgress", "section_id", sectionID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for ListPagesWithProgress", "section_id", sectionID)</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(10, "Making initial API request...")
        }</span>
        
        <span class="cov0" title="0">logging.PageLogger.Debug("Making Graph API call to list pages with progress", "section_id", sectionID)
        result, err := c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Initial Graph API call failed", "section_id", sectionID, "error", err)
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Authentication error detected, attempting token refresh", "section_id", sectionID)
                        if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(15, "Authentication error, refreshing token...")
                        }</span>
                        <span class="cov0" title="0">if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Token refresh failed after auth error", "section_id", sectionID, "refresh_error", refreshErr, "original_error", err)
                                        return nil, fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                        progressCallback(20, "Token refreshed, retrying API request...")
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed, retrying Graph API call", "section_id", sectionID)
                                result, err = c.GraphClient.Me().Onenote().Sections().ByOnenoteSectionId(sectionID).Pages().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Graph API call failed after token refresh", "section_id", sectionID, "error", err)
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Graph API call succeeded after token refresh", "section_id", sectionID)</span>
                        } else<span class="cov0" title="0"> {
                                logging.PageLogger.Error("Authentication error but no token manager available", "section_id", sectionID, "error", err)
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.PageLogger.Error("Graph API call failed with non-auth error", "section_id", sectionID, "error", err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var pages []map[string]interface{}
        if result != nil </span><span class="cov0" title="0">{
                pages = append(pages, extractOnenotePageList(result)...)
                logging.PageLogger.Debug("Initial page batch retrieved", "section_id", sectionID, "page_count", len(pages))
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(30, fmt.Sprintf("Retrieved initial batch: %d pages", len(pages)))
                }</span>
        }
        
        <span class="cov0" title="0">nextLink := result.GetOdataNextLink()
        paginationCount := 0
        totalExpectedProgress := 70 // Reserve 30% for pagination, 70% total for completion
        
        // Estimate pagination progress - we don't know total pages yet, so we'll increment gradually
        for nextLink != nil </span><span class="cov0" title="0">{
                paginationCount++
                // Progressive pagination progress: 30% + (paginationCount * 10%) up to 70%
                currentProgress := 30 + (paginationCount * 10)
                if currentProgress &gt; totalExpectedProgress </span><span class="cov0" title="0">{
                        currentProgress = totalExpectedProgress
                }</span>
                
                <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(currentProgress, fmt.Sprintf("Loading page batch %d...", paginationCount+1))
                }</span>
                
                <span class="cov0" title="0">logging.PageLogger.Debug("Processing pagination with progress", "section_id", sectionID, "pagination_count", paginationCount, "progress", currentProgress)
                requestInfo := abstractions.NewRequestInformation()
                requestInfo.UrlTemplate = *nextLink
                requestInfo.Method = abstractions.GET
                resp, err := c.GraphClient.GetAdapter().Send(ctx, requestInfo, msgraphmodels.CreateOnenotePageCollectionResponseFromDiscriminatorValue, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Pagination request failed", "section_id", sectionID, "pagination_count", paginationCount, "error", err)
                        return nil, fmt.Errorf("failed to fetch next page of pages: %v", err)
                }</span>
                <span class="cov0" title="0">pageResp := resp.(msgraphmodels.OnenotePageCollectionResponseable)
                batchPages := extractOnenotePageList(pageResp)
                pages = append(pages, batchPages...)
                logging.PageLogger.Debug("Pagination batch retrieved with progress", "section_id", sectionID, "pagination_count", paginationCount, "batch_size", len(batchPages), "total_pages", len(pages))
                
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(currentProgress+5, fmt.Sprintf("Processed batch %d: %d total pages", paginationCount+1, len(pages)))
                }</span>
                
                <span class="cov0" title="0">nextLink = pageResp.GetOdataNextLink()</span>
        }
        
        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(100, fmt.Sprintf("Completed: %d pages loaded", len(pages)))
        }</span>
        
        <span class="cov0" title="0">logging.PageLogger.Info("ListPagesWithProgress completed successfully", "section_id", sectionID, "total_pages", len(pages), "pagination_requests", paginationCount)
        return pages, nil</span>
}

// extractOnenotePageList extracts page info from a OnenotePageCollectionResponseable
func extractOnenotePageList(result msgraphmodels.OnenotePageCollectionResponseable) []map[string]interface{} <span class="cov0" title="0">{
        var pages []map[string]interface{}
        for _, page := range result.GetValue() </span><span class="cov0" title="0">{
                m := map[string]interface{}{}
                if page.GetId() != nil </span><span class="cov0" title="0">{
                        m["pageId"] = *page.GetId()
                }</span>
                <span class="cov0" title="0">if page.GetTitle() != nil </span><span class="cov0" title="0">{
                        m["title"] = *page.GetTitle()
                }</span>
                <span class="cov0" title="0">pages = append(pages, m)</span>
        }
        <span class="cov0" title="0">return pages</span>
}

// GetPageContent fetches the HTML content of a page by pageID using the Microsoft Graph SDK.
// pageID: ID of the page to fetch content for.
// forUpdate: Optional boolean that when true includes includeIDs=true parameter for update operations.
// Returns the HTML content as a string and an error, if any.
func (c *PageClient) GetPageContent(pageID string, forUpdate ...bool) (string, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting GetPageContent operation", "page_id", pageID, "for_update", len(forUpdate) &gt; 0 &amp;&amp; forUpdate[0])

        // Check if token is expired and refresh if needed
        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before GetPageContent", "page_id", pageID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during GetPageContent", "page_id", pageID, "error", err)
                        return "", fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for GetPageContent", "page_id", pageID)</span>
        }

        // Check if forUpdate parameter is provided and true
        <span class="cov0" title="0">includeIDs := false
        if len(forUpdate) &gt; 0 &amp;&amp; forUpdate[0] </span><span class="cov0" title="0">{
                includeIDs = true
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("GetPageContent parameters determined", "page_id", pageID, "include_ids", includeIDs)

        ctx := context.Background()

        // Use direct HTTP call to support includeIDs parameter
        if includeIDs </span><span class="cov0" title="0">{
                // Use direct HTTP call with includeIDs parameter
                url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true", pageID)
                logging.PageLogger.Debug("Using direct HTTP call with includeIDs", "page_id", pageID, "url", url)

                content, err := httputils.SafeRequestWithBody(
                        c.MakeAuthenticatedRequest,
                        c.HandleHTTPResponse,
                        c.ReadResponseBody,
                        "GET", url, nil, nil,
                        "GetPageContent",
                )
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Direct HTTP request failed for GetPageContent", "page_id", pageID, "url", url, "error", err)
                        return "", err
                }</span>

                <span class="cov0" title="0">logging.PageLogger.Info("GetPageContent completed successfully via HTTP", "page_id", pageID, "content_length", len(content), "include_ids", true)
                return string(content), nil</span>
        }
        // Use SDK for normal content retrieval
        <span class="cov0" title="0">logging.PageLogger.Debug("Using Graph SDK for normal content retrieval", "page_id", pageID)
        content, err := c.GraphClient.Me().Onenote().Pages().ByOnenotePageId(pageID).Content().Get(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("SDK content retrieval failed", "page_id", pageID, "error", err)
                // Check if this is an auth error and try token refresh
                if strings.Contains(err.Error(), "JWT") || strings.Contains(err.Error(), "401") || strings.Contains(err.Error(), "403") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Authentication error detected in SDK call, attempting token refresh", "page_id", pageID)
                        if c.TokenManager != nil &amp;&amp; c.OAuthConfig != nil </span><span class="cov0" title="0">{
                                if refreshErr := c.RefreshTokenIfNeeded(); refreshErr != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("Token refresh failed after SDK auth error", "page_id", pageID, "refresh_error", refreshErr, "original_error", err)
                                        return "", fmt.Errorf("authentication failed and token refresh failed: %v", refreshErr)
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed, retrying SDK call", "page_id", pageID)
                                // Retry the operation with fresh token
                                content, err = c.GraphClient.Me().Onenote().Pages().ByOnenotePageId(pageID).Content().Get(ctx, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.PageLogger.Error("SDK call failed after token refresh", "page_id", pageID, "error", err)
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">logging.PageLogger.Debug("SDK call succeeded after token refresh", "page_id", pageID)</span>
                        } else<span class="cov0" title="0"> {
                                logging.PageLogger.Error("Authentication error but no token manager available", "page_id", pageID, "error", err)
                                return "", err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logging.PageLogger.Error("SDK call failed with non-auth error", "page_id", pageID, "error", err)
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">logging.PageLogger.Info("GetPageContent completed successfully via SDK", "page_id", pageID, "content_length", len(content), "include_ids", false)
        return string(content), nil</span>
}

// CreatePage creates a new page in a section.
// sectionID: ID of the section to create the page in.
// title: Title of the new page.
// content: HTML content for the page.
// Returns the created page metadata and an error, if any.
func (c *PageClient) CreatePage(sectionID, title, content string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting CreatePage operation", "section_id", sectionID, "title", title, "content_length", len(content))
        // Log the original content at configurable verbosity level
        logging.LogContent(logging.PageLogger, slog.LevelDebug, "CreatePage original content", "section_id", sectionID, "title", title, "original_content", content)
        url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages", sectionID)

        // Ensure the HTML content includes a &lt;title&gt; tag
        finalContent := content
        if !strings.Contains(strings.ToLower(content), "&lt;title&gt;") </span><span class="cov0" title="0">{
                finalContent = "&lt;html&gt;&lt;head&gt;&lt;title&gt;" + htmlEscape(title) + "&lt;/title&gt;&lt;/head&gt;&lt;body&gt;" + content + "&lt;/body&gt;&lt;/html&gt;"
                logging.PageLogger.Debug("Added HTML wrapper with title tag", "section_id", sectionID, "title", title, "final_content_length", len(finalContent))
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("Content already contains title tag", "section_id", sectionID, "title", title, "content_length", len(finalContent))
        }</span>

        // Log the actual content at configurable verbosity level
        <span class="cov0" title="0">logging.LogContent(logging.PageLogger, slog.LevelDebug, "CreatePage final content", "section_id", sectionID, "title", title, "final_content", finalContent)

        // Make authenticated request
        headers := map[string]string{"Content-Type": "application/xhtml+xml"}
        logging.PageLogger.Debug("Making authenticated request to create page", "section_id", sectionID, "url", url, "content_type", headers["Content-Type"])
        var result map[string]interface{}
        err := httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        // Handle HTTP response
                        if err := c.HandleHTTPResponse(resp, "CreatePage"); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("HTTP response handling failed for CreatePage", "section_id", sectionID, "title", title, "status", resp.StatusCode, "error", err)
                                return err
                        }</span>

                        <span class="cov0" title="0">if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to decode response for CreatePage", "section_id", sectionID, "title", title, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                "POST", url, strings.NewReader(finalContent), headers,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated request failed for CreatePage", "section_id", sectionID, "title", title, "error", err)
                return nil, err
        }</span>

        // Log successful creation with page ID if available
        <span class="cov0" title="0">pageID, hasID := result["id"].(string)
        if hasID </span><span class="cov0" title="0">{
                logging.PageLogger.Info("CreatePage completed successfully", "section_id", sectionID, "title", title, "page_id", pageID, "content_length", len(content))
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Info("CreatePage completed successfully but no page ID in response", "section_id", sectionID, "title", title, "content_length", len(content))
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// htmlEscape escapes special HTML characters in a string for safe insertion in &lt;title&gt;.
func htmlEscape(s string) string <span class="cov8" title="1">{
        replacer := strings.NewReplacer(
                "&amp;", "&amp;amp;",
                "&lt;", "&amp;lt;",
                "&gt;", "&amp;gt;",
                "\"", "&amp;quot;",
                "'", "&amp;#39;",
        )
        return replacer.Replace(s)
}</span>

// validateTableUpdates checks if any commands are attempting to update individual table elements
// and returns an error with guidance if table elements are targeted individually.
// isTableElement determines if a target references a table element that cannot be updated individually
func isTableElement(target string) bool <span class="cov8" title="1">{
        target = strings.ToLower(target)
        
        // Direct element targeting (e.g., td:, th:, tr:)
        if strings.HasPrefix(target, "td:") ||
                strings.HasPrefix(target, "th:") ||
                strings.HasPrefix(target, "tr:") ||
                strings.HasPrefix(target, "tbody:") ||
                strings.HasPrefix(target, "thead:") ||
                strings.HasPrefix(target, "tfoot:") </span><span class="cov8" title="1">{
                return true
        }</span>
        
        // Data-id based targeting (e.g., data-id:cell-123, data-id:tr-456)
        <span class="cov8" title="1">if strings.HasPrefix(target, "data-id:") </span><span class="cov8" title="1">{
                idValue := strings.TrimPrefix(target, "data-id:")
                
                // Common table element ID patterns used in OneNote
                tablePatterns := []string{
                        "cell-", "td-", "th-",          // Table cells
                        "row-", "tr-",                  // Table rows  
                        "tbody-", "thead-", "tfoot-",   // Table sections
                        "col-", "colgroup-",            // Table columns
                }
                
                for _, pattern := range tablePatterns </span><span class="cov8" title="1">{
                        if strings.Contains(idValue, pattern) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return false</span>
}

func validateTableUpdates(commands []UpdateCommand) error <span class="cov8" title="1">{
        var tableElementTargets []string

        for _, cmd := range commands </span><span class="cov8" title="1">{
                if isTableElement(cmd.Target) </span><span class="cov8" title="1">{
                        tableElementTargets = append(tableElementTargets, cmd.Target)
                }</span>
        }

        <span class="cov8" title="1">if len(tableElementTargets) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf(`TABLE UPDATE RESTRICTION: You are attempting to update individual table elements (%v). 

OneNote requires that tables be updated as complete units, not individual cells or rows. 

SOLUTION: Instead of updating individual table elements, you must:
1. Target the entire table element (table:data-id) 
2. Replace the complete table HTML with your updated content
3. Include all table structure (table, tr, td/th elements) in your replacement

Example of CORRECT approach:
- Target: "table:{table-data-id}" 
- Action: "replace"
- Content: "&lt;table&gt;...complete table HTML...&lt;/table&gt;"

Example of INCORRECT approach (what you're doing):
- Target: "td:{cell-data-id}" or "data-id:cell-123"
- Action: "replace" 
- Content: "&lt;td&gt;new content&lt;/td&gt;"

This restriction ensures table integrity and prevents layout corruption in OneNote`, tableElementTargets)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdatePageContent updates the HTML content of a page using Microsoft Graph OneNote API.
// commands: Array of update commands defining the changes to make.
// Returns an error if the update fails.
func (c *PageClient) UpdatePageContent(pageID string, commands []UpdateCommand) error <span class="cov0" title="0">{

        // Sanitize and validate the pageID to prevent injection attacks
        sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content", sanitizedPageID)

        if len(commands) == 0 </span><span class="cov0" title="0">{
                logging.PageLogger.Error("No update commands provided", "page_id", pageID)
                return fmt.Errorf("no update commands provided")
        }</span>

        // Log command details for debugging including actual content at verbose level
        <span class="cov0" title="0">for i, cmd := range commands </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Update command details", "page_id", pageID, "command_index", i, "target", cmd.Target, "action", cmd.Action, "position", cmd.Position, "content_length", len(cmd.Content))
                // Log the actual command content at configurable verbosity level
                logging.LogContent(logging.PageLogger, slog.LevelDebug, "Update command content", "page_id", pageID, "command_index", i, "target", cmd.Target, "action", cmd.Action, "content", cmd.Content)
        }</span>

        // Validate table updates to prevent individual table element modifications
        <span class="cov0" title="0">logging.PageLogger.Debug("Validating table update restrictions", "page_id", pageID)
        if errValidate := validateTableUpdates(commands); errValidate != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Table update validation failed", "page_id", pageID, "error", errValidate)
                return errValidate
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Table update validation passed", "page_id", pageID)

        // --- NEW LOGIC: Scan for &lt;img&gt; or &lt;object&gt; tags with Graph API URLs ---
        type resourcePart struct {
                ContentID   string
                Content     []byte
                ContentType string
                Filename    string
        }
        resourceParts := []resourcePart{}
        resourceCounter := 1

        rewriteHTML := func(htmlIn string) (string, error) </span><span class="cov0" title="0">{
                doc, errParse := html.Parse(strings.NewReader(htmlIn))
                if errParse != nil </span><span class="cov0" title="0">{
                        return htmlIn, nil // fallback: return original if parse fails
                }</span>
                <span class="cov0" title="0">var changed bool
                var traverse func(*html.Node)
                traverse = func(n *html.Node) </span><span class="cov0" title="0">{
                        if n.Type == html.ElementNode &amp;&amp; (n.Data == imgTag || n.Data == objectTag) </span><span class="cov0" title="0">{
                                var urlAttr string
                                if n.Data == imgTag </span><span class="cov0" title="0">{
                                        urlAttr = "src"
                                }</span> else<span class="cov0" title="0"> if n.Data == objectTag </span><span class="cov0" title="0">{
                                        urlAttr = "data"
                                }</span>
                                <span class="cov0" title="0">for _, attr := range n.Attr </span><span class="cov0" title="0">{
                                        if attr.Key == urlAttr &amp;&amp; strings.HasPrefix(attr.Val, "https://graph.microsoft.com/") </span><span class="cov0" title="0">{
                                                // Extract resource ID
                                                pageItemID := extractPageItemID(attr.Val)
                                                if pageItemID != "" </span><span class="cov0" title="0">{
                                                        // Download the resource
                                                        item, itemErr := c.GetPageItem(pageID, pageItemID)
                                                        if itemErr != nil </span><span class="cov0" title="0">{
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">contentID := fmt.Sprintf("part%d", resourceCounter)
                                                        resourceCounter++
                                                        resourceParts = append(resourceParts, resourcePart{
                                                                ContentID:   contentID,
                                                                Content:     item.Content,
                                                                ContentType: item.ContentType,
                                                                Filename:    item.Filename,
                                                        })
                                                        // Remove all attributes and only include the src/data attribute
                                                        n.Attr = []html.Attribute{{Key: urlAttr, Val: "name:" + contentID}}
                                                        changed = true
                                                        break</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                                traverse(c)
                        }</span>
                }
                <span class="cov0" title="0">traverse(doc)
                if !changed </span><span class="cov0" title="0">{
                        return htmlIn, nil
                }</span>
                <span class="cov0" title="0">var buf bytes.Buffer
                html.Render(&amp;buf, doc)
                return buf.String(), nil</span>
        }

        // Rewrite HTML in all commands and collect resource parts
        <span class="cov0" title="0">logging.PageLogger.Debug("Rewriting HTML in commands to handle embedded resources", "page_id", pageID)
        for i := range commands </span><span class="cov0" title="0">{
                if commands[i].Content != "" </span><span class="cov0" title="0">{
                        originalLength := len(commands[i].Content)
                        rewritten, _ := rewriteHTML(commands[i].Content)
                        commands[i].Content = rewritten
                        logging.PageLogger.Debug("Rewrote command HTML content", "page_id", pageID, "command_index", i, "original_length", originalLength, "rewritten_length", len(rewritten))
                }</span>
        }
        <span class="cov0" title="0">logging.PageLogger.Debug("HTML rewriting completed", "page_id", pageID, "resource_parts_found", len(resourceParts))

        commandsJSON, err := json.Marshal(commands)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to marshal commands to JSON", "page_id", pageID, "error", err)
                return fmt.Errorf("failed to marshal commands: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Commands marshaled to JSON", "page_id", pageID, "json_length", len(commandsJSON))
        // Log the actual JSON commands at configurable verbosity level
        logging.LogContent(logging.PageLogger, slog.LevelDebug, "Commands JSON content", "page_id", pageID, "commands_json", string(commandsJSON))

        // Create multipart form data
        logging.PageLogger.Debug("Creating multipart form data", "page_id", pageID, "resource_parts", len(resourceParts))
        var buf bytes.Buffer
        writer := multipart.NewWriter(&amp;buf)

        // Add the commands part
        commandsPart, err := writer.CreateFormFile("commands", "commands.json")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to create commands part", "page_id", pageID, "error", err)
                return fmt.Errorf("failed to create commands part: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = commandsPart.Write(commandsJSON)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to write commands to form file", "page_id", pageID, "error", err)
                return fmt.Errorf("failed to write commands to form file: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Commands part added to multipart form", "page_id", pageID)

        // Add resource parts
        for i, part := range resourceParts </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Adding resource part to multipart form", "page_id", pageID, "part_index", i, "content_id", part.ContentID, "filename", part.Filename, "content_type", part.ContentType, "size", len(part.Content))
                partHeader := make(textproto.MIMEHeader)
                partHeader.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"; filename=\"%s\"", part.ContentID, part.Filename))
                partHeader.Set("Content-Type", part.ContentType)
                resourceWriter, errPart := writer.CreatePart(partHeader)
                if errPart != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Failed to create resource part, skipping", "page_id", pageID, "content_id", part.ContentID, "error", errPart)
                        continue</span>
                }
                <span class="cov0" title="0">_, err = resourceWriter.Write(part.Content)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Failed to write resource content, skipping", "page_id", pageID, "content_id", part.ContentID, "error", err)
                        continue</span>
                }
        }

        // Close the writer
        <span class="cov0" title="0">writer.Close()

        // Get the final multipart content type
        contentType := writer.FormDataContentType()

        // Make authenticated request with multipart content type
        headers := map[string]string{"Content-Type": contentType}
        logging.PageLogger.Debug("Making authenticated PATCH request", "page_id", pageID, "url", url, "content_type", contentType, "body_size", buf.Len())

        err = httputils.SafeRequest(
                c.MakeAuthenticatedRequest,
                c.HandleHTTPResponse,
                "PATCH", url, &amp;buf, headers,
                "UpdatePageContent",
        )
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated PATCH request failed for UpdatePageContent", "page_id", pageID, "error", err)
                return err
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Info("UpdatePageContent completed successfully", "page_id", pageID, "command_count", len(commands), "resource_parts", len(resourceParts))
        return nil</span>
}

// UpdatePageContentSimple provides backward compatibility for simple content replacement.
// This function replaces the entire body content of a page.
// For more complex updates, use UpdatePageContent with UpdateCommand array.
func (c *PageClient) UpdatePageContentSimple(pageID, content string) error <span class="cov0" title="0">{
        commands := []UpdateCommand{
                {
                        Target:  "body",
                        Action:  "replace",
                        Content: content,
                },
        }

        return c.UpdatePageContent(pageID, commands)
}</span>

// DeletePage deletes a page by pageID using the Microsoft Graph SDK.
// Returns an error if the deletion fails.
func (c *PageClient) DeletePage(pageID string) error <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting DeletePage operation", "page_id", pageID)
        ctx := context.Background()
        err := c.GraphClient.Me().Onenote().Pages().ByOnenotePageId(pageID).Delete(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("DeletePage failed", "page_id", pageID, "error", err)
                return fmt.Errorf("[pages] DeletePage failed: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Info("DeletePage completed successfully", "page_id", pageID)
        return nil</span>
}

// CopyPage copies a page from one section to another using direct HTTP API calls.
// pageID: ID of the page to copy.
// targetSectionID: ID of the target section to copy the page to.
// Returns the copied page metadata and an error, if any.
func (c *PageClient) CopyPage(pageID string, targetSectionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting CopyPage operation", "page_id", pageID, "target_section_id", targetSectionID)

        // Validate and sanitize inputs
        sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page ID sanitization failed", "page_id", pageID, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">sanitizedTargetSectionID, err := c.SanitizeOneNoteID(targetSectionID, "targetSectionID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Target section ID sanitization failed", "target_section_id", targetSectionID, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Input sanitization completed", "sanitized_page_id", sanitizedPageID, "sanitized_target_section_id", sanitizedTargetSectionID)

        // Construct the URL for copying a page to a section
        url := fmt.Sprintf("https://graph.microsoft.com/beta/me/onenote/pages/%s/copyToSection", sanitizedPageID)
        logging.PageLogger.Debug("Copy URL constructed", "page_id", pageID, "url", url)

        // Create the request body for copying to section
        requestBody := map[string]interface{}{
                "id": sanitizedTargetSectionID,
        }

        // Marshal the request body to JSON
        jsonBody, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to marshal request body", "page_id", pageID, "error", err)
                return nil, fmt.Errorf("failed to marshal request body: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Request body marshaled", "page_id", pageID, "body_length", len(jsonBody))

        // Make authenticated request with custom handler
        headers := map[string]string{"Content-Type": "application/json"}
        logging.PageLogger.Debug("Making authenticated request to copy page", "page_id", pageID, "target_section_id", targetSectionID)
        
        var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        // Check for 202 status code (Accepted - asynchronous operation)
                        logging.PageLogger.Debug("Copy request response received", "page_id", pageID, "status_code", resp.StatusCode)
                        if resp.StatusCode != 202 </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Copy operation failed with unexpected status", "page_id", pageID, "expected_status", 202, "actual_status", resp.StatusCode)
                                return fmt.Errorf("copy operation failed: expected status 202, got %d", resp.StatusCode)
                        }</span>

                        // Read response body
                        <span class="cov0" title="0">content, err := c.ReadResponseBody(resp, "CopyPage")
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to read response body for CopyPage", "page_id", pageID, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logging.PageLogger.Debug("Copy response body read", "page_id", pageID, "content_length", len(content))

                        // Parse the response JSON
                        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to parse copy response", "page_id", pageID, "error", err)
                                return fmt.Errorf("failed to parse copy response: %v", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                "POST", url, bytes.NewBuffer(jsonBody), headers,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated request failed for CopyPage", "page_id", pageID, "target_section_id", targetSectionID, "error", err)
                return nil, err
        }</span>

        // Extract status and id from the response
        <span class="cov0" title="0">status, statusExists := result["status"].(string)
        if !statusExists </span><span class="cov0" title="0">{
                logging.PageLogger.Error("No status field found in copy response", "page_id", pageID)
                return nil, fmt.Errorf("no status field found in copy response")
        }</span>

        <span class="cov0" title="0">operationID, idExists := result["id"].(string)
        if !idExists </span><span class="cov0" title="0">{
                logging.PageLogger.Error("No operation ID found in copy response", "page_id", pageID)
                return nil, fmt.Errorf("no id field found in copy response")
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Debug("Async copy operation initiated", "page_id", pageID, "operation_id", operationID, "initial_status", status)

        // Poll for operation completion
        maxAttempts := 30
        logging.PageLogger.Debug("Starting operation polling", "page_id", pageID, "operation_id", operationID, "max_attempts", maxAttempts)
        for attempt := 1; attempt &lt;= maxAttempts; attempt++ </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Polling operation status", "page_id", pageID, "operation_id", operationID, "attempt", attempt)

                // Get operation status
                operationResult, err := c.GetOnenoteOperation(operationID)
                if err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Failed to get operation status", "page_id", pageID, "operation_id", operationID, "attempt", attempt, "error", err)
                        return nil, fmt.Errorf("failed to get operation status: %v", err)
                }</span>

                // Check operation status
                <span class="cov0" title="0">operationStatus, statusExists := operationResult["status"].(string)
                if !statusExists </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("No status field in operation result", "page_id", pageID, "operation_id", operationID, "attempt", attempt)
                        return nil, fmt.Errorf("no status field in operation result")
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Operation status retrieved", "page_id", pageID, "operation_id", operationID, "attempt", attempt, "status", operationStatus)

                // Check if operation is completed
                if operationStatus == "Completed" </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Copy operation completed", "page_id", pageID, "operation_id", operationID, "attempt", attempt)

                        // Extract page ID from resourceLocation
                        newPageID, err := c.extractPageIDFromResourceLocation(operationResult)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to extract new page ID from operation result", "original_page_id", pageID, "operation_id", operationID, "error", err)
                                return nil, fmt.Errorf("failed to extract page ID from operation result: %v", err)
                        }</span>

                        <span class="cov0" title="0">logging.PageLogger.Info("CopyPage completed successfully", "original_page_id", pageID, "new_page_id", newPageID, "target_section_id", targetSectionID, "operation_id", operationID, "attempts", attempt)
                        return map[string]interface{}{
                                "id":          newPageID,
                                "operationId": operationID,
                                "status":      "Completed",
                        }, nil</span>
                }

                // Check if operation failed
                <span class="cov0" title="0">if operationStatus == "Failed" </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Copy operation failed", "page_id", pageID, "operation_id", operationID, "attempt", attempt)
                        return nil, fmt.Errorf("copy operation failed")
                }</span>

                // Handle special "Running" status (returned when 503 error is encountered)
                <span class="cov0" title="0">if operationStatus == "Running" </span><span class="cov0" title="0">{
                        // Check if we got additional information about the 503 response
                        if note, hasNote := operationResult["note"].(string); hasNote </span><span class="cov0" title="0">{
                                logging.PageLogger.Info("Copy operation still in progress (503 response)",
                                        "page_id", pageID,
                                        "operation_id", operationID,
                                        "attempt", attempt,
                                        "note", note)
                        }</span> else<span class="cov0" title="0"> {
                                logging.PageLogger.Debug("Copy operation still running", "page_id", pageID, "operation_id", operationID, "attempt", attempt)
                        }</span>
                }

                // If not completed, wait before next attempt
                <span class="cov0" title="0">if attempt &lt; maxAttempts </span><span class="cov0" title="0">{
                        // Random delay between 1-3 seconds
                        delay := time.Duration(1+rand.Intn(2+attempt)) * time.Second

                        // Log differently based on whether we got a 503 or just normal progress
                        if operationStatus == "Running" </span><span class="cov0" title="0">{
                                logging.PageLogger.Info("Continuing to wait for copy operation completion after 503 response",
                                        "page_id", pageID,
                                        "operation_id", operationID,
                                        "attempt", attempt,
                                        "delay", delay,
                                        "status", operationStatus)
                        }</span> else<span class="cov0" title="0"> {
                                logging.PageLogger.Debug("Waiting before next polling attempt",
                                        "page_id", pageID,
                                        "operation_id", operationID,
                                        "attempt", attempt,
                                        "delay", delay,
                                        "status", operationStatus)
                        }</span>

                        <span class="cov0" title="0">time.Sleep(delay)</span>
                }
        }

        <span class="cov0" title="0">logging.PageLogger.Error("Copy operation timed out", "page_id", pageID, "operation_id", operationID, "max_attempts", maxAttempts)
        return nil, fmt.Errorf("copy operation did not complete within %d attempts", maxAttempts)</span>
}

// GetOnenoteOperation retrieves the status of an asynchronous OneNote operation.
// operationID: ID of the operation to check.
// Returns the operation status and metadata, and an error, if any.
func (c *PageClient) GetOnenoteOperation(operationID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Debug("Starting GetOnenoteOperation", "operation_id", operationID)

        // Validate and sanitize the operation ID
        sanitizedOperationID, err := c.SanitizeOneNoteID(operationID, "operationID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Operation ID sanitization failed", "operation_id", operationID, "error", err)
                return nil, err
        }</span>

        // Construct the URL for getting operation status
        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/operations/%s", sanitizedOperationID)
        logging.PageLogger.Debug("Operation status URL constructed", "operation_id", operationID, "url", url)

        // Make authenticated request with custom handler
        var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        // Handle HTTP response - special handling for 503 Service Unavailable
                        if resp.StatusCode == 503 </span><span class="cov0" title="0">{
                                // 503 indicates the operation is still in progress, not an error condition
                                logging.PageLogger.Warn("Operation status check returned 503 Service Unavailable - operation still in progress",
                                        "operation_id", operationID,
                                        "status_code", resp.StatusCode,
                                        "note", "This is expected during long-running copy operations")

                                // Return a result indicating the operation is still running
                                result = map[string]interface{}{
                                        "status": "Running",
                                        "id":     operationID,
                                        "note":   "Operation is still in progress (503 response received)",
                                }
                                return nil
                        }</span>

                        // Handle other HTTP responses normally
                        <span class="cov0" title="0">if errHandle := c.HandleHTTPResponse(resp, "GetOnenoteOperation"); errHandle != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("HTTP response handling failed for GetOnenoteOperation", "operation_id", operationID, "status", resp.StatusCode, "error", errHandle)
                                return errHandle
                        }</span>

                        // Read response body
                        <span class="cov0" title="0">content, err := c.ReadResponseBody(resp, "GetOnenoteOperation")
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to read response body for GetOnenoteOperation", "operation_id", operationID, "error", err)
                                return err
                        }</span>

                        // Parse the response JSON
                        <span class="cov0" title="0">if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("Failed to parse operation status response", "operation_id", operationID, "error", err)
                                return fmt.Errorf("failed to parse operation status response: %v", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
                "GET", url, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Authenticated request failed for GetOnenoteOperation", "operation_id", operationID, "error", err)
                return nil, err
        }</span>

        // Log the operation status if available
        <span class="cov0" title="0">if status, hasStatus := result["status"].(string); hasStatus </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("GetOnenoteOperation completed", "operation_id", operationID, "status", status)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("GetOnenoteOperation completed but no status in response", "operation_id", operationID)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// extractPageIDFromResourceLocation extracts the page ID from a resourceLocation URL in JSON response.
// jsonData: JSON data that contains a resourceLocation field with a page URL.
// Returns the page ID extracted from the URL and an error, if any.
func (c *PageClient) extractPageIDFromResourceLocation(jsonData map[string]interface{}) (string, error) <span class="cov8" title="1">{
        logging.PageLogger.Debug("Starting extractPageIDFromResourceLocation")

        // Check if resourceLocation exists in the JSON
        resourceLocation, exists := jsonData["resourceLocation"]
        if !exists </span><span class="cov8" title="1">{
                logging.PageLogger.Debug("No resourceLocation field found in JSON data")
                return "", fmt.Errorf("resourceLocation field not found in JSON data")
        }</span>

        // Convert to string
        <span class="cov8" title="1">url, ok := resourceLocation.(string)
        if !ok </span><span class="cov8" title="1">{
                logging.PageLogger.Debug("ResourceLocation is not a string", "type", fmt.Sprintf("%T", resourceLocation))
                return "", fmt.Errorf("resourceLocation is not a string")
        }</span>
        <span class="cov8" title="1">logging.PageLogger.Debug("Found resourceLocation URL", "url", url)

        // Extract page ID from the URL using regex
        // Pattern matches URLs like: https://graph.microsoft.com/beta/users/.../onenote/pages/{pageId}
        pageIDRegex := regexp.MustCompile(`/onenote/pages/([A-Za-z0-9\-!]+)`)
        matches := pageIDRegex.FindStringSubmatch(url)

        if len(matches) &lt; 2 </span><span class="cov8" title="1">{
                logging.PageLogger.Debug("Could not extract page ID from URL", "url", url)
                return "", fmt.Errorf("could not extract page ID from URL: %s", url)
        }</span>

        <span class="cov8" title="1">pageID := matches[1]
        logging.PageLogger.Debug("Extracted page ID from URL", "url", url, "page_id", pageID)

        // Validate the extracted page ID
        if _, err := c.SanitizeOneNoteID(pageID, "extracted page ID"); err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Extracted page ID failed validation", "page_id", pageID, "error", err)
                return "", fmt.Errorf("extracted page ID failed validation: %v", err)
        }</span>

        <span class="cov8" title="1">logging.PageLogger.Debug("Successfully extracted and validated page ID", "page_id", pageID)
        return pageID, nil</span>
}

// MovePage moves a page from one section to another by copying it to the target section and deleting the original.
// pageID: ID of the page to move.
// targetSectionID: ID of the target section to move the page to.
// Returns the moved page metadata and an error, if any.
func (c *PageClient) MovePage(pageID string, targetSectionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting MovePage operation", "page_id", pageID, "target_section_id", targetSectionID)

        // First, copy the page to the target section
        logging.PageLogger.Debug("Copying page for move operation", "page_id", pageID, "target_section_id", targetSectionID)
        copiedPage, err := c.CopyPage(pageID, targetSectionID)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Copy operation failed during move", "page_id", pageID, "target_section_id", targetSectionID, "error", err)
                return nil, fmt.Errorf("failed to copy page for move operation: %v", err)
        }</span>
        <span class="cov0" title="0">logging.PageLogger.Info("Page copied successfully, proceeding with deletion", "original_page_id", pageID, "new_page_id", copiedPage["id"], "target_section_id", targetSectionID)

        // Then, delete the original page
        logging.PageLogger.Debug("Deleting original page after successful copy", "page_id", pageID)
        err = c.DeletePage(pageID)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Warn("Failed to delete original page after copy, but move operation succeeded", "original_page_id", pageID, "new_page_id", copiedPage["id"], "delete_error", err)
                // Note: We don't return an error here because the copy was successful
                // The user now has the page in the target section, even though the original wasn't deleted
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("Original page deleted successfully", "page_id", pageID)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Info("MovePage completed successfully", "original_page_id", pageID, "new_page_id", copiedPage["id"], "target_section_id", targetSectionID)
        return copiedPage, nil</span>
}

// GetPageItem retrieves complete data for a OneNote page item (image, file, etc.) by its ID.
// This enhanced version matches the original sophisticated implementation with:
// - HTML metadata extraction using ListPageItems (avoids duplicate parsing)
// - Content type detection from HTML data-src-type attribute (primary) and HTTP headers (fallback)
// - Automatic image scaling for large images (can be disabled with fullSize parameter)
// - Rich metadata extraction from HTML attributes
// pageID: ID of the page containing the item.
// pageItemID: Resource ID of the page item to retrieve.
// fullSize: Optional parameter to skip image scaling (defaults to false = scale images)
// Returns PageItemData with metadata and binary content, and an error if retrieval fails.
func (c *PageClient) GetPageItem(pageID, pageItemID string, fullSize ...bool) (*PageItemData, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting GetPageItem operation", "page_id", pageID, "page_item_id", pageItemID, "full_size", len(fullSize) &gt; 0 &amp;&amp; fullSize[0])

        // Check if token is expired and refresh if needed
        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before GetPageItem", "page_id", pageID, "page_item_id", pageItemID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during GetPageItem", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for GetPageItem", "page_id", pageID, "page_item_id", pageItemID)</span>
        }

        // Validate and sanitize inputs
        <span class="cov0" title="0">sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page ID sanitization failed", "page_id", pageID, "error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">sanitizedPageItemID, err := c.SanitizeOneNoteID(pageItemID, "pageItemID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page item ID sanitization failed", "page_item_id", pageItemID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Getting page item using sophisticated approach", "page_id", sanitizedPageID, "page_item_id", sanitizedPageItemID)

        // First, get the page items list to extract HTML metadata (original approach)
        logging.PageLogger.Debug("Getting page items list to extract HTML metadata")
        pageItemsList, err := c.ListPageItems(sanitizedPageID)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to get page items list", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                return nil, fmt.Errorf("failed to get page items list: %v", err)
        }</span>

        // Find the specific page item in the list to get its HTML metadata
        <span class="cov0" title="0">var htmlMetadata *PageItemInfo
        for _, itemMap := range pageItemsList </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Checking item in list", "item_map", itemMap)
                if itemID, exists := itemMap["pageItemId"].(string); exists &amp;&amp; itemID == sanitizedPageItemID </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Found matching page item", "page_item_id", itemID)

                        // Safely extract tagName
                        tagName := ""
                        if tagNameVal, exists := itemMap["tagName"]; exists </span><span class="cov0" title="0">{
                                if tagNameStr, ok := tagNameVal.(string); ok </span><span class="cov0" title="0">{
                                        tagName = tagNameStr
                                }</span>
                        }

                        // Initialize attributes map and add data-attachment if present
                        <span class="cov0" title="0">attributes := make(map[string]string)
                        if dataAttachmentVal, exists := itemMap["data-attachment"]; exists </span><span class="cov0" title="0">{
                                if dataAttachmentStr, ok := dataAttachmentVal.(string); ok </span><span class="cov0" title="0">{
                                        attributes["data-attachment"] = dataAttachmentStr
                                        logging.PageLogger.Debug("Found data-attachment attribute", "value", dataAttachmentStr)
                                }</span>
                        }

                        // Extract mimeType if available - check both data-src-type and type attributes
                        <span class="cov0" title="0">var mimeTypeFromHTML string
                        if mimeTypeVal, exists := itemMap["mimeType"]; exists </span><span class="cov0" title="0">{
                                if mimeTypeStr, ok := mimeTypeVal.(string); ok </span><span class="cov0" title="0">{
                                        mimeTypeFromHTML = mimeTypeStr
                                        // Store the MIME type in appropriate attribute based on tag type
                                        if tagName == "object" </span><span class="cov0" title="0">{
                                                attributes["type"] = mimeTypeStr
                                        }</span> else<span class="cov0" title="0"> {
                                                attributes["data-src-type"] = mimeTypeStr
                                        }</span>
                                        <span class="cov0" title="0">logging.PageLogger.Debug("Found mimeType from HTML", "value", mimeTypeStr, "tag_name", tagName)</span>
                                }
                        }

                        <span class="cov0" title="0">htmlMetadata = &amp;PageItemInfo{
                                TagName:     tagName,
                                PageItemID:  itemID,
                                Attributes:  attributes,
                                OriginalURL: "", // No longer available in simplified structure
                        }

                        logging.PageLogger.Debug("Found HTML metadata for page item", "tag_name", htmlMetadata.TagName, "attributes", htmlMetadata.Attributes, "page_item_id", htmlMetadata.PageItemID, "mime_type_from_html", mimeTypeFromHTML)
                        break</span>
                }
        }

        // Construct the resource URL for downloading content
        <span class="cov0" title="0">resourceURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/resources/%s/$value", sanitizedPageItemID)
        logging.PageLogger.Debug("Downloading item content", "page_id", pageID, "page_item_id", pageItemID, "url", resourceURL)

        // Make authenticated request to download the resource
        var content []byte
        var resp *http.Response
        err = httputils.SafeRequestWithCustomHandler(
                c.MakeAuthenticatedRequest,
                func(response *http.Response) error </span><span class="cov0" title="0">{
                        resp = response // Capture response for header access
                        
                        // Handle HTTP response
                        if errHandle := c.HandleHTTPResponse(response, "GetPageItem"); errHandle != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Error("HTTP response handling failed for GetPageItem", "page_id", pageID, "page_item_id", pageItemID, "status", response.StatusCode, "error", errHandle)
                                return errHandle
                        }</span>

                        // Read the binary content
                        <span class="cov0" title="0">responseContent, readErr := c.ReadResponseBody(response, "GetPageItem")
                        if readErr != nil </span><span class="cov0" title="0">{
                                return readErr
                        }</span>
                        <span class="cov0" title="0">content = responseContent
                        return nil</span>
                },
                "GET", resourceURL, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to download page item content", "page_id", pageID, "page_item_id", pageItemID, "error", err)
                return nil, fmt.Errorf("failed to download page item: %v", err)
        }</span>

        // Create the page item data with content
        <span class="cov0" title="0">pageItemData := &amp;PageItemData{
                Size:    int64(len(content)),
                Content: content,
        }

        // Add HTML metadata if found (original sophisticated approach)
        if htmlMetadata != nil </span><span class="cov0" title="0">{
                pageItemData.TagName = htmlMetadata.TagName
                pageItemData.Attributes = htmlMetadata.Attributes
                pageItemData.OriginalURL = htmlMetadata.OriginalURL

                logging.PageLogger.Debug("HTML metadata found", "tag_name", htmlMetadata.TagName, "attributes", htmlMetadata.Attributes, "data_src_type", htmlMetadata.Attributes["data-src-type"], "type", htmlMetadata.Attributes["type"])

                // Extract content type from HTML attributes - PRIMARY method
                var contentTypeFromHTML string
                // For object tags, check the type attribute first (HTML standard)
                if htmlMetadata.TagName == "object" </span><span class="cov0" title="0">{
                        if contentType, exists := htmlMetadata.Attributes["type"]; exists &amp;&amp; contentType != "" </span><span class="cov0" title="0">{
                                contentTypeFromHTML = contentType
                                logging.PageLogger.Debug("Content type from HTML type attribute (object tag)", "content_type", contentType)
                        }</span>
                }
                // If not found, check data-src-type (existing behavior)
                <span class="cov0" title="0">if contentTypeFromHTML == "" </span><span class="cov0" title="0">{
                        if contentType, exists := htmlMetadata.Attributes["data-src-type"]; exists &amp;&amp; contentType != "" </span><span class="cov0" title="0">{
                                contentTypeFromHTML = contentType
                                logging.PageLogger.Debug("Content type from HTML data-src-type attribute", "content_type", contentType)
                        }</span>
                }

                <span class="cov0" title="0">if contentTypeFromHTML != "" </span><span class="cov0" title="0">{
                        pageItemData.ContentType = contentTypeFromHTML
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to HTTP content type if HTML attribute not found
                        contentType := c.getContentTypeFromResponse(resp)
                        pageItemData.ContentType = contentType
                        logging.PageLogger.Debug("Content type from HTTP headers (fallback)", "content_type", contentType)
                }</span>

                // Generate filename based on content type (enhanced version)
                <span class="cov0" title="0">pageItemData.Filename = c.generateFilenameFromContentType(pageItemID, pageItemData.ContentType)

                // Scale image if it's large and an image type (unless fullSize is requested)
                shouldScale := len(fullSize) == 0 || !fullSize[0] // Scale by default, skip if fullSize=true
                if shouldScale &amp;&amp; strings.HasPrefix(pageItemData.ContentType, "image/") </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Attempting to scale image", "content_type", pageItemData.ContentType, "original_size", len(content))
                        scaledContent, scaled, err := utils.ScaleImageIfNeeded(pageItemData.Content, pageItemData.ContentType, 1024, 768)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.PageLogger.Debug("Failed to scale image", "error", err)
                        }</span> else<span class="cov0" title="0"> if scaled </span><span class="cov0" title="0">{
                                pageItemData.Content = scaledContent
                                pageItemData.Size = int64(len(scaledContent))
                                logging.PageLogger.Debug("Image was scaled down", "original_size", len(content), "scaled_size", len(scaledContent))
                        }</span> else<span class="cov0" title="0"> {
                                logging.PageLogger.Debug("Image size within limits, no scaling needed")
                        }</span>
                } else<span class="cov0" title="0"> if len(fullSize) &gt; 0 &amp;&amp; fullSize[0] </span><span class="cov0" title="0">{
                        logging.PageLogger.Debug("Skipping image scaling due to fullSize parameter")
                }</span>

                <span class="cov0" title="0">logging.PageLogger.Debug("Added HTML metadata", "tag_name", pageItemData.TagName, "original_url", pageItemData.OriginalURL, "content_type", pageItemData.ContentType, "filename", pageItemData.Filename, "size_bytes", pageItemData.Size, "attributes", pageItemData.Attributes)</span>
        } else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("No HTML metadata found for page item", "page_item_id", sanitizedPageItemID)
                // Fallback to HTTP content type and generated filename
                contentType := c.getContentTypeFromResponse(resp)
                pageItemData.ContentType = contentType
                pageItemData.Filename = c.generateFilenameFromContentType(pageItemID, contentType)
                logging.PageLogger.Debug("Using fallback content type and filename", "content_type", contentType, "filename", pageItemData.Filename)
        }</span>

        // Determine if scaling was applied for logging
        <span class="cov0" title="0">scalingApplied := (len(fullSize) == 0 || !fullSize[0]) &amp;&amp; strings.HasPrefix(pageItemData.ContentType, "image/")
        logging.PageLogger.Info("GetPageItem completed successfully", "page_id", pageID, "page_item_id", pageItemID, "filename", pageItemData.Filename, "content_type", pageItemData.ContentType, "size_bytes", pageItemData.Size, "tag_name", pageItemData.TagName, "scaling_applied", scalingApplied)
        return pageItemData, nil</span>
}

// ListPageItems lists all embedded items (images, files) in a OneNote page.
// This enhanced version uses the original sophisticated HTML parsing approach.
// pageID: ID of the page to list items for.
// Returns a slice of page item metadata and an error if listing fails.
func (c *PageClient) ListPageItems(pageID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.PageLogger.Info("Starting ListPageItems operation", "page_id", pageID)

        // Check if token is expired and refresh if needed
        if c.TokenManager != nil &amp;&amp; c.TokenManager.IsExpired() </span><span class="cov0" title="0">{
                logging.PageLogger.Debug("Token expired, refreshing before ListPageItems", "page_id", pageID)
                if err := c.RefreshTokenIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        logging.PageLogger.Error("Token refresh failed during ListPageItems", "page_id", pageID, "error", err)
                        return nil, fmt.Errorf("token expired and refresh failed: %v", err)
                }</span>
                <span class="cov0" title="0">logging.PageLogger.Debug("Token refreshed successfully for ListPageItems", "page_id", pageID)</span>
        }

        // Validate and sanitize page ID
        <span class="cov0" title="0">sanitizedPageID, err := c.SanitizeOneNoteID(pageID, "pageID")
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Page ID sanitization failed", "page_id", pageID, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Getting page content to extract page items", "page_id", sanitizedPageID)

        // Get the page content first (original approach - don't need IDs for listing)
        pageContent, err := c.GetPageContent(sanitizedPageID, false)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to get page content", "page_id", pageID, "error", err)
                return nil, fmt.Errorf("failed to get page content: %v", err)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Retrieved page content", "content_length", len(pageContent))

        // Parse the HTML content using the original sophisticated approach
        pageItems, err := c.parseHTMLForPageItemsOriginal(pageContent)
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to parse page items from HTML", "page_id", pageID, "error", err)
                return nil, fmt.Errorf("failed to parse page items: %v", err)
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Found page items in HTML content", "items_count", len(pageItems))

        // Convert PageItemInfo structs to simplified JSON array with requested fields
        var result []map[string]interface{}
        for _, item := range pageItems </span><span class="cov0" title="0">{
                itemMap := map[string]interface{}{
                        "pageItemId": item.PageItemID,
                        "tagName":    item.TagName,
                }

                // Determine type based on tagName and attributes
                var itemType string
                switch item.TagName </span>{
                case "img":<span class="cov0" title="0">
                        itemType = "image"</span>
                case "object":<span class="cov0" title="0">
                        if dataType, exists := item.Attributes["data-attachment"]; exists </span><span class="cov0" title="0">{
                                if dataType == "true" </span><span class="cov0" title="0">{
                                        itemType = "attachment"
                                }</span> else<span class="cov0" title="0"> {
                                        itemType = "object"
                                }</span>
                        } else<span class="cov0" title="0"> {
                                itemType = "object"
                        }</span>
                default:<span class="cov0" title="0">
                        itemType = item.TagName</span>
                }
                <span class="cov0" title="0">itemMap["type"] = itemType

                // Add data-attachment if it exists in attributes
                if dataAttachment, exists := item.Attributes["data-attachment"]; exists </span><span class="cov0" title="0">{
                        itemMap["data-attachment"] = dataAttachment
                }</span>

                // Add MIME type from attributes (check multiple sources)
                <span class="cov0" title="0">var mimeType string
                // First check for data-src-type (existing behavior)
                if dataSrcType, exists := item.Attributes["data-src-type"]; exists &amp;&amp; dataSrcType != "" </span><span class="cov0" title="0">{
                        mimeType = dataSrcType
                }</span>
                // For object tags, also check the type attribute (HTML standard)
                <span class="cov0" title="0">if mimeType == "" &amp;&amp; item.TagName == "object" </span><span class="cov0" title="0">{
                        if typeAttr, exists := item.Attributes["type"]; exists &amp;&amp; typeAttr != "" </span><span class="cov0" title="0">{
                                mimeType = typeAttr
                        }</span>
                }
                // Set mimeType if we found one
                <span class="cov0" title="0">if mimeType != "" </span><span class="cov0" title="0">{
                        itemMap["mimeType"] = mimeType
                }</span>

                <span class="cov0" title="0">result = append(result, itemMap)
                logging.PageLogger.Debug("Page item found", "tag_name", item.TagName, "page_item_id", item.PageItemID, "type", itemType, "data_attachment", item.Attributes["data-attachment"], "mime_type", mimeType)</span>
        }

        <span class="cov0" title="0">logging.PageLogger.Info("ListPageItems completed successfully", "page_id", pageID, "items_count", len(result))
        return result, nil</span>
}

// getExtensionFromContentType returns a file extension based on MIME type.
// contentType: The MIME type.
// Returns the appropriate file extension.
func getExtensionFromContentType(contentType string) string <span class="cov8" title="1">{
        switch </span>{
        case strings.HasPrefix(contentType, "image/jpeg"):<span class="cov8" title="1">
                return ".jpg"</span>
        case strings.HasPrefix(contentType, "image/png"):<span class="cov8" title="1">
                return ".png"</span>
        case strings.HasPrefix(contentType, "image/gif"):<span class="cov8" title="1">
                return ".gif"</span>
        case strings.HasPrefix(contentType, "image/bmp"):<span class="cov8" title="1">
                return ".bmp"</span>
        case strings.HasPrefix(contentType, "image/webp"):<span class="cov8" title="1">
                return ".webp"</span>
        case strings.HasPrefix(contentType, "image/svg"):<span class="cov8" title="1">
                return ".svg"</span>
        case strings.HasPrefix(contentType, "application/pdf"):<span class="cov8" title="1">
                return ".pdf"</span>
        case strings.HasPrefix(contentType, "text/plain"):<span class="cov8" title="1">
                return ".txt"</span>
        case strings.HasPrefix(contentType, "text/html"):<span class="cov8" title="1">
                return ".html"</span>
        case strings.HasPrefix(contentType, "application/json"):<span class="cov8" title="1">
                return ".json"</span>
        case strings.HasPrefix(contentType, "application/xml"):<span class="cov8" title="1">
                return ".xml"</span>
        case strings.HasPrefix(contentType, "application/zip"):<span class="cov0" title="0">
                return ".zip"</span>
        case strings.HasPrefix(contentType, "application/vnd.openxmlformats-officedocument"):<span class="cov0" title="0">
                if strings.Contains(contentType, "wordprocessingml") </span><span class="cov0" title="0">{
                        return ".docx"
                }</span> else<span class="cov0" title="0"> if strings.Contains(contentType, "spreadsheetml") </span><span class="cov0" title="0">{
                        return ".xlsx"
                }</span> else<span class="cov0" title="0"> if strings.Contains(contentType, "presentationml") </span><span class="cov0" title="0">{
                        return ".pptx"
                }</span>
                <span class="cov0" title="0">return ".office"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// getContentTypeFromResponse extracts content type from HTTP response headers with fallback.
func (c *PageClient) getContentTypeFromResponse(resp *http.Response) string <span class="cov0" title="0">{
        contentType := "application/octet-stream" // Default content type

        if resp.Header.Get("Content-Type") != "" </span><span class="cov0" title="0">{
                contentType = resp.Header.Get("Content-Type")
                logging.PageLogger.Debug("Content type from HTTP headers", "content_type", contentType)
        }</span> else<span class="cov0" title="0"> {
                logging.PageLogger.Debug("No Content-Type header found, using default", "content_type", contentType)
        }</span>

        <span class="cov0" title="0">return contentType</span>
}

// generateFilenameFromContentType creates a filename based on page item ID and content type.
// This version provides more comprehensive MIME type mapping than the original.
func (c *PageClient) generateFilenameFromContentType(pageItemID, contentType string) string <span class="cov0" title="0">{
        var filename string

        // Use the existing utility function for better extension mapping
        ext := getExtensionFromContentType(contentType)
        if ext != "" </span><span class="cov0" title="0">{
                filename = pageItemID + ext
        }</span> else<span class="cov0" title="0"> {
                filename = pageItemID + ".bin"
        }</span>

        <span class="cov0" title="0">logging.PageLogger.Debug("Generated filename from content type", "page_item_id", pageItemID, "content_type", contentType, "filename", filename)
        return filename</span>
}

// parseHTMLForPageItemsOriginal parses HTML content using the original sophisticated approach.
// This replaces the current regex-based parsing with proper HTML parser traversal.
func (c *PageClient) parseHTMLForPageItemsOriginal(htmlContent string) ([]*PageItemInfo, error) <span class="cov0" title="0">{
        var pageItems []*PageItemInfo

        logging.PageLogger.Debug("Starting HTML parsing with proper HTML parser", "content_length", len(htmlContent))

        // Parse HTML using the standard library HTML parser
        doc, err := html.Parse(strings.NewReader(htmlContent))
        if err != nil </span><span class="cov0" title="0">{
                logging.PageLogger.Error("Failed to parse HTML", "error", err)
                return pageItems, fmt.Errorf("failed to parse HTML: %v", err)
        }</span>

        // Recursively traverse the HTML tree to find img and object elements
        <span class="cov0" title="0">var traverse func(*html.Node)
        traverse = func(n *html.Node) </span><span class="cov0" title="0">{
                if n.Type == html.ElementNode </span><span class="cov0" title="0">{
                        if n.Data == "img" || n.Data == "object" </span><span class="cov0" title="0">{
                                // Extract all attributes
                                attributes := make(map[string]string)
                                for _, attr := range n.Attr </span><span class="cov0" title="0">{
                                        attributes[attr.Key] = attr.Val
                                        logging.PageLogger.Debug("Found HTML attribute", "element", n.Data, "key", attr.Key, "value", attr.Val)
                                }</span>

                                // Determine the URL attribute based on element type
                                <span class="cov0" title="0">var urlAttr string
                                var originalURL string

                                if n.Data == "img" </span><span class="cov0" title="0">{
                                        urlAttr = "src"
                                }</span> else<span class="cov0" title="0"> if n.Data == "object" </span><span class="cov0" title="0">{
                                        urlAttr = "data"
                                }</span>

                                <span class="cov0" title="0">if url, exists := attributes[urlAttr]; exists &amp;&amp; url != "" </span><span class="cov0" title="0">{
                                        originalURL = url
                                        pageItemID := extractPageItemID(url)
                                        if pageItemID != "" </span><span class="cov0" title="0">{
                                                logging.PageLogger.Debug("Extracted page item from HTML", "element", n.Data, "page_item_id", pageItemID, "url", url)

                                                pageItems = append(pageItems, &amp;PageItemInfo{
                                                        TagName:     n.Data,
                                                        PageItemID:  pageItemID,
                                                        Attributes:  attributes,
                                                        OriginalURL: originalURL,
                                                })
                                        }</span>
                                }
                        }
                }

                // Recursively process child nodes
                <span class="cov0" title="0">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                        traverse(c)
                }</span>
        }

        // Start traversal from the root
        <span class="cov0" title="0">traverse(doc)

        logging.PageLogger.Debug("HTML parsing completed", "items_found", len(pageItems))
        return pageItems, nil</span>
}

// extractPageItemID extracts the page item ID from OneNote resource URLs
func extractPageItemID(url string) string <span class="cov8" title="1">{
        // Pattern for OneNote resource URLs supports both:
        // - Legacy: https://www.onenote.com/api/v1.0/me/notes/resources/{id}/$value
        // - Microsoft Graph: https://graph.microsoft.com/v1.0/users(...)/onenote/resources/{id}/$value
        // OneNote IDs can contain alphanumeric chars, hyphens, and exclamation marks like: 0-896fbac8f72d01b02c5950345e65f588!1-4D24C77F19546939!39705
        re := regexp.MustCompile(`/resources/([A-Za-z0-9\-!]+)/\$value`)
        matches := re.FindStringSubmatch(url)
        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return matches[1]
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// groups.go - Section Group operations for the Microsoft Graph API client.
//
// This file contains all section group-related operations including listing,
// creating, and managing section groups within OneNote notebooks.
//
// Key Features:
// - List section groups in notebooks or other section groups
// - Create new section groups
// - List sections within section groups
// - Comprehensive container type detection
//
// Operations Supported:
// - ListSectionGroups: List section groups in a container (notebook/section group)
// - CreateSectionGroup: Create a new section group in a container
// - ListSectionsInSectionGroup: List sections within a section group
// - Helper functions for processing responses and validation
//
// Usage Example:
//   sectionClient := sections.NewSectionClient(graphClient)
//   sectionGroups, err := sectionClient.ListSectionGroups(notebookID)
//   if err != nil {
//       logging.SectionLogger.Error("Failed to list section groups", "error", err)
//   }
//
//   newSectionGroup, err := sectionClient.CreateSectionGroup(notebookID, "My New Section Group")
//   if err != nil {
//       logging.SectionLogger.Error("Failed to create section group", "error", err)
//   }

package sections

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

const (
        containerTypeSection      = "section"
        containerTypeSectionGroup = "sectionGroup"
        containerTypeNotebook     = "notebook"
)

// ListSectionGroups fetches all section groups in a notebook or section group using direct HTTP API calls.
// containerID: ID of the notebook or section group to list section groups from.
// Returns a slice of section group metadata maps and an error, if any.
// Note: Section groups can only be listed from notebooks or other section groups, not from sections.
func (c *SectionClient) ListSectionGroups(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing section groups for container using direct HTTP API", "container_id", containerID)

        // Sanitize and validate the containerID to prevent injection attacks
        sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine container type first for better error messages and logic flow
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type determined", "container_type", containerType)

        // Only allow listing section groups from notebooks or section groups
        // Sections cannot contain section groups according to OneNote hierarchy
        if containerType == containerTypeSection </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot list section groups from a section. Container ID %s is a section. Section groups can only be listed from notebooks or other section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != containerTypeNotebook &amp;&amp; containerType != containerTypeSectionGroup </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Section groups can only be listed from notebooks or section groups", containerID, containerType)
        }</span>

        // Construct the appropriate URL based on container type
        <span class="cov0" title="0">var url string
        if containerType == "notebook" </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using notebook endpoint", "url", url)
        }</span> else<span class="cov0" title="0"> { // sectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using section group endpoint", "url", url)
        }</span>

        // Make the API request
        <span class="cov0" title="0">var result []map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned status code", "status_code", resp.StatusCode)
                                return fmt.Errorf("failed to list section groups from %s: HTTP %d", containerType, resp.StatusCode)
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully retrieved section groups", "container_type", containerType)
                        processedResult, procErr := c.processSectionGroupsResponse(resp, "ListSectionGroups", containerID)
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = processedResult
                        return nil</span>
                },
                "GET", url, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err)
                return nil, fmt.Errorf("failed to list section groups from %s: %v", containerType, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ListSectionGroupsWithProgress fetches section groups with progress updates.
// Provides granular progress notifications during API calls to prevent client timeouts.
func (c *SectionClient) ListSectionGroupsWithProgress(containerID string, progressCallback func(progress int, message string)) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing section groups for container with progress", "container_id", containerID)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(0, "Initializing section group listing...")
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(20, "Determining container type...")
        }</span>

        // Determine container type first for better error messages and logic flow
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type determined", "container_type", containerType)

        // Only allow listing section groups from notebooks or section groups
        // Sections cannot contain section groups according to OneNote hierarchy
        if containerType == containerTypeSection </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot list section groups from a section. Container ID %s is a section. Section groups can only be listed from notebooks or other section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != containerTypeNotebook &amp;&amp; containerType != containerTypeSectionGroup </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Section groups can only be listed from notebooks or section groups", containerID, containerType)
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(40, fmt.Sprintf("Getting section groups from %s...", containerType))
        }</span>

        // Construct the appropriate URL based on container type
        <span class="cov0" title="0">var url string
        if containerType == "notebook" </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using notebook endpoint", "url", url)
        }</span> else<span class="cov0" title="0"> { // sectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sectionGroups", sanitizedContainerID)
                logging.SectionLogger.Debug("Using section group endpoint", "url", url)
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(60, "Making API request...")
        }</span>

        // Make the API request
        <span class="cov0" title="0">var result []map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned status code", "status_code", resp.StatusCode)
                                return fmt.Errorf("failed to list section groups from %s: HTTP %d", containerType, resp.StatusCode)
                        }</span>

                        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(80, "Processing response...")
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully retrieved section groups", "container_type", containerType)
                        processedResult, procErr := c.processSectionGroupsResponse(resp, "ListSectionGroups", containerID)
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = processedResult
                        
                        if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(100, fmt.Sprintf("Completed: %d section groups found", len(result)))
                        }</span>
                        
                        <span class="cov0" title="0">return nil</span>
                },
                "GET", url, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err)
                return nil, fmt.Errorf("failed to list section groups from %s: %v", containerType, err)
        }</span>
        
        <span class="cov0" title="0">return result, nil</span>
}

// processSectionGroupsResponse processes the HTTP response for section groups and returns filtered data
func (c *SectionClient) processSectionGroupsResponse(resp *http.Response, operation string, containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status_code", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse section groups response: %v", err)
        }</span>

        // Extract section groups from the response
        <span class="cov0" title="0">sectionGroups, ok := result["value"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("No value field found in response")
                return nil, fmt.Errorf("no value field found in section groups response")
        }</span>

        // Convert to map[string]interface{} format, preserving all raw data for hierarchical processing
        <span class="cov0" title="0">var resultSectionGroups []map[string]interface{}
        for i, sg := range sectionGroups </span><span class="cov0" title="0">{
                if sectionGroup, ok := sg.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Extract the section group ID and name for logging
                        sectionGroupID, hasID := sectionGroup["id"].(string)
                        sectionGroupName, hasName := sectionGroup["displayName"].(string)

                        if !hasID </span><span class="cov0" title="0">{
                                logging.SectionLogger.Warn("Section group missing ID", "index", i)
                                continue</span>
                        }

                        <span class="cov0" title="0">if !hasName </span><span class="cov0" title="0">{
                                logging.SectionLogger.Warn("Section group missing display name", "section_group_id", sectionGroupID)
                                sectionGroupName = "Unnamed Section Group"
                                // Set the displayName in the actual data
                                sectionGroup["displayName"] = sectionGroupName
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Processing section group", "id", sectionGroupID, "name", sectionGroupName)

                        // Preserve the full raw section group data for hierarchical processing
                        // This includes: id, displayName, createdDateTime, lastModifiedDateTime, parentNotebook, parentSectionGroup, etc.
                        resultSectionGroups = append(resultSectionGroups, sectionGroup)
                        logging.SectionLogger.Debug("Added section group to results", "name", sectionGroupName, "id", sectionGroupID)</span>
                } else<span class="cov0" title="0"> {
                        logging.SectionLogger.Warn("Section group is not a valid map", "index", i)
                }</span>
        }

        <span class="cov0" title="0">logging.SectionLogger.Info("Found total section groups", "count", len(resultSectionGroups))
        return resultSectionGroups, nil</span>
}

// ListSectionGroupsWithContext fetches section groups with progress notification support
func (c *SectionClient) ListSectionGroupsWithContext(ctx context.Context, containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing section groups with context", "container_id", containerID)

        // Send progress notification before section groups API call
        c.sendProgressNotification(ctx, "Fetching section groups...")

        // Call the original ListSectionGroups method  
        result, err := c.ListSectionGroups(containerID)
        
        if err == nil </span><span class="cov0" title="0">{
                // Send progress notification after successful completion
                c.sendProgressNotification(ctx, "Section groups retrieved successfully")
        }</span>
        
        <span class="cov0" title="0">return result, err</span>
}

// ListSectionsInSectionGroup fetches all sections in a section group by sectionGroupID using direct HTTP API calls.
// Returns a slice of section metadata maps and an error, if any.
func (c *SectionClient) ListSectionsInSectionGroup(sectionGroupID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing sections for section group using direct HTTP API", "section_group_id", sectionGroupID)

        // Sanitize and validate the sectionGroupID to prevent injection attacks
        sanitizedSectionGroupID, err := c.Client.SanitizeOneNoteID(sectionGroupID, "sectionGroupID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Construct the URL for listing sections in a section group
        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedSectionGroupID)
        logging.SectionLogger.Debug("Sections in section group URL", "url", url)

        // Make authenticated request
        content, err := httputils.SafeRequestWithBody(
                c.Client.MakeAuthenticatedRequest,
                c.Client.HandleHTTPResponse,
                c.Client.ReadResponseBody,
                "GET", url, nil, nil,
                "ListSectionsInSectionGroup",
        )
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Authenticated request failed", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Request completed successfully", "content_length", len(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse sections in section group response: %v", err)
        }</span>

        // Extract sections from the response
        <span class="cov0" title="0">sections, ok := result["value"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("No value field found in response")
                return nil, fmt.Errorf("no value field found in sections in section group response")
        }</span>

        // Convert to map[string]interface{} format with only essential information
        <span class="cov0" title="0">var resultSections []map[string]interface{}
        for _, s := range sections </span><span class="cov0" title="0">{
                if section, ok := s.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Extract only the essential information
                        filteredSection := map[string]interface{}{
                                "id":   section["id"],
                                "name": section["displayName"],
                        }

                        // Add parent information
                        if parentNotebook, exists := section["parentNotebook"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                filteredSection["parentNotebook"] = map[string]interface{}{
                                        "id":   parentNotebook["id"],
                                        "name": parentNotebook["displayName"],
                                }
                        }</span>

                        <span class="cov0" title="0">if parentSectionGroup, exists := section["parentSectionGroup"].(map[string]interface{}); exists &amp;&amp; parentSectionGroup != nil </span><span class="cov0" title="0">{
                                filteredSection["parentSectionGroup"] = map[string]interface{}{
                                        "id":   parentSectionGroup["id"],
                                        "name": parentSectionGroup["displayName"],
                                }
                        }</span>

                        <span class="cov0" title="0">resultSections = append(resultSections, filteredSection)</span>
                }
        }

        <span class="cov0" title="0">logging.SectionLogger.Info("Found total sections in section group", "count", len(resultSections))
        return resultSections, nil</span>
}

// CreateSectionGroup creates a new section group in a notebook or section group using direct HTTP API calls.
// containerID: ID of the notebook or section group to create the section group in.
// displayName: Display name for the new section group.
// Returns the created section group metadata and an error, if any.
// Note: Section groups can only be created inside notebooks or other section groups, not inside sections.
func (c *SectionClient) CreateSectionGroup(containerID, displayName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Creating section group in container using direct HTTP API", "display_name", displayName, "container_id", containerID)

        // Validate display name
        if err := utils.ValidateDisplayName(displayName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine container type first for better error messages
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        // Validate that we can create section groups in this container type
        <span class="cov0" title="0">if containerType == containerTypeSection </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create a section group inside a section. Container ID %s is a section. Section groups can only be created inside notebooks or other section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != containerTypeNotebook &amp;&amp; containerType != containerTypeSectionGroup </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Section groups can only be created inside notebooks or other section groups", containerID, containerType)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type confirmed", "container_type", containerType)

        // Create the request body
        requestBody := map[string]interface{}{
                "displayName": displayName,
        }

        // Marshal the request body to JSON
        jsonBody, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to marshal request body", "error", err)
                return nil, fmt.Errorf("failed to marshal request body: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Request body", "content", string(jsonBody))

        // Use conditional logic to call the correct endpoint based on container type
        var url string
        var endpointType string
        if containerType == containerTypeNotebook </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sectionGroups", sanitizedContainerID)
                endpointType = "notebook"
        }</span> else<span class="cov0" title="0"> { // containerTypeSectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sectionGroups", sanitizedContainerID)
                endpointType = "section group"
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Using correct endpoint based on container type", "url", url, "container_type", containerType, "endpoint_type", endpointType)

        // Make the API request to the correct endpoint
        var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned non-201 status", "status_code", resp.StatusCode, "endpoint_type", endpointType)
                                return fmt.Errorf("failed to create section group in %s: HTTP %d", endpointType, resp.StatusCode)
                        }</span>

                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully created section group", "endpoint_type", endpointType)
                        processedResult, procErr := c.processCreateSectionGroupResponse(resp, "CreateSectionGroup")
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = processedResult
                        return nil</span>
                },
                "POST", url, bytes.NewBuffer(jsonBody), map[string]string{"Content-Type": "application/json"},
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err, "endpoint_type", endpointType)
                return nil, fmt.Errorf("failed to create section group in %s: %v", endpointType, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// processCreateSectionGroupResponse processes the HTTP response for creating section groups and returns the result
func (c *SectionClient) processCreateSectionGroupResponse(resp *http.Response, operation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status_code", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse create section group response: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Info("Successfully created section group", "id", result["id"])
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2025 Gabriel Lawrence
//
// Licensed under the MIT License. See LICENSE file in the project root for full license information.

// sections.go - Section operations for the Microsoft Graph API client.
//
// This file contains all section-related operations including listing,
// creating, and managing sections within OneNote notebooks and section groups.
//
// Key Features:
// - List sections in notebooks, section groups, or sections
// - Create new sections
// - Comprehensive container type detection
//
// Operations Supported:
// - ListSections: List sections in a container (notebook/section group)
// - CreateSection: Create a new section in a container
// - Helper functions for processing responses and validation
//
// Usage Example:
//   sectionClient := sections.NewSectionClient(graphClient)
//   sections, err := sectionClient.ListSections(notebookID)
//   if err != nil {
//       logging.SectionLogger.Error("Failed to list sections", "error", err)
//   }
//
//   newSection, err := sectionClient.CreateSection(notebookID, "My New Section")
//   if err != nil {
//       logging.SectionLogger.Error("Failed to create section", "error", err)
//   }

package sections

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/gebl/onenote-mcp-server/internal/graph"
        httputils "github.com/gebl/onenote-mcp-server/internal/http"
        "github.com/gebl/onenote-mcp-server/internal/logging"
        "github.com/gebl/onenote-mcp-server/internal/utils"
)

// Context keys are now imported from utils to avoid duplication
// (removed local constants since they're not used in this package anymore)

// SectionClient provides section-specific operations
type SectionClient struct {
        *graph.Client
}

// NewSectionClient creates a new SectionClient
func NewSectionClient(client *graph.Client) *SectionClient <span class="cov8" title="1">{
        return &amp;SectionClient{Client: client}
}</span>

// ListSections fetches immediate sections and section groups in a notebook or section group by ID using direct HTTP API calls.
// containerID: ID of the notebook or section group to list sections from.
// Returns a slice containing both sections and section groups metadata maps, and an error if any.
func (c *SectionClient) ListSections(containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing immediate sections and section groups for container using direct HTTP API", "container_id", containerID)

        // Sanitize and validate the containerID to prevent injection attacks
        sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine if this is a notebook or section group by checking the response from both endpoints
        // Try notebook endpoint first
        <span class="cov0" title="0">notebookURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying notebook URL", "url", notebookURL)

        notebookResp, err := c.Client.MakeAuthenticatedRequest("GET", notebookURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Notebook endpoint failed, trying section group endpoint", "error", err)
        }</span> else<span class="cov0" title="0"> {
                defer notebookResp.Body.Close()
                if notebookResp.StatusCode == 200 </span><span class="cov0" title="0">{
                        logging.SectionLogger.Debug("Successfully found sections in notebook")
                        // Get immediate sections from notebook
                        directSections, errSections := c.processSectionsResponse(notebookResp, "ListSections")
                        if errSections != nil </span><span class="cov0" title="0">{
                                return nil, errSections
                        }</span>

                        // Get immediate section groups from the notebook
                        <span class="cov0" title="0">var allItems []map[string]interface{}
                        allItems = append(allItems, directSections...)

                        sectionGroups, groupsErr := c.ListSectionGroups(containerID)
                        if groupsErr != nil </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("Failed to get section groups from notebook", "container_id", containerID, "error", groupsErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Add section groups to the result (immediate children only)
                                allItems = append(allItems, sectionGroups...)
                        }</span>

                        <span class="cov0" title="0">return allItems, nil</span>
                }
        }

        // Try section group endpoint
        <span class="cov0" title="0">sectionGroupURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying section group URL", "url", sectionGroupURL)

        sectionGroupResp, err := c.Client.MakeAuthenticatedRequest("GET", sectionGroupURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Section group endpoint also failed", "error", err)
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID: %v", containerID, err)
        }</span>
        <span class="cov0" title="0">defer sectionGroupResp.Body.Close()

        if sectionGroupResp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID", containerID)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully found sections in section group")
        // Get immediate sections from section group
        directSections, err := c.processSectionsResponse(sectionGroupResp, "ListSections")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get immediate section groups from this section group
        <span class="cov0" title="0">var allItems []map[string]interface{}
        allItems = append(allItems, directSections...)

        nestedSectionGroups, err := c.ListSectionGroups(containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to get nested section groups from section group", "container_id", containerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Add section groups to the result (immediate children only)
                allItems = append(allItems, nestedSectionGroups...)
        }</span>

        <span class="cov0" title="0">return allItems, nil</span>
}

// ListSectionsWithContext fetches sections with progress notification support
func (c *SectionClient) ListSectionsWithContext(ctx context.Context, containerID string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing sections with context", "container_id", containerID)

        // Note: Progress notifications handled at the NotebookTools layer

        // Sanitize and validate the containerID to prevent injection attacks
        sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine if this is a notebook or section group by checking the response from both endpoints
        // Try notebook endpoint first
        <span class="cov0" title="0">notebookURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying notebook URL", "url", notebookURL)

        // Send progress notification before notebook API call
        c.sendProgressNotification(ctx, "Making notebook sections API call...")

        notebookResp, err := c.Client.MakeAuthenticatedRequest("GET", notebookURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Notebook endpoint failed, trying section group endpoint", "error", err)
        }</span> else<span class="cov0" title="0"> {
                defer notebookResp.Body.Close()
                if notebookResp.StatusCode == 200 </span><span class="cov0" title="0">{
                        logging.SectionLogger.Debug("Successfully found sections in notebook")
                        
                        // Send progress notification after successful API call
                        c.sendProgressNotification(ctx, "Processing notebook sections response...")
                        
                        // Get immediate sections from notebook
                        directSections, errSections := c.processSectionsResponse(notebookResp, "ListSections")
                        if errSections != nil </span><span class="cov0" title="0">{
                                return nil, errSections
                        }</span>

                        // Get immediate section groups from the notebook with context
                        <span class="cov0" title="0">var allItems []map[string]interface{}
                        allItems = append(allItems, directSections...)

                        // Send progress notification before section groups API call
                        c.sendProgressNotification(ctx, "Fetching section groups...")
                        
                        sectionGroups, groupsErr := c.ListSectionGroupsWithContext(ctx, containerID)
                        if groupsErr != nil </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("Failed to get section groups from notebook", "container_id", containerID, "error", groupsErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Add section groups to the result (immediate children only)
                                allItems = append(allItems, sectionGroups...)
                        }</span>

                        <span class="cov0" title="0">return allItems, nil</span>
                }
        }

        // Try section group endpoint
        <span class="cov0" title="0">sectionGroupURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying section group URL", "url", sectionGroupURL)

        sectionGroupResp, err := c.Client.MakeAuthenticatedRequest("GET", sectionGroupURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Section group endpoint also failed", "error", err)
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID: %v", containerID, err)
        }</span>
        <span class="cov0" title="0">defer sectionGroupResp.Body.Close()

        if sectionGroupResp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID", containerID)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully found sections in section group")
        // Get immediate sections from section group
        directSections, err := c.processSectionsResponse(sectionGroupResp, "ListSections")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get immediate section groups from this section group with context
        <span class="cov0" title="0">var allItems []map[string]interface{}
        allItems = append(allItems, directSections...)

        // Note: Progress notifications handled at the NotebookTools layer
        nestedSectionGroups, err := c.ListSectionGroupsWithContext(ctx, containerID)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to get nested section groups from section group", "container_id", containerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Add section groups to the result (immediate children only)
                allItems = append(allItems, nestedSectionGroups...)
        }</span>

        <span class="cov0" title="0">return allItems, nil</span>
}

// ListSectionsWithProgress fetches immediate sections and section groups with progress updates.
// Provides granular progress notifications during API calls to prevent client timeouts.
func (c *SectionClient) ListSectionsWithProgress(containerID string, progressCallback func(progress int, message string)) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing immediate sections and section groups for container with progress", "container_id", containerID)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(0, "Initializing section listing...")
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine if this is a notebook or section group by checking the response from both endpoints
        // Try notebook endpoint first
        <span class="cov0" title="0">notebookURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying notebook URL with progress", "url", notebookURL)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(10, "Checking if container is notebook...")
        }</span>

        <span class="cov0" title="0">notebookResp, err := c.Client.MakeAuthenticatedRequest("GET", notebookURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Notebook endpoint failed, trying section group endpoint", "error", err)
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(20, "Not a notebook, checking if section group...")
                }</span>
        } else<span class="cov0" title="0"> {
                defer notebookResp.Body.Close()
                if notebookResp.StatusCode == 200 </span><span class="cov0" title="0">{
                        logging.SectionLogger.Debug("Successfully found sections in notebook")
                        if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(30, "Container is notebook, getting sections...")
                        }</span>
                        
                        // Get immediate sections from notebook
                        <span class="cov0" title="0">directSections, errSections := c.processSectionsResponse(notebookResp, "ListSectionsWithProgress")
                        if errSections != nil </span><span class="cov0" title="0">{
                                return nil, errSections
                        }</span>

                        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(60, fmt.Sprintf("Found %d sections, getting section groups...", len(directSections)))
                        }</span>

                        // Get immediate section groups from the notebook
                        <span class="cov0" title="0">var allItems []map[string]interface{}
                        allItems = append(allItems, directSections...)

                        sectionGroups, groupsErr := c.ListSectionGroupsWithProgress(containerID, func(progress int, message string) </span><span class="cov0" title="0">{
                                // Map section group progress from 60-90%
                                adjustedProgress := 60 + (progress * 30 / 100)
                                if progressCallback != nil </span><span class="cov0" title="0">{
                                        progressCallback(adjustedProgress, fmt.Sprintf("Section groups: %s", message))
                                }</span>
                        })
                        <span class="cov0" title="0">if groupsErr != nil </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("Failed to get section groups from notebook", "container_id", containerID, "error", groupsErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Add section groups to the result (immediate children only)
                                allItems = append(allItems, sectionGroups...)
                        }</span>

                        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                                progressCallback(100, fmt.Sprintf("Completed: %d sections and section groups", len(allItems)))
                        }</span>

                        <span class="cov0" title="0">return allItems, nil</span>
                }
        }

        // Try section group endpoint
        <span class="cov0" title="0">sectionGroupURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
        logging.SectionLogger.Debug("Trying section group URL with progress", "url", sectionGroupURL)

        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(30, "Getting sections from section group...")
        }</span>

        <span class="cov0" title="0">sectionGroupResp, err := c.Client.MakeAuthenticatedRequest("GET", sectionGroupURL, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Section group endpoint also failed", "error", err)
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID: %v", containerID, err)
        }</span>
        <span class="cov0" title="0">defer sectionGroupResp.Body.Close()

        if sectionGroupResp.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is not a valid notebook or section group ID", containerID)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully found sections in section group")
        if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(50, "Processing section group sections...")
        }</span>
        
        // Get immediate sections from section group
        <span class="cov0" title="0">directSections, err := c.processSectionsResponse(sectionGroupResp, "ListSectionsWithProgress")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(70, fmt.Sprintf("Found %d sections, getting nested section groups...", len(directSections)))
        }</span>

        // Get immediate section groups from this section group
        <span class="cov0" title="0">var allItems []map[string]interface{}
        allItems = append(allItems, directSections...)

        nestedSectionGroups, err := c.ListSectionGroupsWithProgress(containerID, func(progress int, message string) </span><span class="cov0" title="0">{
                // Map nested section group progress from 70-95%
                adjustedProgress := 70 + (progress * 25 / 100)
                if progressCallback != nil </span><span class="cov0" title="0">{
                        progressCallback(adjustedProgress, fmt.Sprintf("Nested groups: %s", message))
                }</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to get nested section groups from section group", "container_id", containerID, "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Add section groups to the result (immediate children only)
                allItems = append(allItems, nestedSectionGroups...)
        }</span>

        <span class="cov0" title="0">if progressCallback != nil </span><span class="cov0" title="0">{
                progressCallback(100, fmt.Sprintf("Completed: %d sections and section groups", len(allItems)))
        }</span>

        <span class="cov0" title="0">return allItems, nil</span>
}


// sendProgressNotification sends a progress notification using the centralized utility
func (c *SectionClient) sendProgressNotification(ctx context.Context, message string) <span class="cov0" title="0">{
        utils.SendContextualMessage(ctx, message, logging.SectionLogger)
}</span>

// processSectionsResponse processes the HTTP response for sections and returns filtered data
func (c *SectionClient) processSectionsResponse(resp *http.Response, operation string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse sections response: %v", err)
        }</span>

        // Extract sections from the response
        <span class="cov0" title="0">sections, ok := result["value"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("No value field found in response")
                return nil, fmt.Errorf("no value field found in sections response")
        }</span>

        // Convert to map[string]interface{} format, preserving raw data for hierarchical processing
        <span class="cov0" title="0">var resultSections []map[string]interface{}
        for _, s := range sections </span><span class="cov0" title="0">{
                if section, ok := s.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Preserve the full raw section data for hierarchical processing
                        // This includes: id, displayName, createdDateTime, lastModifiedDateTime, parentNotebook, parentSectionGroup, etc.
                        resultSections = append(resultSections, section)
                }</span>
        }

        <span class="cov0" title="0">logging.SectionLogger.Info("Found sections", "count", len(resultSections))

        // Ensure we always return a slice, even if empty
        if resultSections == nil </span><span class="cov0" title="0">{
                resultSections = []map[string]interface{}{}
        }</span>
        <span class="cov0" title="0">return resultSections, nil</span>
}

// determineContainerType determines if a container ID is a notebook or section group by making test requests
func (c *SectionClient) determineContainerType(containerID string) (string, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Determining container type", "container_id", containerID)

        // Define endpoints to try in order
        endpoints := []httputils.HTTPRequestSpec{
                {
                        Method:  "GET",
                        URL:     fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s", containerID),
                        Headers: nil,
                        Body:    nil,
                },
                {
                        Method:  "GET", 
                        URL:     fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s", containerID),
                        Headers: nil,
                        Body:    nil,
                },
                {
                        Method:  "GET",
                        URL:     fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s", containerID),
                        Headers: nil,
                        Body:    nil,
                },
        }

        containerTypes := []string{"notebook", "sectionGroup", "section"}

        for i, endpoint := range endpoints </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Testing endpoint", "url", endpoint.URL, "expected_type", containerTypes[i])
                
                err := httputils.SafeRequest(
                        c.Client.MakeAuthenticatedRequest,
                        func(resp *http.Response, operation string) error </span><span class="cov0" title="0">{
                                if resp.StatusCode == 200 </span><span class="cov0" title="0">{
                                        logging.SectionLogger.Debug("Container type detected", "type", containerTypes[i])
                                        return nil // Success case
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("HTTP %d", resp.StatusCode)</span> // Non-200 status
                        },
                        endpoint.Method, endpoint.URL, endpoint.Body, endpoint.Headers,
                        fmt.Sprintf("determineContainerType_%s", containerTypes[i]),
                )
                
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        // Found the correct type
                        return containerTypes[i], nil
                }</span>
                
                <span class="cov0" title="0">logging.SectionLogger.Debug("Endpoint failed", "url", endpoint.URL, "error", err)</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("container ID %s is not a valid notebook, section group, or section", containerID)</span>
}


// CreateSection creates a new section in a notebook or section group using direct HTTP API calls.
// containerID: ID of the notebook or section group to create the section in.
// displayName: Display name for the new section.
// Returns the created section metadata and an error, if any.
// Note: Sections can only be created inside notebooks or section groups, not inside other sections.
func (c *SectionClient) CreateSection(containerID, displayName string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Creating section in container using direct HTTP API", "display_name", displayName, "container_id", containerID)

        // Validate display name
        if err := utils.ValidateDisplayName(displayName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sanitize and validate the containerID to prevent injection attacks
        <span class="cov0" title="0">sanitizedContainerID, err := c.Client.SanitizeOneNoteID(containerID, "containerID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine container type first for better error messages
        <span class="cov0" title="0">containerType, err := c.determineContainerType(sanitizedContainerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine container type: %v", err)
        }</span>

        // Validate that we can create sections in this container type
        <span class="cov0" title="0">if containerType == "section" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create a section inside another section. Container ID %s is a section. Sections can only be created inside notebooks or section groups", containerID)
        }</span>

        <span class="cov0" title="0">if containerType != "notebook" &amp;&amp; containerType != "sectionGroup" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("container ID %s is a %s. Sections can only be created inside notebooks or section groups", containerID, containerType)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Container type confirmed", "container_type", containerType)

        // Create the request body
        requestBody := map[string]interface{}{
                "displayName": displayName,
        }

        // Marshal the request body to JSON
        var buf bytes.Buffer
        encoder := json.NewEncoder(&amp;buf)
        encoder.SetEscapeHTML(false) // Prevent escaping
        err = encoder.Encode(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to marshal request body", "error", err)
                return nil, fmt.Errorf("failed to marshal request body: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Request body", "body", buf.String())

        // Construct the appropriate URL based on container type
        var url string
        if containerType == "notebook" </span><span class="cov0" title="0">{
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections", sanitizedContainerID)
                logging.SectionLogger.Debug("Using notebook endpoint", "url", url)
        }</span> else<span class="cov0" title="0"> { // sectionGroup
                url = fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sectionGroups/%s/sections", sanitizedContainerID)
                logging.SectionLogger.Debug("Using section group endpoint", "url", url)
        }</span>

        // Make the API request
        <span class="cov0" title="0">var result map[string]interface{}
        err = httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                                logging.SectionLogger.Debug("API returned status code", "status", resp.StatusCode)
                                return fmt.Errorf("failed to create section in %s: HTTP %d", containerType, resp.StatusCode)
                        }</span>
                        
                        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully created section", "container_type", containerType)
                        createResult, procErr := c.processCreateSectionResponse(resp, "CreateSection")
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">result = createResult
                        return nil</span>
                },
                "POST", url, &amp;buf, map[string]string{"Content-Type": "application/json"},
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("API request failed", "error", err)
                return nil, fmt.Errorf("failed to create section in %s: %v", containerType, err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// processCreateSectionResponse processes the HTTP response for creating sections and returns the result
func (c *SectionClient) processCreateSectionResponse(resp *http.Response, operation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Received response", "status", resp.StatusCode, "headers", resp.Header)

        // Handle HTTP response
        if err := c.Client.HandleHTTPResponse(resp, operation); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("HTTP response handling failed", "error", err)
                return nil, err
        }</span>

        // Read response body
        <span class="cov0" title="0">content, err := c.Client.ReadResponseBody(resp, operation)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to read response body", "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse create section response: %v", err)
        }</span>

        // Validate the response contains required fields
        <span class="cov0" title="0">sectionID, hasID := result["id"].(string)
        if !hasID </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Created section response missing ID field")
                return nil, fmt.Errorf("created section response missing ID field")
        }</span>

        <span class="cov0" title="0">sectionName, hasName := result["displayName"].(string)
        if !hasName </span><span class="cov0" title="0">{
                logging.SectionLogger.Warn("Created section missing display name", "section_id", sectionID)
                sectionName = "Unnamed Section"
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Successfully created section", "section_id", sectionID, "section_name", sectionName)
        logging.SectionLogger.Info("Successfully created section", "section_id", sectionID)

        return result, nil</span>
}

// ListAllSections fetches all sections across all notebooks using the global sections endpoint
// This is equivalent to https://graph.microsoft.com/v1.0/me/onenote/sections?$select=displayName,id
func (c *SectionClient) ListAllSections() ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing all sections across all notebooks using global endpoint")

        // Use the global sections endpoint with select query to get displayName and id
        sectionsURL := "https://graph.microsoft.com/v1.0/me/onenote/sections?$select=displayName,id"
        logging.SectionLogger.Debug("Fetching from global sections endpoint", "url", sectionsURL)

        var sections []map[string]interface{}
        err := httputils.SafeRequestWithCustomHandler(
                c.Client.MakeAuthenticatedRequest,
                func(resp *http.Response) error </span><span class="cov0" title="0">{
                        if err := c.Client.HandleHTTPResponse(resp, "ListAllSections"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">sectionsResult, procErr := c.processSectionsResponse(resp, "ListAllSections")
                        if procErr != nil </span><span class="cov0" title="0">{
                                return procErr
                        }</span>
                        <span class="cov0" title="0">sections = sectionsResult
                        return nil</span>
                },
                "GET", sectionsURL, nil, nil,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to fetch sections from global endpoint", "error", err)
                return nil, fmt.Errorf("failed to fetch all sections: %v", err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Info("Successfully listed all sections", "sections_count", len(sections))
        return sections, nil</span>
}

// ListAllSectionsWithContext fetches all sections with progress notification support
func (c *SectionClient) ListAllSectionsWithContext(ctx context.Context) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Listing all sections with context")

        // Send progress notification if available
        c.sendProgressNotification(ctx, "Fetching all sections from global endpoint...")

        return c.ListAllSections()
}</span>

// GetSectionByID fetches a specific section by its ID
func (c *SectionClient) GetSectionByID(sectionID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        logging.SectionLogger.Info("Getting section by ID", "section_id", sectionID)

        // Sanitize and validate the sectionID to prevent injection attacks
        sanitizedSectionID, err := c.Client.SanitizeOneNoteID(sectionID, "sectionID")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Use the specific section endpoint
        <span class="cov0" title="0">sectionURL := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s", sanitizedSectionID)
        logging.SectionLogger.Debug("Fetching section details", "url", sectionURL)

        content, err := httputils.SafeRequestWithBody(
                c.Client.MakeAuthenticatedRequest,
                c.Client.HandleHTTPResponse,
                c.Client.ReadResponseBody,
                "GET", sectionURL, nil, nil,
                "GetSectionByID",
        )
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to fetch section by ID", "section_id", sectionID, "error", err)
                return nil, fmt.Errorf("failed to fetch section %s: %v", sectionID, err)
        }</span>

        <span class="cov0" title="0">logging.SectionLogger.Debug("Response body", "content", string(content))

        // Parse the response JSON
        var result map[string]interface{}
        if err := json.Unmarshal(content, &amp;result); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Failed to unmarshal response", "error", err)
                return nil, fmt.Errorf("failed to parse section response: %v", err)
        }</span>

        // Validate the response contains required fields
        <span class="cov0" title="0">if _, hasID := result["id"].(string); !hasID </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Section response missing ID field")
                return nil, fmt.Errorf("section response missing ID field")
        }</span>

        <span class="cov0" title="0">if displayName, hasName := result["displayName"].(string); hasName </span><span class="cov0" title="0">{
                logging.SectionLogger.Debug("Successfully retrieved section", "section_id", sectionID, "section_name", displayName)
        }</span> else<span class="cov0" title="0"> {
                logging.SectionLogger.Debug("Successfully retrieved section (no display name)", "section_id", sectionID)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ResolveSectionNotebook resolves which notebook owns a section by its ID
func (c *SectionClient) ResolveSectionNotebook(ctx context.Context, sectionID string) (notebookID string, notebookName string, err error) <span class="cov0" title="0">{
        logging.SectionLogger.Debug("Resolving notebook ownership for section",
                "section_id", sectionID)

        // Sanitize and validate the sectionID to prevent injection attacks
        sanitizedSectionID, err := c.Client.SanitizeOneNoteID(sectionID, "sectionID")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid section ID: %v", err)
        }</span>

        // Use Graph API to get section metadata including parent notebook
        // We use $expand to get the parent notebook information in the same call
        <span class="cov0" title="0">url := fmt.Sprintf("https://graph.microsoft.com/v1.0/me/onenote/sections/%s?$expand=parentNotebook", sanitizedSectionID)
        
        response, err := c.Client.MakeAuthenticatedRequest("GET", url, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to resolve section notebook via Graph API",
                        "section_id", sectionID,
                        "error", err.Error())
                return "", "", fmt.Errorf("failed to resolve section notebook: %w", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        if response.StatusCode != 200 </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Graph API returned error when resolving section notebook",
                        "section_id", sectionID,
                        "status_code", response.StatusCode)
                return "", "", fmt.Errorf("Graph API error %d when resolving section notebook", response.StatusCode)
        }</span>

        <span class="cov0" title="0">var sectionInfo struct {
                ID             string `json:"id"`
                DisplayName    string `json:"displayName"`
                ParentNotebook *struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"parentNotebook"`
        }

        if err := json.NewDecoder(response.Body).Decode(&amp;sectionInfo); err != nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Failed to decode section notebook resolution response",
                        "section_id", sectionID,
                        "error", err.Error())
                return "", "", fmt.Errorf("failed to decode Graph API response: %w", err)
        }</span>

        // Validate that we got the parent notebook information
        <span class="cov0" title="0">if sectionInfo.ParentNotebook == nil </span><span class="cov0" title="0">{
                logging.SectionLogger.Error("Section response missing parent notebook information",
                        "section_id", sectionID)
                return "", "", fmt.Errorf("unable to determine parent notebook for section %s", sectionID)
        }</span>

        <span class="cov0" title="0">notebookID = sectionInfo.ParentNotebook.ID
        notebookName = sectionInfo.ParentNotebook.DisplayName

        logging.SectionLogger.Debug("Successfully resolved section notebook ownership",
                "section_id", sectionID,
                "section_name", sectionInfo.DisplayName,
                "notebook_id", notebookID,
                "notebook_name", notebookName)

        return notebookID, notebookName, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
